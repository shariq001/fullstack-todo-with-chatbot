{"version":3,"sources":["../../../../frontend/node_modules/better-auth/src/adapters/kysely-adapter/node-sqlite-dialect.ts"],"sourcesContent":["/**\n * @see {@link https://nodejs.org/api/sqlite.html} - Node.js SQLite API documentation\n */\n\nimport type { DatabaseSync } from \"node:sqlite\";\nimport type {\n\tDatabaseConnection,\n\tDatabaseIntrospector,\n\tDatabaseMetadata,\n\tDatabaseMetadataOptions,\n\tDialect,\n\tDialectAdapter,\n\tDialectAdapterBase,\n\tDriver,\n\tKysely,\n\tQueryCompiler,\n\tQueryResult,\n\tSchemaMetadata,\n\tTableMetadata,\n} from \"kysely\";\nimport {\n\tCompiledQuery,\n\tDEFAULT_MIGRATION_LOCK_TABLE,\n\tDEFAULT_MIGRATION_TABLE,\n\tDefaultQueryCompiler,\n\tsql,\n} from \"kysely\";\n\nclass NodeSqliteAdapter implements DialectAdapterBase {\n\tget supportsCreateIfNotExists(): boolean {\n\t\treturn true;\n\t}\n\n\tget supportsTransactionalDdl(): boolean {\n\t\treturn false;\n\t}\n\n\tget supportsReturning(): boolean {\n\t\treturn true;\n\t}\n\n\tasync acquireMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\n\tasync releaseMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\tget supportsOutput(): boolean {\n\t\treturn true;\n\t}\n}\n\n/**\n * Config for the SQLite dialect.\n */\nexport interface NodeSqliteDialectConfig {\n\t/**\n\t * A sqlite DatabaseSync instance or a function that returns one.\n\t */\n\tdatabase: DatabaseSync;\n\n\t/**\n\t * Called once when the first query is executed.\n\t */\n\tonCreateConnection?:\n\t\t| ((connection: DatabaseConnection) => Promise<void>)\n\t\t| undefined;\n}\n\nclass NodeSqliteDriver implements Driver {\n\treadonly #config: NodeSqliteDialectConfig;\n\treadonly #connectionMutex = new ConnectionMutex();\n\n\t#db?: DatabaseSync;\n\t#connection?: DatabaseConnection;\n\n\tconstructor(config: NodeSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tasync init(): Promise<void> {\n\t\tthis.#db = this.#config.database;\n\n\t\tthis.#connection = new NodeSqliteConnection(this.#db);\n\n\t\tif (this.#config.onCreateConnection) {\n\t\t\tawait this.#config.onCreateConnection(this.#connection);\n\t\t}\n\t}\n\n\tasync acquireConnection(): Promise<DatabaseConnection> {\n\t\t// SQLite only has one single connection. We use a mutex here to wait\n\t\t// until the single connection has been released.\n\t\tawait this.#connectionMutex.lock();\n\t\treturn this.#connection!;\n\t}\n\n\tasync beginTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"begin\"));\n\t}\n\n\tasync commitTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"commit\"));\n\t}\n\n\tasync rollbackTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"rollback\"));\n\t}\n\n\tasync releaseConnection(): Promise<void> {\n\t\tthis.#connectionMutex.unlock();\n\t}\n\n\tasync destroy(): Promise<void> {\n\t\tthis.#db?.close();\n\t}\n}\n\nclass NodeSqliteConnection implements DatabaseConnection {\n\treadonly #db: DatabaseSync;\n\n\tconstructor(db: DatabaseSync) {\n\t\tthis.#db = db;\n\t}\n\n\texecuteQuery<O>(compiledQuery: CompiledQuery): Promise<QueryResult<O>> {\n\t\tconst { sql, parameters } = compiledQuery;\n\t\tconst stmt = this.#db.prepare(sql);\n\n\t\tconst rows = stmt.all(...(parameters as any[])) as O[];\n\n\t\treturn Promise.resolve({\n\t\t\trows,\n\t\t});\n\t}\n\n\tasync *streamQuery() {\n\t\tthrow new Error(\"Streaming query is not supported by SQLite driver.\");\n\t}\n}\n\nclass ConnectionMutex {\n\t#promise?: Promise<void>;\n\t#resolve?: () => void;\n\n\tasync lock(): Promise<void> {\n\t\twhile (await this.#promise) {\n\t\t\tawait this.#promise;\n\t\t}\n\n\t\tthis.#promise = new Promise((resolve) => {\n\t\t\tthis.#resolve = resolve;\n\t\t});\n\t}\n\n\tunlock(): void {\n\t\tconst resolve = this.#resolve;\n\n\t\tthis.#promise = undefined;\n\t\tthis.#resolve = undefined;\n\n\t\tresolve?.();\n\t}\n}\n\nclass NodeSqliteIntrospector implements DatabaseIntrospector {\n\treadonly #db: Kysely<unknown>;\n\n\tconstructor(db: Kysely<unknown>) {\n\t\tthis.#db = db;\n\t}\n\n\tasync getSchemas(): Promise<SchemaMetadata[]> {\n\t\t// Sqlite doesn't support schemas.\n\t\treturn [];\n\t}\n\n\tasync getTables(\n\t\toptions: DatabaseMetadataOptions = { withInternalKyselyTables: false },\n\t): Promise<TableMetadata[]> {\n\t\tlet query = this.#db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_schema\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"type\", \"=\", \"table\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"not like\", \"sqlite_%\")\n\t\t\t.select(\"name\")\n\t\t\t.$castTo<{ name: string }>();\n\n\t\tif (!options.withInternalKyselyTables) {\n\t\t\tquery = query\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_TABLE)\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_LOCK_TABLE);\n\t\t}\n\n\t\tconst tables = await query.execute();\n\t\treturn Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));\n\t}\n\n\tasync getMetadata(\n\t\toptions?: DatabaseMetadataOptions | undefined,\n\t): Promise<DatabaseMetadata> {\n\t\treturn {\n\t\t\ttables: await this.getTables(options),\n\t\t};\n\t}\n\n\tasync #getTableMetadata(table: string): Promise<TableMetadata> {\n\t\tconst db = this.#db;\n\n\t\t// Get the SQL that was used to create the table.\n\t\tconst createSql = await db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_master\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"=\", table)\n\t\t\t.select(\"sql\")\n\t\t\t.$castTo<{ sql: string | undefined }>()\n\t\t\t.execute();\n\n\t\t// Try to find the name of the column that has `autoincrement` >&\n\t\tconst autoIncrementCol = createSql[0]?.sql\n\t\t\t?.split(/[\\(\\),]/)\n\t\t\t?.find((it) => it.toLowerCase().includes(\"autoincrement\"))\n\t\t\t?.split(/\\s+/)?.[0]\n\t\t\t?.replace(/[\"`]/g, \"\");\n\n\t\tconst columns = await db\n\t\t\t.selectFrom(\n\t\t\t\tsql<{\n\t\t\t\t\tname: string;\n\t\t\t\t\ttype: string;\n\t\t\t\t\tnotnull: 0 | 1;\n\t\t\t\t\tdflt_value: any;\n\t\t\t\t}>`pragma_table_info(${table})`.as(\"table_info\"),\n\t\t\t)\n\t\t\t.select([\"name\", \"type\", \"notnull\", \"dflt_value\"])\n\t\t\t.execute();\n\n\t\treturn {\n\t\t\tname: table,\n\t\t\tcolumns: columns.map((col) => ({\n\t\t\t\tname: col.name,\n\t\t\t\tdataType: col.type,\n\t\t\t\tisNullable: !col.notnull,\n\t\t\t\tisAutoIncrementing: col.name === autoIncrementCol,\n\t\t\t\thasDefaultValue: col.dflt_value != null,\n\t\t\t})),\n\t\t\tisView: true,\n\t\t};\n\t}\n}\n\nclass NodeSqliteQueryCompiler extends DefaultQueryCompiler {\n\tprotected override getCurrentParameterPlaceholder() {\n\t\treturn \"?\";\n\t}\n\n\tprotected override getLeftIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getRightIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getAutoIncrement() {\n\t\treturn \"autoincrement\";\n\t}\n}\n\nexport class NodeSqliteDialect implements Dialect {\n\treadonly #config: NodeSqliteDialectConfig;\n\n\tconstructor(config: NodeSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tcreateDriver(): Driver {\n\t\treturn new NodeSqliteDriver(this.#config);\n\t}\n\n\tcreateQueryCompiler(): QueryCompiler {\n\t\treturn new NodeSqliteQueryCompiler();\n\t}\n\n\tcreateAdapter(): DialectAdapter {\n\t\treturn new NodeSqliteAdapter();\n\t}\n\n\tcreateIntrospector(db: Kysely<any>): DatabaseIntrospector {\n\t\treturn new NodeSqliteIntrospector(db);\n\t}\n}\n"],"names":["#config","#connectionMutex","#db","#connection","sql","#promise","#resolve","#getTableMetadata"],"mappings":"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"}