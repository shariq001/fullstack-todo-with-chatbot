{"version":3,"sources":["../../../../frontend/node_modules/better-auth/dist/adapters/kysely-adapter/index.mjs","../../../../frontend/node_modules/better-auth/src/adapters/kysely-adapter/kysely-adapter.ts"],"sourcesContent":["import { createKyselyAdapter, getKyselyDatabaseType } from \"./dialect.mjs\";\nimport { kyselyAdapter } from \"./kysely-adapter.mjs\";\n\nexport { createKyselyAdapter, getKyselyDatabaseType, kyselyAdapter };","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport type {\n\tInsertQueryBuilder,\n\tKysely,\n\tRawBuilder,\n\tUpdateQueryBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\ninterface KyselyAdapterConfig {\n\t/**\n\t * Database type.\n\t */\n\ttype?: KyselyDatabaseType | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * Use plural for table names.\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const kyselyAdapter = (\n\tdb: Kysely<any>,\n\tconfig?: KyselyAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter = (\n\t\tdb: Kysely<any>,\n\t): AdapterFactoryCustomizeAdapterCreator => {\n\t\treturn ({\n\t\t\tgetFieldName,\n\t\t\tschema,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetModelName,\n\t\t}) => {\n\t\t\tconst selectAllJoins = (join: JoinConfig | undefined) => {\n\t\t\t\t// Use selectAll which will handle column naming appropriately\n\t\t\t\tconst allSelects: RawBuilder<unknown>[] = [];\n\t\t\t\tconst allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[] = [];\n\t\t\t\tif (join) {\n\t\t\t\t\tfor (const [joinModel, _] of Object.entries(join)) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(joinModel)]?.fields;\n\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\tif (!fields) continue;\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const [field, fieldAttr] of Object.entries(fields)) {\n\t\t\t\t\t\t\tallSelects.push(\n\t\t\t\t\t\t\t\tsql`${sql.ref(`join_${joinModelName}`)}.${sql.ref(fieldAttr.fieldName || field)} as ${sql.ref(`_joined_${joinModelName}_${fieldAttr.fieldName || field}`)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallSelectsStr.push({\n\t\t\t\t\t\t\t\tjoinModel: joinModel,\n\t\t\t\t\t\t\t\tjoinModelRef: joinModelName,\n\t\t\t\t\t\t\t\tfieldName: fieldAttr.fieldName || field,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { allSelectsStr, allSelects };\n\t\t\t};\n\n\t\t\tconst withReturning = async (\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t\tbuilder:\n\t\t\t\t\t| InsertQueryBuilder<any, any, any>\n\t\t\t\t\t| UpdateQueryBuilder<any, string, string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\twhere: Where[],\n\t\t\t) => {\n\t\t\t\tlet res: any;\n\t\t\t\tif (config?.type === \"mysql\") {\n\t\t\t\t\t// This isn't good, but kysely doesn't support returning in mysql and it doesn't return the inserted id.\n\t\t\t\t\t// Change this if there is a better way.\n\t\t\t\t\tawait builder.execute();\n\t\t\t\t\tconst field = values.id\n\t\t\t\t\t\t? \"id\"\n\t\t\t\t\t\t: where.length > 0 && where[0]?.field\n\t\t\t\t\t\t\t? where[0].field\n\t\t\t\t\t\t\t: \"id\";\n\n\t\t\t\t\tif (!values.id && where.length === 0) {\n\t\t\t\t\t\tres = await db\n\t\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = values[field] || where[0]?.value;\n\t\t\t\t\tres = await db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t.where(getFieldName({ model, field }), \"=\", value)\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\tres = await builder.outputAll(\"inserted\").executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tres = await builder.returningAll().executeTakeFirst();\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\tfunction convertWhereClause(model: string, w?: Where[] | undefined) {\n\t\t\t\tif (!w)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tand: null,\n\t\t\t\t\t\tor: null,\n\t\t\t\t\t};\n\n\t\t\t\tconst conditions = {\n\t\t\t\t\tand: [] as any[],\n\t\t\t\t\tor: [] as any[],\n\t\t\t\t};\n\n\t\t\t\tw.forEach((condition) => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t\tvalue: _value,\n\t\t\t\t\t\toperator = \"=\",\n\t\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t\t} = condition;\n\t\t\t\t\tconst value: any = _value;\n\t\t\t\t\tconst field: string | any = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst expr = (eb: any) => {\n\t\t\t\t\t\tconst f = `${model}.${field}`;\n\t\t\t\t\t\tif (operator.toLowerCase() === \"in\") {\n\t\t\t\t\t\t\treturn eb(f, \"in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator.toLowerCase() === \"not_in\") {\n\t\t\t\t\t\t\treturn eb(f, \"not in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"contains\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"eq\") {\n\t\t\t\t\t\t\treturn eb(f, \"=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ne\") {\n\t\t\t\t\t\t\treturn eb(f, \"<>\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gt\") {\n\t\t\t\t\t\t\treturn eb(f, \">\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gte\") {\n\t\t\t\t\t\t\treturn eb(f, \">=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lt\") {\n\t\t\t\t\t\t\treturn eb(f, \"<\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lte\") {\n\t\t\t\t\t\t\treturn eb(f, \"<=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn eb(f, operator, value);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (connector === \"OR\") {\n\t\t\t\t\t\tconditions.or.push(expr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconditions.and.push(expr);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tand: conditions.and.length ? conditions.and : null,\n\t\t\t\t\tor: conditions.or.length ? conditions.or : null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction processJoinedResults(\n\t\t\t\trows: any[],\n\t\t\t\tjoinConfig: JoinConfig | undefined,\n\t\t\t\tallSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[],\n\t\t\t) {\n\t\t\t\tif (!joinConfig || !rows.length) {\n\t\t\t\t\treturn rows;\n\t\t\t\t}\n\n\t\t\t\t// Group rows by main model ID\n\t\t\t\tconst groupedByMainId = new Map<string, any>();\n\n\t\t\t\tfor (const currentRow of rows) {\n\t\t\t\t\t// Separate main model columns from joined columns\n\t\t\t\t\tconst mainModelFields: Record<string, any> = {};\n\t\t\t\t\tconst joinedModelFields: Record<string, Record<string, any>> = {};\n\n\t\t\t\t\t// Initialize joined model fields map\n\t\t\t\t\tfor (const [joinModel] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Distribute all columns - collect complete objects per model\n\t\t\t\t\tfor (const [key, value] of Object.entries(currentRow)) {\n\t\t\t\t\t\tconst keyStr = String(key);\n\t\t\t\t\t\tlet assigned = false;\n\n\t\t\t\t\t\t// Check if this is a joined column\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tjoinModel,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tjoinModelRef,\n\t\t\t\t\t\t} of allSelectsStr) {\n\t\t\t\t\t\t\tif (keyStr === `_joined_${joinModelRef}_${fieldName}`) {\n\t\t\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)]![\n\t\t\t\t\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t] = value;\n\t\t\t\t\t\t\t\tassigned = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!assigned) {\n\t\t\t\t\t\t\tmainModelFields[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mainId = mainModelFields.id;\n\t\t\t\t\tif (!mainId) continue;\n\n\t\t\t\t\t// Initialize or get existing entry for this main model\n\t\t\t\t\tif (!groupedByMainId.has(mainId)) {\n\t\t\t\t\t\tconst entry: Record<string, any> = { ...mainModelFields };\n\n\t\t\t\t\t\t// Initialize joined models based on uniqueness\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] =\n\t\t\t\t\t\t\t\tjoinAttr.relation === \"one-to-one\" ? null : [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroupedByMainId.set(mainId, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst entry = groupedByMainId.get(mainId)!;\n\n\t\t\t\t\t// Add joined records to the entry\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\n\t\t\t\t\t\tconst joinedObj = joinedModelFields[getModelName(joinModel)];\n\n\t\t\t\t\t\tconst hasData =\n\t\t\t\t\t\t\tjoinedObj &&\n\t\t\t\t\t\t\tObject.keys(joinedObj).length > 0 &&\n\t\t\t\t\t\t\tObject.values(joinedObj).some(\n\t\t\t\t\t\t\t\t(value) => value !== null && value !== undefined,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isUnique) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] = hasData ? joinedObj : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For arrays, append if not already there (deduplicate by id) and respect limit\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName]) && hasData) {\n\t\t\t\t\t\t\t\t// Check if we've reached the limit before processing\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length >= limit) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get the id field name using getFieldName to ensure correct transformation\n\t\t\t\t\t\t\t\tconst idFieldName = getFieldName({\n\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst joinedId = joinedObj[idFieldName];\n\n\t\t\t\t\t\t\t\t// Only deduplicate if we have an id field\n\t\t\t\t\t\t\t\tif (joinedId) {\n\t\t\t\t\t\t\t\t\tconst exists = entry[joinModelName].some(\n\t\t\t\t\t\t\t\t\t\t(item: any) => item[idFieldName] === joinedId,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!exists && entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If no id field, still add the object if it has data and limit not reached\n\t\t\t\t\t\t\t\t\tif (entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = Array.from(groupedByMainId.values());\n\n\t\t\t\t// Apply final limit to non-unique join arrays as a safety measure\n\t\t\t\tfor (const entry of result) {\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tif (joinAttr.relation !== \"one-to-one\") {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName])) {\n\t\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length > limit) {\n\t\t\t\t\t\t\t\t\tentry[joinModelName] = entry[joinModelName].slice(0, limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ data, model }) {\n\t\t\t\t\tconst builder = db.insertInto(model).values(data);\n\t\t\t\t\tconst returned = await withReturning(data, builder, model, []);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (!res || !Array.isArray(res) || res.length === 0) return null;\n\n\t\t\t\t\t// Get the first row from the result array\n\t\t\t\t\tconst row = res[0];\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst processedRows = processJoinedResults(\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\tjoin,\n\t\t\t\t\t\t\tallSelectsStr,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn processedRows[0] as any;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn row as any;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\n\t\t\t\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tif (!sortBy) {\n\t\t\t\t\t\t\t\t\t\tb = b.orderBy(getFieldName({ model, field: \"id\" }));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tb = b.offset(offset).fetch(limit || 100);\n\t\t\t\t\t\t\t\t} else if (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.top(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.limit(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.offset(offset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\tb = b.orderBy(\n\t\t\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\t// it's possible users provide a schema name in the model name (`<schema>.<model>`)\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tquery = query.orderBy(\n\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await query.execute();\n\n\t\t\t\t\tif (!res) return [];\n\t\t\t\t\tif (join) return processJoinedResults(res, join, allSelectsStr);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\treturn await withReturning(values as any, query, model, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numUpdatedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t// a temporal solution for counting other than \"*\" - see more - https://www.sqlite.org/quirks.html#double_quoted_string_literals_are_accepted\n\t\t\t\t\t\t.select(db.fn.count(\"id\").as(\"count\"));\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (typeof res[0]!.count === \"number\") {\n\t\t\t\t\t\treturn res[0]!.count;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof res[0]!.count === \"bigint\") {\n\t\t\t\t\t\treturn Number(res[0]!.count);\n\t\t\t\t\t}\n\t\t\t\t\treturn parseInt(res[0]!.count);\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tawait query.execute();\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numDeletedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"kysely\",\n\t\t\tadapterName: \"Kysely Adapter\",\n\t\t\tusePlural: config?.usePlural,\n\t\t\tdebugLogs: config?.debugLogs,\n\t\t\tsupportsBooleans:\n\t\t\t\tconfig?.type === \"sqlite\" ||\n\t\t\t\tconfig?.type === \"mssql\" ||\n\t\t\t\tconfig?.type === \"mysql\" ||\n\t\t\t\t!config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsDates:\n\t\t\t\tconfig?.type === \"sqlite\" || config?.type === \"mssql\" || !config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig?.type === \"postgres\"\n\t\t\t\t\t? true // even if there is JSON support, only pg supports passing direct json, all others must stringify\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: false, // Even if field supports JSON, we must pass stringified arrays to the database.\n\t\t\tsupportsUUIDs: config?.type === \"postgres\" ? true : false,\n\t\t\ttransaction: config?.transaction\n\t\t\t\t? (cb) =>\n\t\t\t\t\t\tdb.transaction().execute((trx) => {\n\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\tadapter: createCustomAdapter(trx),\n\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t})\n\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"names":["lazyOptions: BetterAuthOptions | null","allSelects: RawBuilder<unknown>[]","allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[]","res: any","db","value: any","field: string | any","mainModelFields: Record<string, any>","joinedModelFields: Record<string, Record<string, any>>","entry: Record<string, any>","entry","query: any","eb","join","adapterOptions: AdapterFactoryOptions | null"],"mappings":"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","ignoreList":[0,1]}