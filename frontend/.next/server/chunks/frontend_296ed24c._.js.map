{"version":3,"sources":["../../../../frontend/node_modules/jose/dist/webapi/lib/crypto_key.js","../../../../frontend/node_modules/jose/dist/webapi/lib/invalid_key_input.js","../../../../frontend/node_modules/jose/dist/webapi/lib/is_object.js","../../../../frontend/node_modules/%40better-auth/utils/dist/hex.mjs","../../../../frontend/node_modules/%40better-auth/utils/dist/index.mjs","../../../../frontend/node_modules/%40better-auth/utils/dist/base64.mjs","../../../../frontend/node_modules/%40better-auth/core/dist/db/index.mjs","../../../../frontend/node_modules/zod/v4/classic/compat.js","../../../../frontend/node_modules/zod/v4/classic/from-json-schema.js","../../../../frontend/node_modules/rou3/dist/index.mjs","../../../../frontend/node_modules/%40better-auth/utils/dist/binary.mjs","../../../../frontend/node_modules/better-auth/dist/_virtual/rolldown_runtime.mjs","../../../../frontend/node_modules/zod/index.js","../../../../frontend/node_modules/%40better-fetch/fetch/dist/index.js","../../../../frontend/node_modules/defu/dist/defu.mjs","../../../../frontend/node_modules/zod/v4/classic/external.js","../../../../frontend/node_modules/jose/dist/webapi/lib/buffer_utils.js","../../../../frontend/node_modules/jose/dist/webapi/lib/is_key_like.js","../../../../frontend/node_modules/jose/dist/webapi/lib/digest.js","../../../../frontend/node_modules/jose/dist/webapi/lib/check_key_length.js","../../../../frontend/node_modules/jose/dist/webapi/lib/private_symbols.js","../../../../frontend/node_modules/jose/dist/webapi/lib/is_disjoint.js","../../../../frontend/node_modules/jose/dist/webapi/lib/validate_algorithms.js","../../../../frontend/node_modules/jose/dist/webapi/util/errors.js","../../../../frontend/node_modules/jose/dist/webapi/lib/base64.js","../../../../frontend/node_modules/jose/dist/webapi/lib/aeskw.js","../../../../frontend/node_modules/jose/dist/webapi/lib/jwk_to_key.js","../../../../frontend/node_modules/better-auth/src/utils/constants.ts","../../../../frontend/node_modules/jose/dist/webapi/jwe/compact/encrypt.js","../../../../frontend/node_modules/jose/dist/webapi/lib/is_jwk.js","../../../../frontend/node_modules/jose/dist/webapi/lib/cek.js","../../../../frontend/node_modules/jose/dist/webapi/lib/validate_crit.js","../../../../frontend/node_modules/jose/dist/webapi/lib/iv.js","../../../../frontend/node_modules/jose/dist/webapi/lib/subtle_dsa.js","../../../../frontend/node_modules/jose/dist/webapi/jws/compact/sign.js","../../../../frontend/node_modules/jose/dist/webapi/lib/check_cek_length.js","../../../../frontend/node_modules/better-auth/src/utils/time.ts","../../../../frontend/node_modules/%40better-auth/core/src/context/global.ts","../../../../frontend/node_modules/better-auth/src/utils/date.ts","../../../../frontend/node_modules/%40better-auth/core/src/async_hooks/index.ts","../../../../frontend/node_modules/better-auth/src/db/field.ts","../../../../frontend/node_modules/jose/dist/webapi/key/export.js","../../../../frontend/node_modules/jose/dist/webapi/lib/check_iv_length.js","../../../../frontend/node_modules/jose/dist/webapi/jwt/encrypt.js","../../../../frontend/node_modules/zod/v4/classic/coerce.js","../../../../frontend/node_modules/jose/dist/webapi/util/base64url.js","../../../../frontend/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","../../../../frontend/node_modules/better-call/src/error.ts","../../../../frontend/node_modules/better-auth/src/db/field-converter.ts","../../../../frontend/node_modules/better-auth/src/utils/is-promise.ts","../../../../frontend/node_modules/jose/dist/webapi/jwks/remote.js","../../../../frontend/node_modules/better-auth/dist/utils/index.mjs","../../../../frontend/node_modules/%40better-auth/utils/dist/hash.mjs","../../../../frontend/node_modules/jose/dist/webapi/lib/rsaes.js","../../../../frontend/node_modules/jose/dist/webapi/lib/ecdhes.js","../../../../frontend/node_modules/jose/dist/webapi/lib/check_key_type.js","../../../../frontend/node_modules/jose/dist/webapi/jwks/local.js","../../../../frontend/node_modules/jose/dist/webapi/lib/jwt_claims_set.js","../../../../frontend/node_modules/jose/dist/webapi/lib/sign.js","../../../../frontend/node_modules/jose/dist/webapi/lib/key_to_jwk.js","../../../../frontend/node_modules/jose/dist/webapi/lib/aesgcmkw.js","../../../../frontend/node_modules/jose/dist/webapi/jwe/compact/decrypt.js","../../../../frontend/node_modules/jose/dist/webapi/jwt/decrypt.js","../../../../frontend/node_modules/jose/dist/webapi/lib/verify.js","../../../../frontend/node_modules/jose/dist/webapi/jws/compact/verify.js","../../../../frontend/node_modules/jose/dist/webapi/jwt/verify.js","../../../../frontend/node_modules/jose/dist/webapi/jwt/sign.js","../../../../frontend/node_modules/jose/dist/webapi/util/decode_protected_header.js","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/create-authorization-url.ts","../../../../frontend/node_modules/better-auth/src/api/middlewares/oauth.ts","../../../../frontend/node_modules/better-auth/src/crypto/random.ts","../../../../frontend/node_modules/%40better-auth/utils/dist/hmac.mjs","../../../../frontend/node_modules/jose/dist/webapi/lib/normalize_key.js","../../../../frontend/node_modules/jose/dist/webapi/jwt/unsecured.js","../../../../frontend/node_modules/jose/dist/webapi/util/decode_jwt.js","../../../../frontend/node_modules/better-auth/src/utils/password.ts","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/client-credentials-token.ts","../../../../frontend/node_modules/better-auth/src/api/routes/sign-out.ts","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/refresh-access-token.ts","../../../../frontend/node_modules/jose/dist/webapi/lib/pbes2kw.js","../../../../frontend/node_modules/jose/dist/webapi/key/import.js","../../../../frontend/node_modules/better-auth/src/crypto/buffer.ts","../../../../frontend/node_modules/%40noble/hashes/src/_u64.ts","../../../../frontend/node_modules/better-call/src/validator.ts","../../../../frontend/node_modules/%40better-auth/core/src/db/schema/shared.ts","../../../../frontend/node_modules/better-call/src/utils.ts","../../../../frontend/node_modules/better-auth/src/db/with-hooks.ts","../../../../frontend/node_modules/better-auth/src/oauth2/utils.ts","../../../../frontend/node_modules/better-auth/src/crypto/jwt.ts","../../../../frontend/node_modules/%40noble/hashes/src/utils.ts","../../../../frontend/node_modules/better-auth/src/utils/get-request-ip.ts","../../../../frontend/node_modules/better-auth/src/api/to-auth-endpoints.ts","../../../../frontend/node_modules/better-call/src/endpoint.ts","../../../../frontend/node_modules/better-call/src/cookies.ts","../../../../frontend/node_modules/better-auth/src/utils/wildcard.ts","../../../../frontend/node_modules/better-auth/src/api/routes/error.ts","../../../../frontend/node_modules/jose/dist/webapi/lib/decrypt.js","../../../../frontend/node_modules/better-auth/src/db/schema.ts","../../../../frontend/node_modules/better-auth/src/db/get-schema.ts","../../../../frontend/node_modules/better-auth/src/db/adapter-base.ts","../../../../frontend/node_modules/better-call/src/to-response.ts","../../../../frontend/node_modules/better-call/src/middleware.ts","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/validate-authorization-code.ts","../../../../frontend/node_modules/better-auth/src/db/adapter-kysely.ts","../../../../frontend/node_modules/%40noble/hashes/src/scrypt.ts","../../../../frontend/node_modules/%40noble/hashes/src/sha2.ts","../../../../frontend/node_modules/jose/dist/webapi/lib/encrypt.js","../../../../frontend/node_modules/jose/dist/webapi/jwk/thumbprint.js","../../../../frontend/node_modules/jose/dist/webapi/jws/flattened/sign.js","../../../../frontend/node_modules/%40noble/hashes/src/pbkdf2.ts","../../../../frontend/node_modules/better-auth/src/cookies/cookie-utils.ts","../../../../frontend/node_modules/%40better-auth/core/src/context/endpoint-context.ts","../../../../frontend/node_modules/better-auth/src/oauth2/state.ts","../../../../frontend/node_modules/better-call/src/crypto.ts","../../../../frontend/node_modules/better-auth/src/oauth2/link-account.ts","../../../../frontend/node_modules/%40better-auth/core/src/context/request-state.ts","../../../../frontend/node_modules/better-auth/src/auth/base.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-auth-config.ts","../../../../frontend/node_modules/better-auth/src/context/init.ts","../../../../frontend/node_modules/better-auth/src/api/rate-limiter/index.ts","../../../../frontend/node_modules/better-auth/src/db/to-zod.ts","../../../../frontend/node_modules/jose/dist/webapi/jws/flattened/verify.js","../../../../frontend/node_modules/jose/dist/webapi/jwe/flattened/encrypt.js","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/slack.ts","../../../../frontend/node_modules/jose/dist/webapi/lib/decrypt_key_management.js","../../../../frontend/node_modules/jose/dist/webapi/lib/encrypt_key_management.js","../../../../frontend/node_modules/better-call/src/context.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/vk.ts","../../../../frontend/node_modules/jose/dist/webapi/jwe/flattened/decrypt.js","../../../../frontend/node_modules/better-auth/src/context/helpers.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/linear.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/notion.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/salesforce.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/dropbox.ts","../../../../frontend/node_modules/better-auth/src/api/routes/callback.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/linkedin.ts","../../../../frontend/node_modules/better-call/src/router.ts","../../../../frontend/node_modules/better-auth/src/api/routes/password.ts","../../../../frontend/node_modules/%40better-auth/core/src/api/index.ts","../../../../frontend/node_modules/better-auth/src/db/internal-adapter.ts","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/utils.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/discord.ts","../../../../frontend/node_modules/better-auth/src/api/routes/update-user.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/tiktok.ts","../../../../frontend/node_modules/better-auth/src/utils/url.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/cognito.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/roblox.ts","../../../../frontend/node_modules/better-auth/src/crypto/password.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/apple.ts","../../../../frontend/node_modules/better-auth/src/api/routes/sign-in.ts","../../../../frontend/node_modules/better-auth/src/auth/trusted-origins.ts","../../../../frontend/node_modules/%40better-auth/core/src/oauth2/verify.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/github.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/google.ts","../../../../frontend/node_modules/better-auth/src/cookies/index.ts","../../../../frontend/node_modules/better-auth/src/cookies/session-store.ts","../../../../frontend/node_modules/better-auth/src/crypto/index.ts","../../../../frontend/node_modules/better-auth/src/api/routes/sign-up.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/kakao.ts","../../../../frontend/node_modules/%40noble/ciphers/src/chacha.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/gitlab.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/atlassian.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/paybin.ts","../../../../frontend/node_modules/%40noble/ciphers/src/utils.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/figma.ts","../../../../frontend/node_modules/better-auth/src/api/middlewares/origin-check.ts","../../../../frontend/node_modules/better-call/src/openapi.ts","../../../../frontend/node_modules/%40noble/ciphers/src/_poly1305.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/paypal.ts","../../../../frontend/node_modules/%40noble/hashes/src/_md.ts","../../../../frontend/node_modules/%40noble/hashes/src/hmac.ts","../../../../frontend/node_modules/%40noble/hashes/src/hkdf.ts","../../../../frontend/node_modules/better-auth/src/api/routes/account.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/line.ts","../../../../frontend/node_modules/better-auth/src/api/routes/email-verification.ts","../../../../frontend/node_modules/better-auth/src/state.ts","../../../../frontend/node_modules/better-auth/src/api/index.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/huggingface.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/vercel.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/reddit.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/naver.ts","../../../../frontend/node_modules/better-auth/src/db/get-migration.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/spotify.ts","../../../../frontend/node_modules/%40better-auth/core/src/context/transaction.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/facebook.ts","../../../../frontend/node_modules/%40noble/ciphers/src/_arx.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/polar.ts","../../../../frontend/node_modules/better-auth/src/context/create-context.ts","../../../../frontend/node_modules/better-auth/src/api/routes/session.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/zoom.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/twitch.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/kick.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/twitter.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/microsoft-entra-id.ts","../../../../frontend/node_modules/%40better-auth/core/src/social-providers/index.ts","../../../../frontend/node_modules/%40better-fetch/fetch/src/retry.ts","../../../../frontend/node_modules/%40better-fetch/fetch/src/utils.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/utils/package-json.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-database.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-framework.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-project-info.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/utils/import-util.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-system-info.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/detectors/detect-runtime.ts","../../../../frontend/node_modules/%40better-fetch/fetch/src/create-fetch/index.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/utils/hash.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/utils/id.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/project-id.ts","../../../../frontend/node_modules/%40better-auth/telemetry/src/index.ts","../../../../frontend/node_modules/%40better-fetch/fetch/src/url.ts","../../../../frontend/node_modules/better-auth/dist/index.mjs","../../../../frontend/app/api/auth/%5B...auth%5D/route.ts","../../../../frontend/node_modules/next/src/build/templates/app-route.ts"],"sourcesContent":["const unusable = (name, prop = 'algorithm.name') => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\nconst isAlgorithm = (algorithm, name) => algorithm.name === name;\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87': {\n            if (!isAlgorithm(key.algorithm, alg))\n                throw unusable(alg);\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport const invalidKeyInput = (actual, ...types) => message('Key must be ', actual, ...types);\nexport const withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);\n","const isObjectLike = (value) => typeof value === 'object' && value !== null;\nexport function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n","const hexadecimal = \"0123456789abcdef\";\nconst hex = {\n  encode: (data) => {\n    if (typeof data === \"string\") {\n      data = new TextEncoder().encode(data);\n    }\n    if (data.byteLength === 0) {\n      return \"\";\n    }\n    const buffer = new Uint8Array(data);\n    let result = \"\";\n    for (const byte of buffer) {\n      result += byte.toString(16).padStart(2, \"0\");\n    }\n    return result;\n  },\n  decode: (data) => {\n    if (!data) {\n      return \"\";\n    }\n    if (typeof data === \"string\") {\n      if (data.length % 2 !== 0) {\n        throw new Error(\"Invalid hexadecimal string\");\n      }\n      if (!new RegExp(`^[${hexadecimal}]+$`).test(data)) {\n        throw new Error(\"Invalid hexadecimal string\");\n      }\n      const result = new Uint8Array(data.length / 2);\n      for (let i = 0; i < data.length; i += 2) {\n        result[i / 2] = parseInt(data.slice(i, i + 2), 16);\n      }\n      return new TextDecoder().decode(result);\n    }\n    return new TextDecoder().decode(data);\n  }\n};\n\nexport { hex };\n","function getWebcryptoSubtle() {\n  const cr = typeof globalThis !== \"undefined\" && globalThis.crypto;\n  if (cr && typeof cr.subtle === \"object\" && cr.subtle != null)\n    return cr.subtle;\n  throw new Error(\"crypto.subtle must be defined\");\n}\n\nexport { getWebcryptoSubtle };\n","function getAlphabet(urlSafe) {\n  return urlSafe ? \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\" : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n}\nfunction base64Encode(data, alphabet, padding) {\n  let result = \"\";\n  let buffer = 0;\n  let shift = 0;\n  for (const byte of data) {\n    buffer = buffer << 8 | byte;\n    shift += 8;\n    while (shift >= 6) {\n      shift -= 6;\n      result += alphabet[buffer >> shift & 63];\n    }\n  }\n  if (shift > 0) {\n    result += alphabet[buffer << 6 - shift & 63];\n  }\n  if (padding) {\n    const padCount = (4 - result.length % 4) % 4;\n    result += \"=\".repeat(padCount);\n  }\n  return result;\n}\nfunction base64Decode(data, alphabet) {\n  const decodeMap = /* @__PURE__ */ new Map();\n  for (let i = 0; i < alphabet.length; i++) {\n    decodeMap.set(alphabet[i], i);\n  }\n  const result = [];\n  let buffer = 0;\n  let bitsCollected = 0;\n  for (const char of data) {\n    if (char === \"=\")\n      break;\n    const value = decodeMap.get(char);\n    if (value === void 0) {\n      throw new Error(`Invalid Base64 character: ${char}`);\n    }\n    buffer = buffer << 6 | value;\n    bitsCollected += 6;\n    if (bitsCollected >= 8) {\n      bitsCollected -= 8;\n      result.push(buffer >> bitsCollected & 255);\n    }\n  }\n  return Uint8Array.from(result);\n}\nconst base64 = {\n  encode(data, options = {}) {\n    const alphabet = getAlphabet(false);\n    const buffer = typeof data === \"string\" ? new TextEncoder().encode(data) : new Uint8Array(data);\n    return base64Encode(buffer, alphabet, options.padding ?? true);\n  },\n  decode(data) {\n    if (typeof data !== \"string\") {\n      data = new TextDecoder().decode(data);\n    }\n    const urlSafe = data.includes(\"-\") || data.includes(\"_\");\n    const alphabet = getAlphabet(urlSafe);\n    return base64Decode(data, alphabet);\n  }\n};\nconst base64Url = {\n  encode(data, options = {}) {\n    const alphabet = getAlphabet(true);\n    const buffer = typeof data === \"string\" ? new TextEncoder().encode(data) : new Uint8Array(data);\n    return base64Encode(buffer, alphabet, options.padding ?? true);\n  },\n  decode(data) {\n    const urlSafe = data.includes(\"-\") || data.includes(\"_\");\n    const alphabet = getAlphabet(urlSafe);\n    return base64Decode(data, alphabet);\n  }\n};\n\nexport { base64, base64Url };\n","import { getAuthTables } from \"./get-tables.mjs\";\nimport { coreSchema } from \"./schema/shared.mjs\";\nimport { accountSchema } from \"./schema/account.mjs\";\nimport { rateLimitSchema } from \"./schema/rate-limit.mjs\";\nimport { sessionSchema } from \"./schema/session.mjs\";\nimport { userSchema } from \"./schema/user.mjs\";\nimport { verificationSchema } from \"./schema/verification.mjs\";\n\nexport { accountSchema, coreSchema, getAuthTables, rateLimitSchema, sessionSchema, userSchema, verificationSchema };","// Zod 3 compat layer\nimport * as core from \"../core/index.js\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n    invalid_type: \"invalid_type\",\n    too_big: \"too_big\",\n    too_small: \"too_small\",\n    invalid_format: \"invalid_format\",\n    not_multiple_of: \"not_multiple_of\",\n    unrecognized_keys: \"unrecognized_keys\",\n    invalid_union: \"invalid_union\",\n    invalid_key: \"invalid_key\",\n    invalid_element: \"invalid_element\",\n    invalid_value: \"invalid_value\",\n    custom: \"custom\",\n};\nexport { $brand, config } from \"../core/index.js\";\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map) {\n    core.config({\n        customError: map,\n    });\n}\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap() {\n    return core.config().customError;\n}\n/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n","import { globalRegistry } from \"../core/registries.js\";\nimport * as _checks from \"./checks.js\";\nimport * as _iso from \"./iso.js\";\nimport * as _schemas from \"./schemas.js\";\n// Local z object to avoid circular dependency with ../index.js\nconst z = {\n    ..._schemas,\n    ..._checks,\n    iso: _iso,\n};\n// Keys that are recognized and handled by the conversion logic\nconst RECOGNIZED_KEYS = new Set([\n    // Schema identification\n    \"$schema\",\n    \"$ref\",\n    \"$defs\",\n    \"definitions\",\n    // Core schema keywords\n    \"$id\",\n    \"id\",\n    \"$comment\",\n    \"$anchor\",\n    \"$vocabulary\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n    // Type\n    \"type\",\n    \"enum\",\n    \"const\",\n    // Composition\n    \"anyOf\",\n    \"oneOf\",\n    \"allOf\",\n    \"not\",\n    // Object\n    \"properties\",\n    \"required\",\n    \"additionalProperties\",\n    \"patternProperties\",\n    \"propertyNames\",\n    \"minProperties\",\n    \"maxProperties\",\n    // Array\n    \"items\",\n    \"prefixItems\",\n    \"additionalItems\",\n    \"minItems\",\n    \"maxItems\",\n    \"uniqueItems\",\n    \"contains\",\n    \"minContains\",\n    \"maxContains\",\n    // String\n    \"minLength\",\n    \"maxLength\",\n    \"pattern\",\n    \"format\",\n    // Number\n    \"minimum\",\n    \"maximum\",\n    \"exclusiveMinimum\",\n    \"exclusiveMaximum\",\n    \"multipleOf\",\n    // Already handled metadata\n    \"description\",\n    \"default\",\n    // Content\n    \"contentEncoding\",\n    \"contentMediaType\",\n    \"contentSchema\",\n    // Unsupported (error-throwing)\n    \"unevaluatedItems\",\n    \"unevaluatedProperties\",\n    \"if\",\n    \"then\",\n    \"else\",\n    \"dependentSchemas\",\n    \"dependentRequired\",\n    // OpenAPI\n    \"nullable\",\n    \"readOnly\",\n]);\nfunction detectVersion(schema, defaultTarget) {\n    const $schema = schema.$schema;\n    if ($schema === \"https://json-schema.org/draft/2020-12/schema\") {\n        return \"draft-2020-12\";\n    }\n    if ($schema === \"http://json-schema.org/draft-07/schema#\") {\n        return \"draft-7\";\n    }\n    if ($schema === \"http://json-schema.org/draft-04/schema#\") {\n        return \"draft-4\";\n    }\n    // Use defaultTarget if provided, otherwise default to draft-2020-12\n    return defaultTarget ?? \"draft-2020-12\";\n}\nfunction resolveRef(ref, ctx) {\n    if (!ref.startsWith(\"#\")) {\n        throw new Error(\"External $ref is not supported, only local refs (#/...) are allowed\");\n    }\n    const path = ref.slice(1).split(\"/\").filter(Boolean);\n    // Handle root reference \"#\"\n    if (path.length === 0) {\n        return ctx.rootSchema;\n    }\n    const defsKey = ctx.version === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n    if (path[0] === defsKey) {\n        const key = path[1];\n        if (!key || !ctx.defs[key]) {\n            throw new Error(`Reference not found: ${ref}`);\n        }\n        return ctx.defs[key];\n    }\n    throw new Error(`Reference not found: ${ref}`);\n}\nfunction convertBaseSchema(schema, ctx) {\n    // Handle unsupported features\n    if (schema.not !== undefined) {\n        // Special case: { not: {} } represents never\n        if (typeof schema.not === \"object\" && Object.keys(schema.not).length === 0) {\n            return z.never();\n        }\n        throw new Error(\"not is not supported in Zod (except { not: {} } for never)\");\n    }\n    if (schema.unevaluatedItems !== undefined) {\n        throw new Error(\"unevaluatedItems is not supported\");\n    }\n    if (schema.unevaluatedProperties !== undefined) {\n        throw new Error(\"unevaluatedProperties is not supported\");\n    }\n    if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {\n        throw new Error(\"Conditional schemas (if/then/else) are not supported\");\n    }\n    if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {\n        throw new Error(\"dependentSchemas and dependentRequired are not supported\");\n    }\n    // Handle $ref\n    if (schema.$ref) {\n        const refPath = schema.$ref;\n        if (ctx.refs.has(refPath)) {\n            return ctx.refs.get(refPath);\n        }\n        if (ctx.processing.has(refPath)) {\n            // Circular reference - use lazy\n            return z.lazy(() => {\n                if (!ctx.refs.has(refPath)) {\n                    throw new Error(`Circular reference not resolved: ${refPath}`);\n                }\n                return ctx.refs.get(refPath);\n            });\n        }\n        ctx.processing.add(refPath);\n        const resolved = resolveRef(refPath, ctx);\n        const zodSchema = convertSchema(resolved, ctx);\n        ctx.refs.set(refPath, zodSchema);\n        ctx.processing.delete(refPath);\n        return zodSchema;\n    }\n    // Handle enum\n    if (schema.enum !== undefined) {\n        const enumValues = schema.enum;\n        // Special case: OpenAPI 3.0 null representation { type: \"string\", nullable: true, enum: [null] }\n        if (ctx.version === \"openapi-3.0\" &&\n            schema.nullable === true &&\n            enumValues.length === 1 &&\n            enumValues[0] === null) {\n            return z.null();\n        }\n        if (enumValues.length === 0) {\n            return z.never();\n        }\n        if (enumValues.length === 1) {\n            return z.literal(enumValues[0]);\n        }\n        // Check if all values are strings\n        if (enumValues.every((v) => typeof v === \"string\")) {\n            return z.enum(enumValues);\n        }\n        // Mixed types - use union of literals\n        const literalSchemas = enumValues.map((v) => z.literal(v));\n        if (literalSchemas.length < 2) {\n            return literalSchemas[0];\n        }\n        return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);\n    }\n    // Handle const\n    if (schema.const !== undefined) {\n        return z.literal(schema.const);\n    }\n    // Handle type\n    const type = schema.type;\n    if (Array.isArray(type)) {\n        // Expand type array into anyOf union\n        const typeSchemas = type.map((t) => {\n            const typeSchema = { ...schema, type: t };\n            return convertBaseSchema(typeSchema, ctx);\n        });\n        if (typeSchemas.length === 0) {\n            return z.never();\n        }\n        if (typeSchemas.length === 1) {\n            return typeSchemas[0];\n        }\n        return z.union(typeSchemas);\n    }\n    if (!type) {\n        // No type specified - empty schema (any)\n        return z.any();\n    }\n    let zodSchema;\n    switch (type) {\n        case \"string\": {\n            let stringSchema = z.string();\n            // Apply format using .check() with Zod format functions\n            if (schema.format) {\n                const format = schema.format;\n                // Map common formats to Zod check functions\n                if (format === \"email\") {\n                    stringSchema = stringSchema.check(z.email());\n                }\n                else if (format === \"uri\" || format === \"uri-reference\") {\n                    stringSchema = stringSchema.check(z.url());\n                }\n                else if (format === \"uuid\" || format === \"guid\") {\n                    stringSchema = stringSchema.check(z.uuid());\n                }\n                else if (format === \"date-time\") {\n                    stringSchema = stringSchema.check(z.iso.datetime());\n                }\n                else if (format === \"date\") {\n                    stringSchema = stringSchema.check(z.iso.date());\n                }\n                else if (format === \"time\") {\n                    stringSchema = stringSchema.check(z.iso.time());\n                }\n                else if (format === \"duration\") {\n                    stringSchema = stringSchema.check(z.iso.duration());\n                }\n                else if (format === \"ipv4\") {\n                    stringSchema = stringSchema.check(z.ipv4());\n                }\n                else if (format === \"ipv6\") {\n                    stringSchema = stringSchema.check(z.ipv6());\n                }\n                else if (format === \"mac\") {\n                    stringSchema = stringSchema.check(z.mac());\n                }\n                else if (format === \"cidr\") {\n                    stringSchema = stringSchema.check(z.cidrv4());\n                }\n                else if (format === \"cidr-v6\") {\n                    stringSchema = stringSchema.check(z.cidrv6());\n                }\n                else if (format === \"base64\") {\n                    stringSchema = stringSchema.check(z.base64());\n                }\n                else if (format === \"base64url\") {\n                    stringSchema = stringSchema.check(z.base64url());\n                }\n                else if (format === \"e164\") {\n                    stringSchema = stringSchema.check(z.e164());\n                }\n                else if (format === \"jwt\") {\n                    stringSchema = stringSchema.check(z.jwt());\n                }\n                else if (format === \"emoji\") {\n                    stringSchema = stringSchema.check(z.emoji());\n                }\n                else if (format === \"nanoid\") {\n                    stringSchema = stringSchema.check(z.nanoid());\n                }\n                else if (format === \"cuid\") {\n                    stringSchema = stringSchema.check(z.cuid());\n                }\n                else if (format === \"cuid2\") {\n                    stringSchema = stringSchema.check(z.cuid2());\n                }\n                else if (format === \"ulid\") {\n                    stringSchema = stringSchema.check(z.ulid());\n                }\n                else if (format === \"xid\") {\n                    stringSchema = stringSchema.check(z.xid());\n                }\n                else if (format === \"ksuid\") {\n                    stringSchema = stringSchema.check(z.ksuid());\n                }\n                // Note: json-string format is not currently supported by Zod\n                // Custom formats are ignored - keep as plain string\n            }\n            // Apply constraints\n            if (typeof schema.minLength === \"number\") {\n                stringSchema = stringSchema.min(schema.minLength);\n            }\n            if (typeof schema.maxLength === \"number\") {\n                stringSchema = stringSchema.max(schema.maxLength);\n            }\n            if (schema.pattern) {\n                // JSON Schema patterns are not implicitly anchored (match anywhere in string)\n                stringSchema = stringSchema.regex(new RegExp(schema.pattern));\n            }\n            zodSchema = stringSchema;\n            break;\n        }\n        case \"number\":\n        case \"integer\": {\n            let numberSchema = type === \"integer\" ? z.number().int() : z.number();\n            // Apply constraints\n            if (typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.min(schema.minimum);\n            }\n            if (typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.max(schema.maximum);\n            }\n            if (typeof schema.exclusiveMinimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.exclusiveMinimum);\n            }\n            else if (schema.exclusiveMinimum === true && typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.minimum);\n            }\n            if (typeof schema.exclusiveMaximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.exclusiveMaximum);\n            }\n            else if (schema.exclusiveMaximum === true && typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.maximum);\n            }\n            if (typeof schema.multipleOf === \"number\") {\n                numberSchema = numberSchema.multipleOf(schema.multipleOf);\n            }\n            zodSchema = numberSchema;\n            break;\n        }\n        case \"boolean\": {\n            zodSchema = z.boolean();\n            break;\n        }\n        case \"null\": {\n            zodSchema = z.null();\n            break;\n        }\n        case \"object\": {\n            const shape = {};\n            const properties = schema.properties || {};\n            const requiredSet = new Set(schema.required || []);\n            // Convert properties - mark optional ones\n            for (const [key, propSchema] of Object.entries(properties)) {\n                const propZodSchema = convertSchema(propSchema, ctx);\n                // If not in required array, make it optional\n                shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();\n            }\n            // Handle propertyNames\n            if (schema.propertyNames) {\n                const keySchema = convertSchema(schema.propertyNames, ctx);\n                const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === \"object\"\n                    ? convertSchema(schema.additionalProperties, ctx)\n                    : z.any();\n                // Case A: No properties (pure record)\n                if (Object.keys(shape).length === 0) {\n                    zodSchema = z.record(keySchema, valueSchema);\n                    break;\n                }\n                // Case B: With properties (intersection of object and looseRecord)\n                const objectSchema = z.object(shape).passthrough();\n                const recordSchema = z.looseRecord(keySchema, valueSchema);\n                zodSchema = z.intersection(objectSchema, recordSchema);\n                break;\n            }\n            // Handle patternProperties\n            if (schema.patternProperties) {\n                // patternProperties: keys matching pattern must satisfy corresponding schema\n                // Use loose records so non-matching keys pass through\n                const patternProps = schema.patternProperties;\n                const patternKeys = Object.keys(patternProps);\n                const looseRecords = [];\n                for (const pattern of patternKeys) {\n                    const patternValue = convertSchema(patternProps[pattern], ctx);\n                    const keySchema = z.string().regex(new RegExp(pattern));\n                    looseRecords.push(z.looseRecord(keySchema, patternValue));\n                }\n                // Build intersection: object schema + all pattern property records\n                const schemasToIntersect = [];\n                if (Object.keys(shape).length > 0) {\n                    // Use passthrough so patternProperties can validate additional keys\n                    schemasToIntersect.push(z.object(shape).passthrough());\n                }\n                schemasToIntersect.push(...looseRecords);\n                if (schemasToIntersect.length === 0) {\n                    zodSchema = z.object({}).passthrough();\n                }\n                else if (schemasToIntersect.length === 1) {\n                    zodSchema = schemasToIntersect[0];\n                }\n                else {\n                    // Chain intersections: (A & B) & C & D ...\n                    let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);\n                    for (let i = 2; i < schemasToIntersect.length; i++) {\n                        result = z.intersection(result, schemasToIntersect[i]);\n                    }\n                    zodSchema = result;\n                }\n                break;\n            }\n            // Handle additionalProperties\n            // In JSON Schema, additionalProperties defaults to true (allow any extra properties)\n            // In Zod, objects strip unknown keys by default, so we need to handle this explicitly\n            const objectSchema = z.object(shape);\n            if (schema.additionalProperties === false) {\n                // Strict mode - no extra properties allowed\n                zodSchema = objectSchema.strict();\n            }\n            else if (typeof schema.additionalProperties === \"object\") {\n                // Extra properties must match the specified schema\n                zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));\n            }\n            else {\n                // additionalProperties is true or undefined - allow any extra properties (passthrough)\n                zodSchema = objectSchema.passthrough();\n            }\n            break;\n        }\n        case \"array\": {\n            // TODO: uniqueItems is not supported\n            // TODO: contains/minContains/maxContains are not supported\n            // Check if this is a tuple (prefixItems or items as array)\n            const prefixItems = schema.prefixItems;\n            const items = schema.items;\n            if (prefixItems && Array.isArray(prefixItems)) {\n                // Tuple with prefixItems (draft-2020-12)\n                const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));\n                const rest = items && typeof items === \"object\" && !Array.isArray(items)\n                    ? convertSchema(items, ctx)\n                    : undefined;\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (Array.isArray(items)) {\n                // Tuple with items array (draft-7)\n                const tupleItems = items.map((item) => convertSchema(item, ctx));\n                const rest = schema.additionalItems && typeof schema.additionalItems === \"object\"\n                    ? convertSchema(schema.additionalItems, ctx)\n                    : undefined; // additionalItems: false means no rest, handled by default tuple behavior\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (items !== undefined) {\n                // Regular array\n                const element = convertSchema(items, ctx);\n                let arraySchema = z.array(element);\n                // Apply constraints\n                if (typeof schema.minItems === \"number\") {\n                    arraySchema = arraySchema.min(schema.minItems);\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    arraySchema = arraySchema.max(schema.maxItems);\n                }\n                zodSchema = arraySchema;\n            }\n            else {\n                // No items specified - array of any\n                zodSchema = z.array(z.any());\n            }\n            break;\n        }\n        default:\n            throw new Error(`Unsupported type: ${type}`);\n    }\n    // Apply metadata\n    if (schema.description) {\n        zodSchema = zodSchema.describe(schema.description);\n    }\n    if (schema.default !== undefined) {\n        zodSchema = zodSchema.default(schema.default);\n    }\n    return zodSchema;\n}\nfunction convertSchema(schema, ctx) {\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    // Convert base schema first (ignoring composition keywords)\n    let baseSchema = convertBaseSchema(schema, ctx);\n    const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;\n    // Process composition keywords LAST (they can appear together)\n    // Handle anyOf - wrap base schema with union\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n        const options = schema.anyOf.map((s) => convertSchema(s, ctx));\n        const anyOfUnion = z.union(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;\n    }\n    // Handle oneOf - exclusive union (exactly one must match)\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n        const options = schema.oneOf.map((s) => convertSchema(s, ctx));\n        const oneOfUnion = z.xor(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;\n    }\n    // Handle allOf - wrap base schema with intersection\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n        if (schema.allOf.length === 0) {\n            baseSchema = hasExplicitType ? baseSchema : z.any();\n        }\n        else {\n            let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);\n            const startIdx = hasExplicitType ? 0 : 1;\n            for (let i = startIdx; i < schema.allOf.length; i++) {\n                result = z.intersection(result, convertSchema(schema.allOf[i], ctx));\n            }\n            baseSchema = result;\n        }\n    }\n    // Handle nullable (OpenAPI 3.0)\n    if (schema.nullable === true && ctx.version === \"openapi-3.0\") {\n        baseSchema = z.nullable(baseSchema);\n    }\n    // Handle readOnly\n    if (schema.readOnly === true) {\n        baseSchema = z.readonly(baseSchema);\n    }\n    // Collect metadata: core schema keywords and unrecognized keys\n    const extraMeta = {};\n    // Core schema keywords that should be captured as metadata\n    const coreMetadataKeys = [\"$id\", \"id\", \"$comment\", \"$anchor\", \"$vocabulary\", \"$dynamicRef\", \"$dynamicAnchor\"];\n    for (const key of coreMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Content keywords - store as metadata\n    const contentMetadataKeys = [\"contentEncoding\", \"contentMediaType\", \"contentSchema\"];\n    for (const key of contentMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Unrecognized keys (custom metadata)\n    for (const key of Object.keys(schema)) {\n        if (!RECOGNIZED_KEYS.has(key)) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    if (Object.keys(extraMeta).length > 0) {\n        ctx.registry.add(baseSchema, extraMeta);\n    }\n    return baseSchema;\n}\n/**\n * Converts a JSON Schema to a Zod schema. This function should be considered semi-experimental. It's behavior is liable to change. */\nexport function fromJSONSchema(schema, params) {\n    // Handle boolean schemas\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    const version = detectVersion(schema, params?.defaultTarget);\n    const defs = (schema.$defs || schema.definitions || {});\n    const ctx = {\n        version,\n        defs,\n        refs: new Map(),\n        processing: new Set(),\n        rootSchema: schema,\n        registry: params?.registry ?? globalRegistry,\n    };\n    return convertSchema(schema, ctx);\n}\n","const NullProtoObj = /* @__PURE__ */ (() => {\n\tconst e = function() {};\n\treturn e.prototype = Object.create(null), Object.freeze(e.prototype), e;\n})();\n\n/**\n* Create a new router context.\n*/\nfunction createRouter() {\n\treturn {\n\t\troot: { key: \"\" },\n\t\tstatic: new NullProtoObj()\n\t};\n}\n\nfunction splitPath(path) {\n\tconst [_, ...s] = path.split(\"/\");\n\treturn s[s.length - 1] === \"\" ? s.slice(0, -1) : s;\n}\nfunction getMatchParams(segments, paramsMap) {\n\tconst params = new NullProtoObj();\n\tfor (const [index, name] of paramsMap) {\n\t\tconst segment = index < 0 ? segments.slice(-(index + 1)).join(\"/\") : segments[index];\n\t\tif (typeof name === \"string\") params[name] = segment;\n\t\telse {\n\t\t\tconst match = segment.match(name);\n\t\t\tif (match) for (const key in match.groups) params[key] = match.groups[key];\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n* Add a route to the router context.\n*/\nfunction addRoute(ctx, method = \"\", path, data) {\n\tmethod = method.toUpperCase();\n\tif (path.charCodeAt(0) !== 47) path = `/${path}`;\n\tpath = path.replace(/\\\\:/g, \"%3A\");\n\tconst segments = splitPath(path);\n\tlet node = ctx.root;\n\tlet _unnamedParamIndex = 0;\n\tconst paramsMap = [];\n\tconst paramsRegexp = [];\n\tfor (let i = 0; i < segments.length; i++) {\n\t\tlet segment = segments[i];\n\t\tif (segment.startsWith(\"**\")) {\n\t\t\tif (!node.wildcard) node.wildcard = { key: \"**\" };\n\t\t\tnode = node.wildcard;\n\t\t\tparamsMap.push([\n\t\t\t\t-(i + 1),\n\t\t\t\tsegment.split(\":\")[1] || \"_\",\n\t\t\t\tsegment.length === 2\n\t\t\t]);\n\t\t\tbreak;\n\t\t}\n\t\tif (segment === \"*\" || segment.includes(\":\")) {\n\t\t\tif (!node.param) node.param = { key: \"*\" };\n\t\t\tnode = node.param;\n\t\t\tif (segment === \"*\") paramsMap.push([\n\t\t\t\ti,\n\t\t\t\t`_${_unnamedParamIndex++}`,\n\t\t\t\ttrue\n\t\t\t]);\n\t\t\telse if (segment.includes(\":\", 1)) {\n\t\t\t\tconst regexp = getParamRegexp(segment);\n\t\t\t\tparamsRegexp[i] = regexp;\n\t\t\t\tnode.hasRegexParam = true;\n\t\t\t\tparamsMap.push([\n\t\t\t\t\ti,\n\t\t\t\t\tregexp,\n\t\t\t\t\tfalse\n\t\t\t\t]);\n\t\t\t} else paramsMap.push([\n\t\t\t\ti,\n\t\t\t\tsegment.slice(1),\n\t\t\t\tfalse\n\t\t\t]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (segment === \"\\\\*\") segment = segments[i] = \"*\";\n\t\telse if (segment === \"\\\\*\\\\*\") segment = segments[i] = \"**\";\n\t\tconst child = node.static?.[segment];\n\t\tif (child) node = child;\n\t\telse {\n\t\t\tconst staticNode = { key: segment };\n\t\t\tif (!node.static) node.static = new NullProtoObj();\n\t\t\tnode.static[segment] = staticNode;\n\t\t\tnode = staticNode;\n\t\t}\n\t}\n\tconst hasParams = paramsMap.length > 0;\n\tif (!node.methods) node.methods = new NullProtoObj();\n\tnode.methods[method] ??= [];\n\tnode.methods[method].push({\n\t\tdata: data || null,\n\t\tparamsRegexp,\n\t\tparamsMap: hasParams ? paramsMap : void 0\n\t});\n\tif (!hasParams) ctx.static[\"/\" + segments.join(\"/\")] = node;\n}\nfunction getParamRegexp(segment) {\n\tconst regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\");\n\treturn /* @__PURE__ */ new RegExp(`^${regex}$`);\n}\n\n/**\n* Find a route by path.\n*/\nfunction findRoute(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst staticNode = ctx.static[path];\n\tif (staticNode && staticNode.methods) {\n\t\tconst staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n\t\tif (staticMatch !== void 0) return staticMatch[0];\n\t}\n\tconst segments = splitPath(path);\n\tconst match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n\tif (match === void 0) return;\n\tif (opts?.params === false) return match;\n\treturn {\n\t\tdata: match.data,\n\t\tparams: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n\t};\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods) {\n\t\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\t\tif (match) return match;\n\t\t}\n\t\tif (node.param && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\tif (node.wildcard && node.wildcard.methods) {\n\t\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) return match;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (node.static) {\n\t\tconst staticChild = node.static[segment];\n\t\tif (staticChild) {\n\t\t\tconst match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n\t\t\tif (match) return match;\n\t\t}\n\t}\n\tif (node.param) {\n\t\tconst match = _lookupTree(ctx, node.param, method, segments, index + 1);\n\t\tif (match) {\n\t\t\tif (node.param.hasRegexParam) {\n\t\t\t\tconst exactMatch = match.find((m) => m.paramsRegexp[index]?.test(segment)) || match.find((m) => !m.paramsRegexp[index]);\n\t\t\t\treturn exactMatch ? [exactMatch] : void 0;\n\t\t\t}\n\t\t\treturn match;\n\t\t}\n\t}\n\tif (node.wildcard && node.wildcard.methods) return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n}\n\n/**\n* Remove a route from the router context.\n*/\nfunction removeRoute(ctx, method, path) {\n\tconst segments = splitPath(path);\n\treturn _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n\tif (index === segments.length) {\n\t\tif (node.methods && method in node.methods) {\n\t\t\tdelete node.methods[method];\n\t\t\tif (Object.keys(node.methods).length === 0) node.methods = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst segment = segments[index];\n\tif (segment === \"*\") {\n\t\tif (node.param) {\n\t\t\t_remove(node.param, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.param)) node.param = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tif (segment.startsWith(\"**\")) {\n\t\tif (node.wildcard) {\n\t\t\t_remove(node.wildcard, method, segments, index + 1);\n\t\t\tif (_isEmptyNode(node.wildcard)) node.wildcard = void 0;\n\t\t}\n\t\treturn;\n\t}\n\tconst childNode = node.static?.[segment];\n\tif (childNode) {\n\t\t_remove(childNode, method, segments, index + 1);\n\t\tif (_isEmptyNode(childNode)) {\n\t\t\tdelete node.static[segment];\n\t\t\tif (Object.keys(node.static).length === 0) node.static = void 0;\n\t\t}\n\t}\n}\nfunction _isEmptyNode(node) {\n\treturn node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\n/**\n* Find all route patterns that match the given path.\n*/\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n\tif (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);\n\tconst segments = splitPath(path);\n\tconst matches = _findAll(ctx, ctx.root, method, segments, 0);\n\tif (opts?.params === false) return matches;\n\treturn matches.map((m) => {\n\t\treturn {\n\t\t\tdata: m.data,\n\t\t\tparams: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n\t\t};\n\t});\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n\tconst segment = segments[index];\n\tif (node.wildcard && node.wildcard.methods) {\n\t\tconst match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\tif (node.param) {\n\t\t_findAll(ctx, node.param, method, segments, index + 1, matches);\n\t\tif (index === segments.length && node.param.methods) {\n\t\t\tconst match = node.param.methods[method] || node.param.methods[\"\"];\n\t\t\tif (match) {\n\t\t\t\tconst pMap = match[0].paramsMap;\n\t\t\t\tif (pMap?.[pMap?.length - 1]?.[2]) matches.push(...match);\n\t\t\t}\n\t\t}\n\t}\n\tconst staticChild = node.static?.[segment];\n\tif (staticChild) _findAll(ctx, staticChild, method, segments, index + 1, matches);\n\tif (index === segments.length && node.methods) {\n\t\tconst match = node.methods[method] || node.methods[\"\"];\n\t\tif (match) matches.push(...match);\n\t}\n\treturn matches;\n}\n\nfunction routeToRegExp(route = \"/\") {\n\tconst reSegments = [];\n\tlet idCtr = 0;\n\tfor (const segment of route.split(\"/\")) {\n\t\tif (!segment) continue;\n\t\tif (segment === \"*\") reSegments.push(`(?<_${idCtr++}>[^/]*)`);\n\t\telse if (segment.startsWith(\"**\")) reSegments.push(segment === \"**\" ? \"?(?<_>.*)\" : `?(?<${segment.slice(3)}>.+)`);\n\t\telse if (segment.includes(\":\")) reSegments.push(segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\\./g, \"\\\\.\"));\n\t\telse reSegments.push(segment);\n\t}\n\treturn /* @__PURE__ */ new RegExp(`^/${reSegments.join(\"/\")}/?$`);\n}\n\nexport { NullProtoObj, addRoute, createRouter, findAllRoutes, findRoute, removeRoute, routeToRegExp };","const decoders = /* @__PURE__ */ new Map();\nconst encoder = new TextEncoder();\nconst binary = {\n  decode: (data, encoding = \"utf-8\") => {\n    if (!decoders.has(encoding)) {\n      decoders.set(encoding, new TextDecoder(encoding));\n    }\n    const decoder = decoders.get(encoding);\n    return decoder.decode(data);\n  },\n  encode: encoder.encode\n};\n\nexport { binary };\n","//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (all, symbols) => {\n\tlet target = {};\n\tfor (var name in all) {\n\t\t__defProp(target, name, {\n\t\t\tget: all[name],\n\t\t\tenumerable: true\n\t\t});\n\t}\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\treturn target;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") {\n\t\tfor (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\t\tkey = keys[i];\n\t\t\tif (!__hasOwnProp.call(to, key) && key !== except) {\n\t\t\t\t__defProp(to, key, {\n\t\t\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn to;\n};\nvar __reExport = (target, mod, secondTarget, symbols) => {\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t\tsecondTarget && __defProp(secondTarget, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\t__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\");\n};\n\n//#endregion\nexport { __export, __reExport };","import * as z from \"./v4/classic/external.js\";\nexport * from \"./v4/classic/external.js\";\nexport { z };\nexport default z;\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/error.ts\nvar BetterFetchError = class extends Error {\n  constructor(status, statusText, error) {\n    super(statusText || status.toString(), {\n      cause: error\n    });\n    this.status = status;\n    this.statusText = statusText;\n    this.error = error;\n    Error.captureStackTrace(this, this.constructor);\n  }\n};\n\n// src/plugins.ts\nvar initializePlugins = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f;\n  let opts = options || {};\n  const hooks = {\n    onRequest: [options == null ? void 0 : options.onRequest],\n    onResponse: [options == null ? void 0 : options.onResponse],\n    onSuccess: [options == null ? void 0 : options.onSuccess],\n    onError: [options == null ? void 0 : options.onError],\n    onRetry: [options == null ? void 0 : options.onRetry]\n  };\n  if (!options || !(options == null ? void 0 : options.plugins)) {\n    return {\n      url,\n      options: opts,\n      hooks\n    };\n  }\n  for (const plugin of (options == null ? void 0 : options.plugins) || []) {\n    if (plugin.init) {\n      const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));\n      opts = pluginRes.options || opts;\n      url = pluginRes.url;\n    }\n    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);\n    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);\n    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);\n    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);\n    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);\n  }\n  return {\n    url,\n    options: opts,\n    hooks\n  };\n};\n\n// src/retry.ts\nvar LinearRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay() {\n    return this.options.delay;\n  }\n};\nvar ExponentialRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay(attempt) {\n    const delay = Math.min(\n      this.options.maxDelay,\n      this.options.baseDelay * 2 ** attempt\n    );\n    return delay;\n  }\n};\nfunction createRetryStrategy(options) {\n  if (typeof options === \"number\") {\n    return new LinearRetryStrategy({\n      type: \"linear\",\n      attempts: options,\n      delay: 1e3\n    });\n  }\n  switch (options.type) {\n    case \"linear\":\n      return new LinearRetryStrategy(options);\n    case \"exponential\":\n      return new ExponentialRetryStrategy(options);\n    default:\n      throw new Error(\"Invalid retry strategy\");\n  }\n}\n\n// src/auth.ts\nvar getAuthHeader = async (options) => {\n  const headers = {};\n  const getValue = async (value) => typeof value === \"function\" ? await value() : value;\n  if (options == null ? void 0 : options.auth) {\n    if (options.auth.type === \"Bearer\") {\n      const token = await getValue(options.auth.token);\n      if (!token) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Bearer ${token}`;\n    } else if (options.auth.type === \"Basic\") {\n      const [username, password] = await Promise.all([\n        getValue(options.auth.username),\n        getValue(options.auth.password)\n      ]);\n      if (!username || !password) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n    } else if (options.auth.type === \"Custom\") {\n      const [prefix, value] = await Promise.all([\n        getValue(options.auth.prefix),\n        getValue(options.auth.value)\n      ]);\n      if (!value) {\n        return headers;\n      }\n      headers[\"authorization\"] = `${prefix != null ? prefix : \"\"} ${value}`;\n    }\n  }\n  return headers;\n};\n\n// src/utils.ts\nvar JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(request) {\n  const _contentType = request.headers.get(\"content-type\");\n  const textTypes = /* @__PURE__ */ new Set([\n    \"image/svg\",\n    \"application/xml\",\n    \"application/xhtml\",\n    \"application/html\"\n  ]);\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction isJSONParsable(value) {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction jsonParse(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return text;\n  }\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction getFetch(options) {\n  if (options == null ? void 0 : options.customFetchImpl) {\n    return options.customFetchImpl;\n  }\n  if (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n    return globalThis.fetch;\n  }\n  if (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n    return window.fetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction isPayloadMethod(method) {\n  if (!method) {\n    return false;\n  }\n  const payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  return payloadMethod.includes(method.toUpperCase());\n}\nfunction isRouteMethod(method) {\n  const routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  if (!method) {\n    return false;\n  }\n  return routeMethod.includes(method.toUpperCase());\n}\nasync function getHeaders(opts) {\n  const headers = new Headers(opts == null ? void 0 : opts.headers);\n  const authHeader = await getAuthHeader(opts);\n  for (const [key, value] of Object.entries(authHeader || {})) {\n    headers.set(key, value);\n  }\n  if (!headers.has(\"content-type\")) {\n    const t = detectContentType(opts == null ? void 0 : opts.body);\n    if (t) {\n      headers.set(\"content-type\", t);\n    }\n  }\n  return headers;\n}\nfunction getURL(url, options) {\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  let _url;\n  try {\n    if (url.startsWith(\"http\")) {\n      _url = url;\n    } else {\n      let baseURL = options == null ? void 0 : options.baseURL;\n      if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith(\"/\"))) {\n        baseURL = baseURL + \"/\";\n      }\n      if (url.startsWith(\"/\")) {\n        _url = new URL(url.substring(1), baseURL);\n      } else {\n        _url = new URL(url, options == null ? void 0 : options.baseURL);\n      }\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      if (!(options == null ? void 0 : options.baseURL)) {\n        throw TypeError(\n          `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`\n        );\n      }\n      throw TypeError(\n        `Invalid URL ${url}. Please validate that you are passing the correct input.`\n      );\n    }\n    throw e;\n  }\n  if (options == null ? void 0 : options.params) {\n    if (Array.isArray(options == null ? void 0 : options.params)) {\n      const params = (options == null ? void 0 : options.params) ? Array.isArray(options.params) ? `/${options.params.join(\"/\")}` : `/${Object.values(options.params).join(\"/\")}` : \"\";\n      _url = _url.toString().split(\"/:\")[0];\n      _url = `${_url.toString()}${params}`;\n    } else {\n      for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {\n        _url = _url.toString().replace(`:${key}`, String(value));\n      }\n    }\n  }\n  const __url = new URL(_url);\n  const queryParams = options == null ? void 0 : options.query;\n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      __url.searchParams.append(key, String(value));\n    }\n  }\n  return __url;\n}\nfunction detectContentType(body) {\n  if (isJSONSerializable(body)) {\n    return \"application/json\";\n  }\n  return null;\n}\nfunction getBody(options) {\n  if (!(options == null ? void 0 : options.body)) {\n    return null;\n  }\n  const headers = new Headers(options == null ? void 0 : options.headers);\n  if (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {\n      if (value instanceof Date) {\n        options.body[key] = value.toISOString();\n      }\n    }\n    return JSON.stringify(options.body);\n  }\n  if (headers.has(\"content-type\") && headers.get(\"content-type\") === \"application/x-www-form-urlencoded\") {\n    if (isJSONSerializable(options.body)) {\n      return new URLSearchParams(options.body).toString();\n    }\n    return options.body;\n  }\n  return options.body;\n}\nfunction getMethod(url, options) {\n  var _a;\n  if (options == null ? void 0 : options.method) {\n    return options.method.toUpperCase();\n  }\n  if (url.startsWith(\"@\")) {\n    const pMethod = (_a = url.split(\"@\")[1]) == null ? void 0 : _a.split(\"/\")[0];\n    if (!methods.includes(pMethod)) {\n      return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n    }\n    return pMethod.toUpperCase();\n  }\n  return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n}\nfunction getTimeout(options, controller) {\n  let abortTimeout;\n  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {\n    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);\n  }\n  return {\n    abortTimeout,\n    clearTimeout: () => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  };\n}\nfunction bodyParser(data, responseType) {\n  if (responseType === \"json\") {\n    return JSON.parse(data);\n  }\n  return data;\n}\nvar ValidationError = class _ValidationError extends Error {\n  constructor(issues, message) {\n    super(message || JSON.stringify(issues, null, 2));\n    this.issues = issues;\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nasync function parseStandardSchema(schema, input) {\n  const result = await schema[\"~standard\"].validate(input);\n  if (result.issues) {\n    throw new ValidationError(result.issues);\n  }\n  return result.value;\n}\n\n// src/create-fetch/schema.ts\nvar methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\nvar createSchema = (schema, config) => {\n  return {\n    schema,\n    config\n  };\n};\n\n// src/create-fetch/index.ts\nvar applySchemaPlugin = (config) => ({\n  id: \"apply-schema\",\n  name: \"Apply Schema\",\n  version: \"1.0.0\",\n  async init(url, options) {\n    var _a, _b, _c, _d;\n    const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find(\n      (plugin) => {\n        var _a2;\n        return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || \"\") || url.startsWith(plugin.schema.config.prefix || \"\") : false;\n      }\n    )) == null ? void 0 : _b.schema) || config.schema;\n    if (schema) {\n      let urlKey = url;\n      if ((_c = schema.config) == null ? void 0 : _c.prefix) {\n        if (urlKey.startsWith(schema.config.prefix)) {\n          urlKey = urlKey.replace(schema.config.prefix, \"\");\n          if (schema.config.baseURL) {\n            url = url.replace(schema.config.prefix, schema.config.baseURL);\n          }\n        }\n      }\n      if ((_d = schema.config) == null ? void 0 : _d.baseURL) {\n        if (urlKey.startsWith(schema.config.baseURL)) {\n          urlKey = urlKey.replace(schema.config.baseURL, \"\");\n        }\n      }\n      const keySchema = schema.schema[urlKey];\n      if (keySchema) {\n        let opts = __spreadProps(__spreadValues({}, options), {\n          method: keySchema.method,\n          output: keySchema.output\n        });\n        if (!(options == null ? void 0 : options.disableValidation)) {\n          opts = __spreadProps(__spreadValues({}, opts), {\n            body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,\n            params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,\n            query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query\n          });\n        }\n        return {\n          url,\n          options: opts\n        };\n      }\n    }\n    return {\n      url,\n      options\n    };\n  }\n});\nvar createFetch = (config) => {\n  async function $fetch(url, options) {\n    const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {\n      plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {}), ...(options == null ? void 0 : options.plugins) || []]\n    });\n    if (config == null ? void 0 : config.catchAllError) {\n      try {\n        return await betterFetch(url, opts);\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            status: 500,\n            statusText: \"Fetch Error\",\n            message: \"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n            error\n          }\n        };\n      }\n    }\n    return await betterFetch(url, opts);\n  }\n  return $fetch;\n};\n\n// src/url.ts\nfunction getURL2(url, option) {\n  const { baseURL, params, query } = option || {\n    query: {},\n    params: {},\n    baseURL: \"\"\n  };\n  let basePath = url.startsWith(\"http\") ? url.split(\"/\").slice(0, 3).join(\"/\") : baseURL || \"\";\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  if (!basePath.endsWith(\"/\")) basePath += \"/\";\n  let [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n  const queryParams = new URLSearchParams(urlQuery);\n  for (const [key, value] of Object.entries(query || {})) {\n    if (value == null) continue;\n    let serializedValue;\n    if (typeof value === \"string\") {\n      serializedValue = value;\n    } else if (Array.isArray(value)) {\n      for (const val of value) {\n        queryParams.append(key, val);\n      }\n      continue;\n    } else {\n      serializedValue = JSON.stringify(value);\n    }\n    queryParams.set(key, serializedValue);\n  }\n  if (params) {\n    if (Array.isArray(params)) {\n      const paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n      for (const [index, key] of paramPaths.entries()) {\n        const value = params[index];\n        path = path.replace(key, value);\n      }\n    } else {\n      for (const [key, value] of Object.entries(params)) {\n        path = path.replace(`:${key}`, String(value));\n      }\n    }\n  }\n  path = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (path.startsWith(\"/\")) path = path.slice(1);\n  let queryParamString = queryParams.toString();\n  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n  if (!basePath.startsWith(\"http\")) {\n    return `${basePath}${path}${queryParamString}`;\n  }\n  const _url = new URL(`${path}${queryParamString}`, basePath);\n  return _url;\n}\n\n// src/fetch.ts\nvar betterFetch = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const {\n    hooks,\n    url: __url,\n    options: opts\n  } = await initializePlugins(url, options);\n  const fetch = getFetch(opts);\n  const controller = new AbortController();\n  const signal = (_a = opts.signal) != null ? _a : controller.signal;\n  const _url = getURL2(__url, opts);\n  const body = getBody(opts);\n  const headers = await getHeaders(opts);\n  const method = getMethod(__url, opts);\n  let context = __spreadProps(__spreadValues({}, opts), {\n    url: _url,\n    headers,\n    body,\n    method,\n    signal\n  });\n  for (const onRequest of hooks.onRequest) {\n    if (onRequest) {\n      const res = await onRequest(context);\n      if (typeof res === \"object\" && res !== null) {\n        context = res;\n      }\n    }\n  }\n  if (\"pipeTo\" in context && typeof context.pipeTo === \"function\" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === \"function\") {\n    if (!(\"duplex\" in context)) {\n      context.duplex = \"half\";\n    }\n  }\n  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);\n  let response = await fetch(context.url, context);\n  clearTimeout2();\n  const responseContext = {\n    response,\n    request: context\n  };\n  for (const onResponse of hooks.onResponse) {\n    if (onResponse) {\n      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {\n        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response\n      }));\n      if (r instanceof Response) {\n        response = r;\n      } else if (typeof r === \"object\" && r !== null) {\n        response = r.response;\n      }\n    }\n  }\n  if (response.ok) {\n    const hasBody = context.method !== \"HEAD\";\n    if (!hasBody) {\n      return {\n        data: \"\",\n        error: null\n      };\n    }\n    const responseType = detectResponseType(response);\n    const successContext = {\n      data: null,\n      response,\n      request: context\n    };\n    if (responseType === \"json\" || responseType === \"text\") {\n      const text = await response.text();\n      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;\n      successContext.data = await parser2(text);\n    } else {\n      successContext.data = await response[responseType]();\n    }\n    if (context == null ? void 0 : context.output) {\n      if (context.output && !context.disableValidation) {\n        successContext.data = await parseStandardSchema(\n          context.output,\n          successContext.data\n        );\n      }\n    }\n    for (const onSuccess of hooks.onSuccess) {\n      if (onSuccess) {\n        await onSuccess(__spreadProps(__spreadValues({}, successContext), {\n          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response\n        }));\n      }\n    }\n    if (options == null ? void 0 : options.throw) {\n      return successContext.data;\n    }\n    return {\n      data: successContext.data,\n      error: null\n    };\n  }\n  const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;\n  const responseText = await response.text();\n  const isJSONResponse = isJSONParsable(responseText);\n  const errorObject = isJSONResponse ? await parser(responseText) : null;\n  const errorContext = {\n    response,\n    responseText,\n    request: context,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n  for (const onError of hooks.onError) {\n    if (onError) {\n      await onError(__spreadProps(__spreadValues({}, errorContext), {\n        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.retry) {\n    const retryStrategy = createRetryStrategy(options.retry);\n    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;\n    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n      for (const onRetry of hooks.onRetry) {\n        if (onRetry) {\n          await onRetry(responseContext);\n        }\n      }\n      const delay = retryStrategy.getDelay(_retryAttempt);\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {\n        retryAttempt: _retryAttempt + 1\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.throw) {\n    throw new BetterFetchError(\n      response.status,\n      response.statusText,\n      isJSONResponse ? errorObject : responseText\n    );\n  }\n  return {\n    data: null,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n};\nexport {\n  BetterFetchError,\n  ValidationError,\n  applySchemaPlugin,\n  betterFetch,\n  bodyParser,\n  createFetch,\n  createRetryStrategy,\n  createSchema,\n  detectContentType,\n  detectResponseType,\n  getBody,\n  getFetch,\n  getHeaders,\n  getMethod,\n  getTimeout,\n  getURL,\n  initializePlugins,\n  isFunction,\n  isJSONParsable,\n  isJSONSerializable,\n  isPayloadMethod,\n  isRouteMethod,\n  jsonParse,\n  methods,\n  parseStandardSchema\n};\n//# sourceMappingURL=index.js.map","function isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\nexport { globalRegistry, registry, config, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, TimePrecision, util, NEVER, } from \"../core/index.js\";\nexport { toJSONSchema } from \"../core/json-schema-processors.js\";\nexport { fromJSONSchema } from \"./from-json-schema.js\";\nexport * as locales from \"../locales/index.js\";\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\nexport * as coerce from \"./coerce.js\";\n","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function encode(string) {\n    const bytes = new Uint8Array(string.length);\n    for (let i = 0; i < string.length; i++) {\n        const code = string.charCodeAt(i);\n        if (code > 127) {\n            throw new TypeError('non-ASCII string encountered in encode()');\n        }\n        bytes[i] = code;\n    }\n    return bytes;\n}\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport const isCryptoKey = (key) => {\n    if (key?.[Symbol.toStringTag] === 'CryptoKey')\n        return true;\n    try {\n        return key instanceof CryptoKey;\n    }\n    catch {\n        return false;\n    }\n};\nexport const isKeyObject = (key) => key?.[Symbol.toStringTag] === 'KeyObject';\nexport const isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);\n","export async function digest(algorithm, data) {\n    const subtleDigest = `SHA-${algorithm.slice(-3)}`;\n    return new Uint8Array(await crypto.subtle.digest(subtleDigest, data));\n}\n","export function checkKeyLength(alg, key) {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n}\n","export const unprotected = Symbol();\n","export function isDisjoint(...headers) {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n}\n","export function validateAlgorithms(option, algorithms) {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n}\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","import { checkEncCryptoKey } from './crypto_key.js';\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    checkEncCryptoKey(key, alg, usage);\n    return key;\n}\nexport async function wrap(alg, key, cek) {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.importKey('raw', cek, { hash: 'SHA-256', name: 'HMAC' }, true, ['sign']);\n    return new Uint8Array(await crypto.subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n}\nexport async function unwrap(alg, key, encryptedKey) {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await crypto.subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', { hash: 'SHA-256', name: 'HMAC' }, true, ['sign']);\n    return new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKeyCek));\n}\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'AKP': {\n            switch (jwk.alg) {\n                case 'ML-DSA-44':\n                case 'ML-DSA-65':\n                case 'ML-DSA-87':\n                    algorithm = { name: jwk.alg };\n                    keyUsages = jwk.priv ? ['sign'] : ['verify'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport async function jwkToKey(jwk) {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    if (keyData.kty !== 'AKP') {\n        delete keyData.alg;\n    }\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);\n}\n","export const DEFAULT_SECRET = \"better-auth-secret-12345678901234567890\";\n","import { FlattenedEncrypt } from '../flattened/encrypt.js';\nexport class CompactEncrypt {\n    #flattened;\n    constructor(plaintext) {\n        this.#flattened = new FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this.#flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this.#flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this.#flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this.#flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n","import { isObject } from './is_object.js';\nexport const isJWK = (key) => isObject(key) && typeof key.kty === 'string';\nexport const isPrivateJWK = (key) => key.kty !== 'oct' &&\n    ((key.kty === 'AKP' && typeof key.priv === 'string') || typeof key.d === 'string');\nexport const isPublicJWK = (key) => key.kty !== 'oct' && key.d === undefined && key.priv === undefined;\nexport const isSecretJWK = (key) => key.kty === 'oct' && typeof key.k === 'string';\n","import { JOSENotSupported } from '../util/errors.js';\nexport function cekLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport const generateCek = (alg) => crypto.getRandomValues(new Uint8Array(cekLength(alg) >> 3));\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport function bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\nexport const generateIv = (alg) => crypto.getRandomValues(new Uint8Array(bitLength(alg) >> 3));\n","import { JOSENotSupported } from '../util/errors.js';\nexport function subtleAlgorithm(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return { name: alg };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { JWEInvalid } from '../util/errors.js';\nexport function checkCekLength(cek, expected) {\n    const actual = cek.byteLength << 3;\n    if (actual !== expected) {\n        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n    }\n}\n","// Time constants (in milliseconds)\nconst SEC = 1000;\nconst MIN = SEC * 60;\nconst HOUR = MIN * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * 30;\nconst YEAR = DAY * 365.25;\n\n// Unit type definitions\ntype Years = \"years\" | \"year\" | \"yrs\" | \"yr\" | \"y\";\ntype Months = \"months\" | \"month\" | \"mo\";\ntype Weeks = \"weeks\" | \"week\" | \"w\";\ntype Days = \"days\" | \"day\" | \"d\";\ntype Hours = \"hours\" | \"hour\" | \"hrs\" | \"hr\" | \"h\";\ntype Minutes = \"minutes\" | \"minute\" | \"mins\" | \"min\" | \"m\";\ntype Seconds = \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\";\ntype Unit = Years | Months | Weeks | Days | Hours | Minutes | Seconds;\ntype UnitAnyCase = Capitalize<Unit> | Uppercase<Unit> | Unit;\ntype Suffix = \" ago\" | \" from now\";\ntype Prefix = \"+\" | \"-\" | \"+ \" | \"- \";\n\n// Base time string formats\ntype BaseTimeString = `${number}${UnitAnyCase}` | `${number} ${UnitAnyCase}`;\n\n/**\n * A typed string representing a time duration.\n * Supports formats like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\", \"-5m\", etc.\n */\nexport type TimeString =\n\t| BaseTimeString\n\t| `${BaseTimeString}${Suffix}`\n\t| `${Prefix}${BaseTimeString}`;\n\nconst REGEX =\n\t/^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)(?: (ago|from now))?$/i;\n\nfunction parse(value: string): number {\n\tconst match = REGEX.exec(value);\n\n\tif (!match || (match[4] && match[1])) {\n\t\tthrow new TypeError(\n\t\t\t`Invalid time string format: \"${value}\". Use formats like \"7d\", \"30m\", \"1 hour\", etc.`,\n\t\t);\n\t}\n\n\tconst n = parseFloat(match[2]!);\n\tconst unit = match[3]!.toLowerCase();\n\n\tlet result: number;\n\tswitch (unit) {\n\t\tcase \"years\":\n\t\tcase \"year\":\n\t\tcase \"yrs\":\n\t\tcase \"yr\":\n\t\tcase \"y\":\n\t\t\tresult = n * YEAR;\n\t\t\tbreak;\n\t\tcase \"months\":\n\t\tcase \"month\":\n\t\tcase \"mo\":\n\t\t\tresult = n * MONTH;\n\t\t\tbreak;\n\t\tcase \"weeks\":\n\t\tcase \"week\":\n\t\tcase \"w\":\n\t\t\tresult = n * WEEK;\n\t\t\tbreak;\n\t\tcase \"days\":\n\t\tcase \"day\":\n\t\tcase \"d\":\n\t\t\tresult = n * DAY;\n\t\t\tbreak;\n\t\tcase \"hours\":\n\t\tcase \"hour\":\n\t\tcase \"hrs\":\n\t\tcase \"hr\":\n\t\tcase \"h\":\n\t\t\tresult = n * HOUR;\n\t\t\tbreak;\n\t\tcase \"minutes\":\n\t\tcase \"minute\":\n\t\tcase \"mins\":\n\t\tcase \"min\":\n\t\tcase \"m\":\n\t\t\tresult = n * MIN;\n\t\t\tbreak;\n\t\tcase \"seconds\":\n\t\tcase \"second\":\n\t\tcase \"secs\":\n\t\tcase \"sec\":\n\t\tcase \"s\":\n\t\t\tresult = n * SEC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new TypeError(`Unknown time unit: \"${unit}\"`);\n\t}\n\n\tif (match[1] === \"-\" || match[4] === \"ago\") {\n\t\treturn -result;\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse a time string and return the value in milliseconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in milliseconds\n * @throws TypeError if the string format is invalid\n *\n * @example\n * ms(\"1d\")          // 86400000\n * ms(\"2 hours\")     // 7200000\n * ms(\"30s\")         // 30000\n * ms(\"2 hours ago\") // -7200000\n */\nexport function ms(value: TimeString): number {\n\treturn parse(value);\n}\n\n/**\n * Parse a time string and return the value in seconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in seconds (rounded)\n * @throws TypeError if the string format is invalid\n *\n * @example\n * sec(\"1d\")          // 86400\n * sec(\"2 hours\")     // 7200\n * sec(\"-30s\")        // -30\n * sec(\"2 hours ago\") // -7200\n */\nexport function sec(value: TimeString): number {\n\treturn Math.round(parse(value) / 1000);\n}\n","import type { AsyncLocalStorage } from \"@better-auth/core/async_hooks\";\n\ninterface BetterAuthGlobal {\n\t/**\n\t * The version of BetterAuth.\n\t */\n\tversion: string;\n\t/**\n\t * Used to track the number of BetterAuth instances in the same process.\n\t *\n\t * Debugging purposes only.\n\t */\n\tepoch: number;\n\t/**\n\t * Stores the AsyncLocalStorage instances for each context.\n\t */\n\tcontext: Record<string, AsyncLocalStorage<unknown>>;\n}\n\nconst symbol = Symbol.for(\"better-auth:global\");\nlet bind: BetterAuthGlobal | null = null;\n\nconst __context: Record<string, AsyncLocalStorage<unknown>> = {};\nconst __betterAuthVersion: string = import.meta.env\n\t.BETTER_AUTH_VERSION as string;\n\n/**\n * We store context instance in the globalThis.\n *\n * The reason we do this is that some bundlers, web framework, or package managers might\n * create multiple copies of BetterAuth in the same process intentionally or unintentionally.\n *\n * For example, yarn v1, Next.js, SSR, Vite...\n *\n * @internal\n */\nexport function __getBetterAuthGlobal(): BetterAuthGlobal {\n\tif (!(globalThis as any)[symbol]) {\n\t\t(globalThis as any)[symbol] = {\n\t\t\tversion: __betterAuthVersion,\n\t\t\tepoch: 1,\n\t\t\tcontext: __context,\n\t\t};\n\t\tbind = (globalThis as any)[symbol] as BetterAuthGlobal;\n\t}\n\tbind = (globalThis as any)[symbol] as BetterAuthGlobal;\n\tif (bind.version !== __betterAuthVersion) {\n\t\tbind.version = __betterAuthVersion;\n\t\t// Different versions of BetterAuth are loaded in the same process.\n\t\tbind.epoch++;\n\t}\n\treturn (globalThis as any)[symbol] as BetterAuthGlobal;\n}\n\nexport function getBetterAuthVersion(): string {\n\treturn __getBetterAuthGlobal().version;\n}\n","export const getDate = (span: number, unit: \"sec\" | \"ms\" = \"ms\") => {\n\treturn new Date(Date.now() + (unit === \"sec\" ? span * 1000 : span));\n};\n","import type { AsyncLocalStorage } from \"node:async_hooks\";\n\nexport type { AsyncLocalStorage };\n\nconst AsyncLocalStoragePromise: Promise<typeof AsyncLocalStorage | null> =\n\timport(\n\t\t/* @vite-ignore */\n\t\t/* webpackIgnore: true */\n\t\t\"node:async_hooks\"\n\t)\n\t\t.then((mod) => mod.AsyncLocalStorage)\n\t\t.catch((err) => {\n\t\t\tif (\"AsyncLocalStorage\" in globalThis) {\n\t\t\t\treturn (globalThis as any).AsyncLocalStorage;\n\t\t\t}\n\t\t\tif (typeof window !== \"undefined\") {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconsole.warn(\n\t\t\t\t\"[better-auth] Warning: AsyncLocalStorage is not available in this environment. Some features may not work as expected.\",\n\t\t\t);\n\t\t\tconsole.warn(\n\t\t\t\t\"[better-auth] Please read more about this warning at https://better-auth.com/docs/installation#mount-handler\",\n\t\t\t);\n\t\t\tconsole.warn(\n\t\t\t\t\"[better-auth] If you are using Cloudflare Workers, please see: https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag\",\n\t\t\t);\n\t\t\tthrow err;\n\t\t});\n\nexport async function getAsyncLocalStorage(): Promise<\n\ttypeof AsyncLocalStorage\n> {\n\tconst mod = await AsyncLocalStoragePromise;\n\tif (mod === null) {\n\t\tthrow new Error(\"getAsyncLocalStorage is only available in server code\");\n\t} else {\n\t\treturn mod;\n\t}\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tDBFieldAttribute,\n\tDBFieldAttributeConfig,\n\tDBFieldType,\n} from \"@better-auth/core/db\";\n\nexport const createFieldAttribute = <\n\tT extends DBFieldType,\n\tC extends DBFieldAttributeConfig,\n>(\n\ttype: T,\n\tconfig?: C | undefined,\n) => {\n\treturn {\n\t\ttype,\n\t\t...config,\n\t} satisfies DBFieldAttribute<T>;\n};\n\nexport type InferValueType<T extends DBFieldType> = T extends \"string\"\n\t? string\n\t: T extends \"number\"\n\t\t? number\n\t\t: T extends \"boolean\"\n\t\t\t? boolean\n\t\t\t: T extends \"date\"\n\t\t\t\t? Date\n\t\t\t\t: T extends \"json\"\n\t\t\t\t\t? Record<string, any>\n\t\t\t\t\t: T extends `${infer U}[]`\n\t\t\t\t\t\t? U extends \"string\"\n\t\t\t\t\t\t\t? string[]\n\t\t\t\t\t\t\t: number[]\n\t\t\t\t\t\t: T extends Array<any>\n\t\t\t\t\t\t\t? T[number]\n\t\t\t\t\t\t\t: never;\n\nexport type InferFieldsOutput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: key]: InferFieldOutput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key\n\t\t\t\t\t\t: never]?: InferFieldOutput<Field[key]> | null;\n\t\t\t}\n\t\t: {};\n\nexport type InferFieldsInput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false ? never : key]?:\n\t\t\t\t\t| InferFieldInput<Field[key]>\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null;\n\t\t\t}\n\t\t: {};\n\n/**\n * For client will add \"?\" on optional fields\n */\nexport type InferFieldsInputClient<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? key\n\t\t\t\t\t\t: Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never]?: InferFieldInput<Field[key]> | undefined | null;\n\t\t\t}\n\t\t: {};\n\ntype InferFieldOutput<T extends DBFieldAttribute> = T[\"returned\"] extends false\n\t? never\n\t: T[\"required\"] extends false\n\t\t? InferValueType<T[\"type\"]> | undefined | null\n\t\t: InferValueType<T[\"type\"]>;\n\n/**\n * Converts a Record<string, DBFieldAttribute> to an object type\n * with keys and value types inferred from DBFieldAttribute[\"type\"].\n */\nexport type FieldAttributeToObject<\n\tFields extends Record<string, DBFieldAttribute>,\n> = AddOptionalFields<\n\t{\n\t\t[K in keyof Fields]: InferValueType<Fields[K][\"type\"]>;\n\t},\n\tFields\n>;\n\ntype AddOptionalFields<\n\tT extends Record<string, any>,\n\tFields extends Record<keyof T, DBFieldAttribute>,\n> = {\n\t// Required fields: required === true\n\t[K in keyof T as Fields[K] extends { required: true } ? K : never]: T[K];\n} & {\n\t// Optional fields: required !== true\n\t[K in keyof T as Fields[K] extends { required: true } ? never : K]?: T[K];\n};\n\n/**\n * Infer the additional fields from the plugin options.\n * For example, you can infer the additional fields of the org plugin's organization schema like this:\n * ```ts\n * type AdditionalFields = InferAdditionalFieldsFromPluginOptions<\"organization\", OrganizationOptions>\n * ```\n *\n * @param isClientSide - When `true` (default), filters out `input: false` fields (clients can't send these).\n *   When `false`, includes all fields (for internal/server-side use).\n */\nexport type InferAdditionalFieldsFromPluginOptions<\n\tSchemaName extends string,\n\tOptions extends {\n\t\tschema?:\n\t\t\t| {\n\t\t\t\t\t[key in SchemaName]?: {\n\t\t\t\t\t\tadditionalFields?: Record<string, DBFieldAttribute>;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t},\n\tisClientSide extends boolean = true,\n> = Options[\"schema\"] extends {\n\t[key in SchemaName]?: {\n\t\tadditionalFields: infer Field extends Record<string, DBFieldAttribute>;\n\t};\n}\n\t? isClientSide extends true\n\t\t? FieldAttributeToObject<RemoveFieldsWithInputFalse<Field>>\n\t\t: FieldAttributeToObject<Field>\n\t: {};\n\ntype RemoveFieldsWithInputFalse<T extends Record<string, DBFieldAttribute>> = {\n\t[K in keyof T as T[K][\"input\"] extends false ? never : K]: T[K];\n};\n\nexport type RemoveFieldsWithReturnedFalse<\n\tT extends Record<string, DBFieldAttribute>,\n> = {\n\t[K in keyof T as T[K][\"returned\"] extends false ? never : K]: T[K];\n};\n\ntype InferFieldInput<T extends DBFieldAttribute> = InferValueType<T[\"type\"]>;\n\nexport type PluginFieldAttribute = Omit<\n\tDBFieldAttribute,\n\t\"transform\" | \"defaultValue\" | \"hashValue\"\n>;\n\nexport type InferFieldsFromPlugins<\n\tOptions extends BetterAuthOptions,\n\tKey extends string,\n\tFormat extends \"output\" | \"input\",\n> = Options[\"plugins\"] extends []\n\t? {}\n\t: Options[\"plugins\"] extends Array<infer T>\n\t\t? T extends {\n\t\t\t\tschema: {\n\t\t\t\t\t[key in Key]: {\n\t\t\t\t\t\tfields: infer Field;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t\t? Format extends \"output\"\n\t\t\t\t? InferFieldsOutput<Field>\n\t\t\t\t: InferFieldsInput<Field>\n\t\t\t: {}\n\t\t: {};\n\nexport type InferFieldsFromOptions<\n\tOptions extends BetterAuthOptions,\n\tKey extends \"session\" | \"user\",\n\tFormat extends \"output\" | \"input\",\n> = Options[Key] extends {\n\tadditionalFields: infer Field;\n}\n\t? Format extends \"output\"\n\t\t? InferFieldsOutput<Field>\n\t\t: InferFieldsInput<Field>\n\t: {};\n","import { toSPKI as exportPublic, toPKCS8 as exportPrivate } from '../lib/asn1.js';\nimport { keyToJWK } from '../lib/key_to_jwk.js';\nexport async function exportSPKI(key) {\n    return exportPublic(key);\n}\nexport async function exportPKCS8(key) {\n    return exportPrivate(key);\n}\nexport async function exportJWK(key) {\n    return keyToJWK(key);\n}\n","import { JWEInvalid } from '../util/errors.js';\nimport { bitLength } from './iv.js';\nexport function checkIvLength(enc, iv) {\n    if (iv.length << 3 !== bitLength(enc)) {\n        throw new JWEInvalid('Invalid Initialization Vector length');\n    }\n}\n","import { CompactEncrypt } from '../jwe/compact/encrypt.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class EncryptJWT {\n    #cek;\n    #iv;\n    #keyManagementParameters;\n    #protectedHeader;\n    #replicateIssuerAsHeader;\n    #replicateSubjectAsHeader;\n    #replicateAudienceAsHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this.#keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this.#keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this.#cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this.#cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this.#iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this.#iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this.#replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this.#replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this.#replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new CompactEncrypt(this.#jwt.data());\n        if (this.#protectedHeader &&\n            (this.#replicateIssuerAsHeader ||\n                this.#replicateSubjectAsHeader ||\n                this.#replicateAudienceAsHeader)) {\n            this.#protectedHeader = {\n                ...this.#protectedHeader,\n                iss: this.#replicateIssuerAsHeader ? this.#jwt.iss : undefined,\n                sub: this.#replicateSubjectAsHeader ? this.#jwt.sub : undefined,\n                aud: this.#replicateAudienceAsHeader ? this.#jwt.aud : undefined,\n            };\n        }\n        enc.setProtectedHeader(this.#protectedHeader);\n        if (this.#iv) {\n            enc.setInitializationVector(this.#iv);\n        }\n        if (this.#cek) {\n            enc.setContentEncryptionKey(this.#cek);\n        }\n        if (this.#keyManagementParameters) {\n            enc.setKeyManagementParameters(this.#keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport function string(params) {\n    return core._coercedString(schemas.ZodString, params);\n}\nexport function number(params) {\n    return core._coercedNumber(schemas.ZodNumber, params);\n}\nexport function boolean(params) {\n    return core._coercedBoolean(schemas.ZodBoolean, params);\n}\nexport function bigint(params) {\n    return core._coercedBigint(schemas.ZodBigInt, params);\n}\nexport function date(params) {\n    return core._coercedDate(schemas.ZodDate, params);\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport { invalidKeyInput } from './invalid_key_input.js';\nexport async function getSigKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n}\n","import type { StandardSchemaV1 } from \"./standard-schema\";\n// https://github.com/nodejs/node/blob/360f7cc7867b43344aac00564286b895e15f21d7/lib/internal/errors.js#L246C1-L261C2\nfunction isErrorStackTraceLimitWritable() {\n\tconst desc = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n\tif (desc === undefined) {\n\t\treturn Object.isExtensible(Error);\n\t}\n\n\treturn Object.prototype.hasOwnProperty.call(desc, \"writable\")\n\t\t? desc.writable\n\t\t: desc.set !== undefined;\n}\n\n/**\n * Hide internal stack frames from the error stack trace.\n */\nexport function hideInternalStackFrames(stack: string): string {\n\tconst lines = stack.split(\"\\n    at \");\n\tif (lines.length <= 1) {\n\t\treturn stack;\n\t}\n\tlines.splice(1, 1);\n\treturn lines.join(\"\\n    at \");\n}\n\n// https://github.com/nodejs/node/blob/360f7cc7867b43344aac00564286b895e15f21d7/lib/internal/errors.js#L411-L432\n/**\n * Creates a custom error class that hides stack frames.\n */\nexport function makeErrorForHideStackFrame<B extends new (...args: any[]) => Error>(\n\tBase: B,\n\tclazz: any,\n): {\n\tnew (...args: ConstructorParameters<B>): InstanceType<B> & { errorStack: string | undefined };\n} {\n\tclass HideStackFramesError extends Base {\n\t\t#hiddenStack: string | undefined;\n\n\t\tconstructor(...args: any[]) {\n\t\t\tif (isErrorStackTraceLimitWritable()) {\n\t\t\t\tconst limit = Error.stackTraceLimit;\n\t\t\t\tError.stackTraceLimit = 0;\n\t\t\t\tsuper(...args);\n\t\t\t\tError.stackTraceLimit = limit;\n\t\t\t} else {\n\t\t\t\tsuper(...args);\n\t\t\t}\n\t\t\tconst stack = new Error().stack;\n\t\t\tif (stack) {\n\t\t\t\tthis.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));\n\t\t\t}\n\t\t}\n\n\t\t// use `getter` here to avoid the stack trace being captured by loggers\n\t\tget errorStack() {\n\t\t\treturn this.#hiddenStack;\n\t\t}\n\t}\n\n\t// This is a workaround for wpt tests that expect that the error\n\t// constructor has a `name` property of the base class.\n\tObject.defineProperty(HideStackFramesError.prototype, \"constructor\", {\n\t\tget() {\n\t\t\treturn clazz;\n\t\t},\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t});\n\n\treturn HideStackFramesError as any;\n}\n\nexport const statusCodes = {\n\tOK: 200,\n\tCREATED: 201,\n\tACCEPTED: 202,\n\tNO_CONTENT: 204,\n\tMULTIPLE_CHOICES: 300,\n\tMOVED_PERMANENTLY: 301,\n\tFOUND: 302,\n\tSEE_OTHER: 303,\n\tNOT_MODIFIED: 304,\n\tTEMPORARY_REDIRECT: 307,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_ALLOWED: 405,\n\tNOT_ACCEPTABLE: 406,\n\tPROXY_AUTHENTICATION_REQUIRED: 407,\n\tREQUEST_TIMEOUT: 408,\n\tCONFLICT: 409,\n\tGONE: 410,\n\tLENGTH_REQUIRED: 411,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tURI_TOO_LONG: 414,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tRANGE_NOT_SATISFIABLE: 416,\n\tEXPECTATION_FAILED: 417,\n\t\"I'M_A_TEAPOT\": 418,\n\tMISDIRECTED_REQUEST: 421,\n\tUNPROCESSABLE_ENTITY: 422,\n\tLOCKED: 423,\n\tFAILED_DEPENDENCY: 424,\n\tTOO_EARLY: 425,\n\tUPGRADE_REQUIRED: 426,\n\tPRECONDITION_REQUIRED: 428,\n\tTOO_MANY_REQUESTS: 429,\n\tREQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n\tUNAVAILABLE_FOR_LEGAL_REASONS: 451,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504,\n\tHTTP_VERSION_NOT_SUPPORTED: 505,\n\tVARIANT_ALSO_NEGOTIATES: 506,\n\tINSUFFICIENT_STORAGE: 507,\n\tLOOP_DETECTED: 508,\n\tNOT_EXTENDED: 510,\n\tNETWORK_AUTHENTICATION_REQUIRED: 511,\n};\n\nexport type Status =\n\t| 100\n\t| 101\n\t| 102\n\t| 103\n\t| 200\n\t| 201\n\t| 202\n\t| 203\n\t| 204\n\t| 205\n\t| 206\n\t| 207\n\t| 208\n\t| 226\n\t| 300\n\t| 301\n\t| 302\n\t| 303\n\t| 304\n\t| 305\n\t| 306\n\t| 307\n\t| 308\n\t| 400\n\t| 401\n\t| 402\n\t| 403\n\t| 404\n\t| 405\n\t| 406\n\t| 407\n\t| 408\n\t| 409\n\t| 410\n\t| 411\n\t| 412\n\t| 413\n\t| 414\n\t| 415\n\t| 416\n\t| 417\n\t| 418\n\t| 421\n\t| 422\n\t| 423\n\t| 424\n\t| 425\n\t| 426\n\t| 428\n\t| 429\n\t| 431\n\t| 451\n\t| 500\n\t| 501\n\t| 502\n\t| 503\n\t| 504\n\t| 505\n\t| 506\n\t| 507\n\t| 508\n\t| 510\n\t| 511;\n\nclass InternalAPIError extends Error {\n\tconstructor(\n\t\tpublic status: keyof typeof statusCodes | Status = \"INTERNAL_SERVER_ERROR\",\n\t\tpublic body:\n\t\t\t| ({\n\t\t\t\t\tmessage?: string;\n\t\t\t\t\tcode?: string;\n\t\t\t\t\tcause?: unknown;\n\t\t\t  } & Record<string, any>)\n\t\t\t| undefined = undefined,\n\t\tpublic headers: HeadersInit = {},\n\t\tpublic statusCode = typeof status === \"number\" ? status : statusCodes[status],\n\t) {\n\t\tsuper(\n\t\t\tbody?.message,\n\t\t\tbody?.cause\n\t\t\t\t? {\n\t\t\t\t\t\tcause: body.cause,\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t);\n\t\tthis.name = \"APIError\";\n\t\tthis.status = status;\n\t\tthis.headers = headers;\n\t\tthis.statusCode = statusCode;\n\t\tthis.body = body\n\t\t\t? {\n\t\t\t\t\tcode: body?.message\n\t\t\t\t\t\t?.toUpperCase()\n\t\t\t\t\t\t.replace(/ /g, \"_\")\n\t\t\t\t\t\t.replace(/[^A-Z0-9_]/g, \"\"),\n\t\t\t\t\t...body,\n\t\t\t\t}\n\t\t\t: undefined;\n\t}\n}\n\nexport class ValidationError extends InternalAPIError {\n\tconstructor(\n\t\tpublic message: string,\n\t\tpublic issues: readonly StandardSchemaV1.Issue[],\n\t) {\n\t\tsuper(400, {\n\t\t\tmessage: message,\n\t\t\tcode: \"VALIDATION_ERROR\",\n\t\t});\n\n\t\tthis.issues = issues;\n\t}\n}\n\nexport class BetterCallError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = \"BetterCallError\";\n\t}\n}\n\nexport type APIError = InstanceType<typeof InternalAPIError>;\nexport const APIError = makeErrorForHideStackFrame(InternalAPIError, Error);\n","import type { DBFieldAttribute } from \"@better-auth/core/db\";\n\nexport function convertToDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T,\n) {\n\tconst result: Record<string, any> = values.id\n\t\t? {\n\t\t\t\tid: values.id,\n\t\t\t}\n\t\t: {};\n\tfor (const key in fields) {\n\t\tconst field = fields[key]!;\n\t\tconst value = values[key];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult[field.fieldName || key] = value;\n\t}\n\treturn result as T;\n}\n\nexport function convertFromDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T | null,\n) {\n\tif (!values) {\n\t\treturn null;\n\t}\n\tconst result: Record<string, any> = {\n\t\tid: values.id,\n\t};\n\tfor (const [key, value] of Object.entries(fields)) {\n\t\tresult[key] = values[value.fieldName || key];\n\t}\n\treturn result as T;\n}\n","export function isPromise(obj?: unknown): obj is Promise<unknown> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === \"object\" || typeof obj === \"function\") &&\n\t\ttypeof (obj as Promise<unknown>).then === \"function\"\n\t);\n}\n","import { JOSEError, JWKSNoMatchingKey, JWKSTimeout } from '../util/errors.js';\nimport { createLocalJWKSet } from './local.js';\nimport { isObject } from '../lib/is_object.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v6.1.3';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nexport const customFetch = Symbol();\nasync function fetchJwks(url, headers, signal, fetchImpl = fetch) {\n    const response = await fetchImpl(url, {\n        method: 'GET',\n        signal,\n        redirect: 'manual',\n        headers,\n    }).catch((err) => {\n        if (err.name === 'TimeoutError') {\n            throw new JWKSTimeout();\n        }\n        throw err;\n    });\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n}\nexport const jwksCache = Symbol();\nfunction isFreshJwksCache(input, cacheMaxAge) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || Date.now() - input.uat >= cacheMaxAge) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isObject)) {\n        return false;\n    }\n    return true;\n}\nclass RemoteJWKSet {\n    #url;\n    #timeoutDuration;\n    #cooldownDuration;\n    #cacheMaxAge;\n    #jwksTimestamp;\n    #pendingFetch;\n    #headers;\n    #customFetch;\n    #local;\n    #cache;\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this.#url = new URL(url.href);\n        this.#timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this.#cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this.#cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n        this.#headers = new Headers(options?.headers);\n        if (USER_AGENT && !this.#headers.has('User-Agent')) {\n            this.#headers.set('User-Agent', USER_AGENT);\n        }\n        if (!this.#headers.has('accept')) {\n            this.#headers.set('accept', 'application/json');\n            this.#headers.append('accept', 'application/jwk-set+json');\n        }\n        this.#customFetch = options?.[customFetch];\n        if (options?.[jwksCache] !== undefined) {\n            this.#cache = options?.[jwksCache];\n            if (isFreshJwksCache(options?.[jwksCache], this.#cacheMaxAge)) {\n                this.#jwksTimestamp = this.#cache.uat;\n                this.#local = createLocalJWKSet(this.#cache.jwks);\n            }\n        }\n    }\n    pendingFetch() {\n        return !!this.#pendingFetch;\n    }\n    coolingDown() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this.#jwksTimestamp === 'number'\n            ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge\n            : false;\n    }\n    jwks() {\n        return this.#local?.jwks();\n    }\n    async getKey(protectedHeader, token) {\n        if (!this.#local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this.#local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this.#local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this.#pendingFetch && isCloudflareWorkers()) {\n            this.#pendingFetch = undefined;\n        }\n        this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch)\n            .then((json) => {\n            this.#local = createLocalJWKSet(json);\n            if (this.#cache) {\n                this.#cache.uat = Date.now();\n                this.#cache.jwks = json;\n            }\n            this.#jwksTimestamp = Date.now();\n            this.#pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this.#pendingFetch = undefined;\n            throw err;\n        });\n        await this.#pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => set.pendingFetch(),\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\n","import { generateGenericState, parseGenericState } from \"../state.mjs\";\nimport { generateState, parseState } from \"../oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./hide-metadata.mjs\";\nimport { generateId as generateId$1 } from \"@better-auth/core/utils\";\n\nexport { generateId$1 as generateId };","import { base64Url, base64 } from './base64.mjs';\nimport { getWebcryptoSubtle } from './index.mjs';\n\nfunction createHash(algorithm, encoding) {\n  return {\n    digest: async (input) => {\n      const encoder = new TextEncoder();\n      const data = typeof input === \"string\" ? encoder.encode(input) : input;\n      const hashBuffer = await getWebcryptoSubtle().digest(algorithm, data);\n      if (encoding === \"hex\") {\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n        return hashHex;\n      }\n      if (encoding === \"base64\" || encoding === \"base64url\" || encoding === \"base64urlnopad\") {\n        if (encoding.includes(\"url\")) {\n          return base64Url.encode(hashBuffer, {\n            padding: encoding !== \"base64urlnopad\"\n          });\n        }\n        const hashBase64 = base64.encode(hashBuffer);\n        return hashBase64;\n      }\n      return hashBuffer;\n    }\n  };\n}\n\nexport { createHash };\n","import { checkEncCryptoKey } from './crypto_key.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { JOSENotSupported } from '../util/errors.js';\nconst subtleAlgorithm = (alg) => {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n};\nexport async function encrypt(alg, key, cek) {\n    checkEncCryptoKey(key, alg, 'encrypt');\n    checkKeyLength(alg, key);\n    return new Uint8Array(await crypto.subtle.encrypt(subtleAlgorithm(alg), key, cek));\n}\nexport async function decrypt(alg, key, encryptedKey) {\n    checkEncCryptoKey(key, alg, 'decrypt');\n    checkKeyLength(alg, key);\n    return new Uint8Array(await crypto.subtle.decrypt(subtleAlgorithm(alg), key, encryptedKey));\n}\n","import { encode, concat, uint32be } from './buffer_utils.js';\nimport { checkEncCryptoKey } from './crypto_key.js';\nimport { digest } from './digest.js';\nfunction lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nasync function concatKdf(Z, L, OtherInfo) {\n    const dkLen = L >> 3;\n    const hashLen = 32;\n    const reps = Math.ceil(dkLen / hashLen);\n    const dk = new Uint8Array(reps * hashLen);\n    for (let i = 1; i <= reps; i++) {\n        const hashInput = new Uint8Array(4 + Z.length + OtherInfo.length);\n        hashInput.set(uint32be(i), 0);\n        hashInput.set(Z, 4);\n        hashInput.set(OtherInfo, 4 + Z.length);\n        const hashResult = await digest('sha256', hashInput);\n        dk.set(hashResult, (i - 1) * hashLen);\n    }\n    return dk.slice(0, dkLen);\n}\nexport async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(), apv = new Uint8Array()) {\n    checkEncCryptoKey(publicKey, 'ECDH');\n    checkEncCryptoKey(privateKey, 'ECDH', 'deriveBits');\n    const algorithmID = lengthAndInput(encode(algorithm));\n    const partyUInfo = lengthAndInput(apu);\n    const partyVInfo = lengthAndInput(apv);\n    const suppPubInfo = uint32be(keyLength);\n    const suppPrivInfo = new Uint8Array();\n    const otherInfo = concat(algorithmID, partyUInfo, partyVInfo, suppPubInfo, suppPrivInfo);\n    const Z = new Uint8Array(await crypto.subtle.deriveBits({\n        name: publicKey.algorithm.name,\n        public: publicKey,\n    }, privateKey, getEcdhBitLength(publicKey)));\n    return concatKdf(Z, keyLength, otherInfo);\n}\nfunction getEcdhBitLength(publicKey) {\n    if (publicKey.algorithm.name === 'X25519') {\n        return 256;\n    }\n    return (Math.ceil(parseInt(publicKey.algorithm.namedCurve.slice(-3), 10) / 8) << 3);\n}\nexport function allowed(key) {\n    switch (key.algorithm.namedCurve) {\n        case 'P-256':\n        case 'P-384':\n        case 'P-521':\n            return true;\n        default:\n            return key.algorithm.name === 'X25519';\n    }\n}\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport { isKeyLike } from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation must be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation must be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n        }\n    }\n};\nexport function checkKeyType(alg, key, usage) {\n    switch (alg.substring(0, 2)) {\n        case 'A1':\n        case 'A2':\n        case 'di':\n        case 'HS':\n        case 'PB':\n            symmetricTypeCheck(alg, key, usage);\n            break;\n        default:\n            asymmetricTypeCheck(alg, key, usage);\n    }\n}\n","import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport { isObject } from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        case 'ML':\n            return 'AKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nclass LocalJWKSet {\n    #jwks;\n    #cached = new WeakMap();\n    constructor(jwks) {\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this.#jwks = structuredClone(jwks);\n    }\n    jwks() {\n        return this.#jwks;\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token?.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this.#jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && (typeof jwk.alg === 'string' || kty === 'AKP')) {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                    case 'Ed25519':\n                    case 'EdDSA':\n                        candidate = jwk.crv === 'Ed25519';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const _cached = this.#cached;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch { }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this.#cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(localJWKSet, {\n        jwks: {\n            value: () => structuredClone(set.jwks()),\n            enumerable: false,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return localJWKSet;\n}\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { encoder, decoder } from './buffer_utils.js';\nimport { isObject } from './is_object.js';\nconst epoch = (date) => Math.floor(date.getTime() / 1000);\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport function secs(str) {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n}\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (value === undefined) {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function sign(alg, key, data) {\n    const cryptoKey = await getSigKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n}\n","import { invalidKeyInput } from './invalid_key_input.js';\nimport { encode as b64u } from '../util/base64url.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nexport async function keyToJWK(key) {\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            key = key.export();\n        }\n        else {\n            return key.export({ format: 'jwk' });\n        }\n    }\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: b64u(key),\n        };\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'Uint8Array'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await crypto.subtle.exportKey('jwk', key);\n    if (jwk.kty === 'AKP') {\n        ;\n        jwk.alg = alg;\n    }\n    return jwk;\n}\n","import { encrypt } from './encrypt.js';\nimport { decrypt } from './decrypt.js';\nimport { encode as b64u } from '../util/base64url.js';\nexport async function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.slice(0, 7);\n    const wrapped = await encrypt(jweAlgorithm, cek, key, iv, new Uint8Array());\n    return {\n        encryptedKey: wrapped.ciphertext,\n        iv: b64u(wrapped.iv),\n        tag: b64u(wrapped.tag),\n    };\n}\nexport async function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.slice(0, 7);\n    return decrypt(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array());\n}\n","import { flattenedDecrypt } from '../flattened/decrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await flattenedDecrypt({\n        ciphertext,\n        iv: iv || undefined,\n        protected: protectedHeader,\n        tag: tag || undefined,\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n","import { compactDecrypt } from '../jwe/compact/decrypt.js';\nimport { validateClaimsSet } from '../lib/jwt_claims_set.js';\nimport { JWTClaimValidationFailed } from '../util/errors.js';\nexport async function jwtDecrypt(jwt, key, options) {\n    const decrypted = await compactDecrypt(jwt, key, options);\n    const payload = validateClaimsSet(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', payload, 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', payload, 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', payload, 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function verify(alg, key, signature, data) {\n    const cryptoKey = await getSigKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { compactVerify } from '../jws/compact/verify.js';\nimport { validateClaimsSet } from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import { decode as b64u } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { isObject } from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(b64u(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n","import type { ProviderOptions } from \"./index\";\nimport { generateCodeChallenge } from \"./utils\";\n\nexport async function createAuthorizationURL({\n\tid,\n\toptions,\n\tauthorizationEndpoint,\n\tstate,\n\tcodeVerifier,\n\tscopes,\n\tclaims,\n\tredirectURI,\n\tduration,\n\tprompt,\n\taccessType,\n\tresponseType,\n\tdisplay,\n\tloginHint,\n\thd,\n\tresponseMode,\n\tadditionalParams,\n\tscopeJoiner,\n}: {\n\tid: string;\n\toptions: ProviderOptions;\n\tredirectURI: string;\n\tauthorizationEndpoint: string;\n\tstate: string;\n\tcodeVerifier?: string | undefined;\n\tscopes?: string[] | undefined;\n\tclaims?: string[] | undefined;\n\tduration?: string | undefined;\n\tprompt?: string | undefined;\n\taccessType?: string | undefined;\n\tresponseType?: string | undefined;\n\tdisplay?: string | undefined;\n\tloginHint?: string | undefined;\n\thd?: string | undefined;\n\tresponseMode?: string | undefined;\n\tadditionalParams?: Record<string, string> | undefined;\n\tscopeJoiner?: string | undefined;\n}) {\n\tconst url = new URL(options.authorizationEndpoint || authorizationEndpoint);\n\turl.searchParams.set(\"response_type\", responseType || \"code\");\n\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t? options.clientId[0]\n\t\t: options.clientId;\n\turl.searchParams.set(\"client_id\", primaryClientId);\n\turl.searchParams.set(\"state\", state);\n\tif (scopes) {\n\t\turl.searchParams.set(\"scope\", scopes.join(scopeJoiner || \" \"));\n\t}\n\turl.searchParams.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\tduration && url.searchParams.set(\"duration\", duration);\n\tdisplay && url.searchParams.set(\"display\", display);\n\tloginHint && url.searchParams.set(\"login_hint\", loginHint);\n\tprompt && url.searchParams.set(\"prompt\", prompt);\n\thd && url.searchParams.set(\"hd\", hd);\n\taccessType && url.searchParams.set(\"access_type\", accessType);\n\tresponseMode && url.searchParams.set(\"response_mode\", responseMode);\n\tif (codeVerifier) {\n\t\tconst codeChallenge = await generateCodeChallenge(codeVerifier);\n\t\turl.searchParams.set(\"code_challenge_method\", \"S256\");\n\t\turl.searchParams.set(\"code_challenge\", codeChallenge);\n\t}\n\tif (claims) {\n\t\tconst claimsObj = claims.reduce(\n\t\t\t(acc, claim) => {\n\t\t\t\tacc[claim] = null;\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{} as Record<string, null>,\n\t\t);\n\t\turl.searchParams.set(\n\t\t\t\"claims\",\n\t\t\tJSON.stringify({\n\t\t\t\tid_token: { email: null, email_verified: null, ...claimsObj },\n\t\t\t}),\n\t\t);\n\t}\n\tif (additionalParams) {\n\t\tObject.entries(additionalParams).forEach(([key, value]) => {\n\t\t\turl.searchParams.set(key, value);\n\t\t});\n\t}\n\treturn url;\n}\n","import { defineRequestState } from \"@better-auth/core/context\";\n\ntype OAuthState = {\n\tcallbackURL: string;\n\tcodeVerifier: string;\n\terrorURL?: string;\n\tnewUserURL?: string;\n\tlink?: {\n\t\temail: string;\n\t\tuserId: string;\n\t};\n\texpiresAt: number;\n\trequestSignUp?: boolean;\n\t[key: string]: any;\n};\n\nconst {\n\tget: getOAuthState,\n\t/**\n\t * @internal This is unsafe to be used directly. Use setOAuthState instead.\n\t */\n\tset: setOAuthState,\n} = defineRequestState<OAuthState | null>(() => null);\n\nexport { getOAuthState, setOAuthState };\n","import { createRandomStringGenerator } from \"@better-auth/utils/random\";\nexport const generateRandomString = createRandomStringGenerator(\n\t\"a-z\",\n\t\"0-9\",\n\t\"A-Z\",\n\t\"-_\",\n);\n","import { hex } from './hex.mjs';\nimport { base64Url, base64 } from './base64.mjs';\nimport { getWebcryptoSubtle } from './index.mjs';\n\nconst createHMAC = (algorithm = \"SHA-256\", encoding = \"none\") => {\n  const hmac = {\n    importKey: async (key, keyUsage) => {\n      return getWebcryptoSubtle().importKey(\n        \"raw\",\n        typeof key === \"string\" ? new TextEncoder().encode(key) : key,\n        { name: \"HMAC\", hash: { name: algorithm } },\n        false,\n        [keyUsage]\n      );\n    },\n    sign: async (hmacKey, data) => {\n      if (typeof hmacKey === \"string\") {\n        hmacKey = await hmac.importKey(hmacKey, \"sign\");\n      }\n      const signature = await getWebcryptoSubtle().sign(\n        \"HMAC\",\n        hmacKey,\n        typeof data === \"string\" ? new TextEncoder().encode(data) : data\n      );\n      if (encoding === \"hex\") {\n        return hex.encode(signature);\n      }\n      if (encoding === \"base64\" || encoding === \"base64url\" || encoding === \"base64urlnopad\") {\n        return base64Url.encode(signature, {\n          padding: encoding !== \"base64urlnopad\"\n        });\n      }\n      return signature;\n    },\n    verify: async (hmacKey, data, signature) => {\n      if (typeof hmacKey === \"string\") {\n        hmacKey = await hmac.importKey(hmacKey, \"verify\");\n      }\n      if (encoding === \"hex\") {\n        signature = hex.decode(signature);\n      }\n      if (encoding === \"base64\" || encoding === \"base64url\" || encoding === \"base64urlnopad\") {\n        signature = await base64.decode(signature);\n      }\n      return getWebcryptoSubtle().verify(\n        \"HMAC\",\n        hmacKey,\n        typeof signature === \"string\" ? new TextEncoder().encode(signature) : signature,\n        typeof data === \"string\" ? new TextEncoder().encode(data) : data\n      );\n    }\n  };\n  return hmac;\n};\n\nexport { createHMAC };\n","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport { jwkToKey } from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await jwkToKey({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    switch (keyObject.asymmetricKeyType) {\n        case 'ml-dsa-44':\n        case 'ml-dsa-65':\n        case 'ml-dsa-87': {\n            if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n            }\n            cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n                isPublic ? 'verify' : 'sign',\n            ]);\n        }\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport async function normalizeKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n}\n","import * as b64u from '../util/base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { validateClaimsSet, JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class UnsecuredJWT {\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    encode() {\n        const header = b64u.encode(JSON.stringify({ alg: 'none' }));\n        const payload = b64u.encode(this.#jwt.data());\n        return `${header}.${payload}.`;\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(decoder.decode(b64u.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch {\n            throw new JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = validateClaimsSet(header, b64u.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n","import { decode as b64u } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport { isObject } from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = b64u(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\n\nexport async function validatePassword(\n\tctx: GenericEndpointContext,\n\tdata: {\n\t\tpassword: string;\n\t\tuserId: string;\n\t},\n) {\n\tconst accounts = await ctx.context.internalAdapter.findAccounts(data.userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword) {\n\t\treturn false;\n\t}\n\tconst compare = await ctx.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: data.password,\n\t});\n\treturn compare;\n}\n\nexport async function checkPassword(userId: string, c: GenericEndpointContext) {\n\tconst accounts = await c.context.internalAdapter.findAccounts(userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword || !c.body.password) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"No password credential found\",\n\t\t});\n\t}\n\tconst compare = await c.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: c.body.password,\n\t});\n\tif (!compare) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Invalid password\",\n\t\t});\n\t}\n\treturn true;\n}\n","import { base64Url } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuth2Tokens, ProviderOptions } from \"./oauth-provider\";\n\nexport function createClientCredentialsTokenRequest({\n\toptions,\n\tscope,\n\tauthentication,\n\tresource,\n}: {\n\toptions: ProviderOptions & { clientSecret: string };\n\tscope?: string | undefined;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\tresource?: (string | string[]) | undefined;\n}) {\n\tconst body = new URLSearchParams();\n\tconst headers: Record<string, any> = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\",\n\t};\n\n\tbody.set(\"grant_type\", \"client_credentials\");\n\tscope && body.set(\"scope\", scope);\n\tif (resource) {\n\t\tif (typeof resource === \"string\") {\n\t\t\tbody.append(\"resource\", resource);\n\t\t} else {\n\t\t\tfor (const _resource of resource) {\n\t\t\t\tbody.append(\"resource\", _resource);\n\t\t\t}\n\t\t}\n\t}\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tconst encodedCredentials = base64Url.encode(\n\t\t\t`${primaryClientId}:${options.clientSecret}`,\n\t\t);\n\t\theaders[\"authorization\"] = `Basic ${encodedCredentials}`;\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tbody.set(\"client_secret\", options.clientSecret);\n\t}\n\n\treturn {\n\t\tbody,\n\t\theaders,\n\t};\n}\n\nexport async function clientCredentialsToken({\n\toptions,\n\ttokenEndpoint,\n\tscope,\n\tauthentication,\n\tresource,\n}: {\n\toptions: ProviderOptions & { clientSecret: string };\n\ttokenEndpoint: string;\n\tscope: string;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\tresource?: (string | string[]) | undefined;\n}): Promise<OAuth2Tokens> {\n\tconst { body, headers } = createClientCredentialsTokenRequest({\n\t\toptions,\n\t\tscope,\n\t\tauthentication,\n\t\tresource,\n\t});\n\n\tconst { data, error } = await betterFetch<{\n\t\taccess_token: string;\n\t\texpires_in?: number | undefined;\n\t\ttoken_type?: string | undefined;\n\t\tscope?: string | undefined;\n\t}>(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody,\n\t\theaders,\n\t});\n\tif (error) {\n\t\tthrow error;\n\t}\n\tconst tokens: OAuth2Tokens = {\n\t\taccessToken: data.access_token,\n\t\ttokenType: data.token_type,\n\t\tscopes: data.scope?.split(\" \"),\n\t};\n\n\tif (data.expires_in) {\n\t\tconst now = new Date();\n\t\ttokens.accessTokenExpiresAt = new Date(\n\t\t\tnow.getTime() + data.expires_in * 1000,\n\t\t);\n\t}\n\n\treturn tokens;\n}\n","import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { deleteSessionCookie } from \"../../cookies\";\n\nexport const signOut = createAuthEndpoint(\n\t\"/sign-out\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"signOut\",\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"signOut\",\n\t\t\t\tdescription: \"Sign out the current user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst sessionCookieToken = await ctx.getSignedCookie(\n\t\t\tctx.context.authCookies.sessionToken.name,\n\t\t\tctx.context.secret,\n\t\t);\n\t\tif (sessionCookieToken) {\n\t\t\ttry {\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(sessionCookieToken);\n\t\t\t} catch (e) {\n\t\t\t\tctx.context.logger.error(\"Failed to delete session from database\", e);\n\t\t\t}\n\t\t}\n\t\tdeleteSessionCookie(ctx);\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t});\n\t},\n);\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuth2Tokens, ProviderOptions } from \"./oauth-provider\";\n\nexport function createRefreshAccessTokenRequest({\n\trefreshToken,\n\toptions,\n\tauthentication,\n\textraParams,\n\tresource,\n}: {\n\trefreshToken: string;\n\toptions: Partial<ProviderOptions>;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\textraParams?: Record<string, string> | undefined;\n\tresource?: (string | string[]) | undefined;\n}) {\n\tconst body = new URLSearchParams();\n\tconst headers: Record<string, any> = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\",\n\t};\n\n\tbody.set(\"grant_type\", \"refresh_token\");\n\tbody.set(\"refresh_token\", refreshToken);\n\t// Use standard Base64 encoding for HTTP Basic Auth (OAuth2 spec, RFC 7617)\n\t// Fixes compatibility with providers like Notion, Twitter, etc.\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tif (primaryClientId) {\n\t\t\theaders[\"authorization\"] =\n\t\t\t\t\"Basic \" +\n\t\t\t\tbase64.encode(`${primaryClientId}:${options.clientSecret ?? \"\"}`);\n\t\t} else {\n\t\t\theaders[\"authorization\"] =\n\t\t\t\t\"Basic \" + base64.encode(`:${options.clientSecret ?? \"\"}`);\n\t\t}\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tif (options.clientSecret) {\n\t\t\tbody.set(\"client_secret\", options.clientSecret);\n\t\t}\n\t}\n\n\tif (resource) {\n\t\tif (typeof resource === \"string\") {\n\t\t\tbody.append(\"resource\", resource);\n\t\t} else {\n\t\t\tfor (const _resource of resource) {\n\t\t\t\tbody.append(\"resource\", _resource);\n\t\t\t}\n\t\t}\n\t}\n\tif (extraParams) {\n\t\tfor (const [key, value] of Object.entries(extraParams)) {\n\t\t\tbody.set(key, value);\n\t\t}\n\t}\n\n\treturn {\n\t\tbody,\n\t\theaders,\n\t};\n}\n\nexport async function refreshAccessToken({\n\trefreshToken,\n\toptions,\n\ttokenEndpoint,\n\tauthentication,\n\textraParams,\n}: {\n\trefreshToken: string;\n\toptions: Partial<ProviderOptions>;\n\ttokenEndpoint: string;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\textraParams?: Record<string, string> | undefined;\n\t/** @deprecated always \"refresh_token\" */\n\tgrantType?: string | undefined;\n}): Promise<OAuth2Tokens> {\n\tconst { body, headers } = createRefreshAccessTokenRequest({\n\t\trefreshToken,\n\t\toptions,\n\t\tauthentication,\n\t\textraParams,\n\t});\n\n\tconst { data, error } = await betterFetch<{\n\t\taccess_token: string;\n\t\trefresh_token?: string | undefined;\n\t\texpires_in?: number | undefined;\n\t\ttoken_type?: string | undefined;\n\t\tscope?: string | undefined;\n\t\tid_token?: string | undefined;\n\t}>(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody,\n\t\theaders,\n\t});\n\tif (error) {\n\t\tthrow error;\n\t}\n\tconst tokens: OAuth2Tokens = {\n\t\taccessToken: data.access_token,\n\t\trefreshToken: data.refresh_token,\n\t\ttokenType: data.token_type,\n\t\tscopes: data.scope?.split(\" \"),\n\t\tidToken: data.id_token,\n\t};\n\n\tif (data.expires_in) {\n\t\tconst now = new Date();\n\t\ttokens.accessTokenExpiresAt = new Date(\n\t\t\tnow.getTime() + data.expires_in * 1000,\n\t\t);\n\t}\n\n\treturn tokens;\n}\n","import { encode as b64u } from '../util/base64url.js';\nimport * as aeskw from './aeskw.js';\nimport { checkEncCryptoKey } from './crypto_key.js';\nimport { concat, encode } from './buffer_utils.js';\nimport { JWEInvalid } from '../util/errors.js';\nfunction getCryptoKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return crypto.subtle.importKey('raw', key, 'PBKDF2', false, [\n            'deriveBits',\n        ]);\n    }\n    checkEncCryptoKey(key, alg, 'deriveBits');\n    return key;\n}\nconst concatSalt = (alg, p2sInput) => concat(encode(alg), Uint8Array.of(0x00), p2sInput);\nasync function deriveKey(p2s, alg, p2c, key) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n    const salt = concatSalt(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10);\n    const subtleAlg = {\n        hash: `SHA-${alg.slice(8, 11)}`,\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const cryptoKey = await getCryptoKey(key, alg);\n    return new Uint8Array(await crypto.subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n}\nexport async function wrap(alg, key, cek, p2c = 2048, p2s = crypto.getRandomValues(new Uint8Array(16))) {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    const encryptedKey = await aeskw.wrap(alg.slice(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: b64u(p2s) };\n}\nexport async function unwrap(alg, key, encryptedKey, p2c, p2s) {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    return aeskw.unwrap(alg.slice(-6), derived, encryptedKey);\n}\n","import { decode as decodeBase64URL } from '../util/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../lib/asn1.js';\nimport { jwkToKey } from '../lib/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isObject } from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, options) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let ext;\n    alg ??= jwk.alg;\n    ext ??= options?.extractable ?? jwk.ext;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n            return jwkToKey({ ...jwk, alg, ext });\n        case 'AKP': {\n            if (typeof jwk.alg !== 'string' || !jwk.alg) {\n                throw new TypeError('missing \"alg\" (Algorithm) Parameter value');\n            }\n            if (alg !== undefined && alg !== jwk.alg) {\n                throw new TypeError('JWK alg and alg option value mismatch');\n            }\n            return jwkToKey({ ...jwk, ext });\n        }\n        case 'EC':\n        case 'OKP':\n            return jwkToKey({ ...jwk, alg, ext });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","/**\n * Compare two buffers in constant time.\n */\nexport function constantTimeEqual(\n\ta: ArrayBuffer | Uint8Array | string,\n\tb: ArrayBuffer | Uint8Array | string,\n): boolean {\n\tif (typeof a === \"string\") {\n\t\ta = new TextEncoder().encode(a);\n\t}\n\tif (typeof b === \"string\") {\n\t\tb = new TextEncoder().encode(b);\n\t}\n\tconst aBuffer = new Uint8Array(a);\n\tconst bBuffer = new Uint8Array(b);\n\tlet c = aBuffer.length ^ bBuffer.length;\n\tconst length = Math.max(aBuffer.length, bBuffer.length);\n\tfor (let i = 0; i < length; i++) {\n\t\tc |=\n\t\t\t(i < aBuffer.length ? aBuffer[i]! : 0) ^\n\t\t\t(i < bBuffer.length ? bBuffer[i]! : 0);\n\t}\n\treturn c === 0;\n}\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import type { EndpointOptions } from \"./endpoint\";\nimport type { InputContext } from \"./context\";\nimport type { StandardSchemaV1 } from \"./standard-schema\";\n\ntype ValidationResponse =\n\t| {\n\t\t\tdata: {\n\t\t\t\tbody: any;\n\t\t\t\tquery: any;\n\t\t\t};\n\t\t\terror: null;\n\t  }\n\t| {\n\t\t\tdata: null;\n\t\t\terror: {\n\t\t\t\tmessage: string;\n\t\t\t\tissues: readonly StandardSchemaV1.Issue[];\n\t\t\t};\n\t  };\n\n/**\n * Runs validation on body and query\n * @returns error and data object\n */\nexport async function runValidation(\n\toptions: EndpointOptions,\n\tcontext: InputContext<any, any> = {},\n): Promise<ValidationResponse> {\n\tlet request = {\n\t\tbody: context.body,\n\t\tquery: context.query,\n\t} as {\n\t\tbody: any;\n\t\tquery: any;\n\t};\n\tif (options.body) {\n\t\tconst result = await options.body[\"~standard\"].validate(context.body);\n\t\tif (result.issues) {\n\t\t\treturn {\n\t\t\t\tdata: null,\n\t\t\t\terror: fromError(result.issues, \"body\"),\n\t\t\t};\n\t\t}\n\t\trequest.body = result.value;\n\t}\n\n\tif (options.query) {\n\t\tconst result = await options.query[\"~standard\"].validate(context.query);\n\t\tif (result.issues) {\n\t\t\treturn {\n\t\t\t\tdata: null,\n\t\t\t\terror: fromError(result.issues, \"query\"),\n\t\t\t};\n\t\t}\n\t\trequest.query = result.value;\n\t}\n\tif (options.requireHeaders && !context.headers) {\n\t\treturn {\n\t\t\tdata: null,\n\t\t\terror: { message: \"Headers is required\", issues: [] },\n\t\t};\n\t}\n\tif (options.requireRequest && !context.request) {\n\t\treturn {\n\t\t\tdata: null,\n\t\t\terror: { message: \"Request is required\", issues: [] },\n\t\t};\n\t}\n\treturn {\n\t\tdata: request,\n\t\terror: null,\n\t};\n}\n\nfunction fromError(error: readonly StandardSchemaV1.Issue[], validating: string) {\n\tconst message = error\n\t\t.map((e) => {\n\t\t\treturn `[${e.path?.length ? `${validating}.` + e.path.map((x) => (typeof x === \"object\" ? x.key : x)).join(\".\") : validating}] ${e.message}`;\n\t\t})\n\t\t.join(\"; \");\n\n\treturn {\n\t\tmessage,\n\t\tissues: error,\n\t};\n}\n","import * as z from \"zod\";\n\nexport const coreSchema = z.object({\n\tid: z.string(),\n\tcreatedAt: z.date().default(() => new Date()),\n\tupdatedAt: z.date().default(() => new Date()),\n});\n","import { APIError } from \"./error\";\n\nconst jsonContentTypeRegex = /^application\\/([a-z0-9.+-]*\\+)?json/i;\n\nexport async function getBody(request: Request, allowedMediaTypes?: string[]) {\n\tconst contentType = request.headers.get(\"content-type\") || \"\";\n\tconst normalizedContentType = contentType.toLowerCase();\n\n\tif (!request.body) {\n\t\treturn undefined;\n\t}\n\n\t// Validate content-type if allowedMediaTypes is provided\n\tif (allowedMediaTypes && allowedMediaTypes.length > 0) {\n\t\tconst isAllowed = allowedMediaTypes.some((allowed) => {\n\t\t\t// Normalize both content types for comparison\n\t\t\tconst normalizedContentTypeBase = normalizedContentType.split(\";\")[0].trim();\n\t\t\tconst normalizedAllowed = allowed.toLowerCase().trim();\n\t\t\treturn (\n\t\t\t\tnormalizedContentTypeBase === normalizedAllowed ||\n\t\t\t\tnormalizedContentTypeBase.includes(normalizedAllowed)\n\t\t\t);\n\t\t});\n\n\t\tif (!isAllowed) {\n\t\t\tif (!normalizedContentType) {\n\t\t\t\tthrow new APIError(415, {\n\t\t\t\t\tmessage: `Content-Type is required. Allowed types: ${allowedMediaTypes.join(\", \")}`,\n\t\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow new APIError(415, {\n\t\t\t\tmessage: `Content-Type \"${contentType}\" is not allowed. Allowed types: ${allowedMediaTypes.join(\", \")}`,\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t});\n\t\t}\n\t}\n\n\tif (jsonContentTypeRegex.test(normalizedContentType)) {\n\t\treturn await request.json();\n\t}\n\n\tif (normalizedContentType.includes(\"application/x-www-form-urlencoded\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result: Record<string, string> = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value.toString();\n\t\t});\n\t\treturn result;\n\t}\n\n\tif (normalizedContentType.includes(\"multipart/form-data\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result: Record<string, any> = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value;\n\t\t});\n\t\treturn result;\n\t}\n\n\tif (normalizedContentType.includes(\"text/plain\")) {\n\t\treturn await request.text();\n\t}\n\n\tif (normalizedContentType.includes(\"application/octet-stream\")) {\n\t\treturn await request.arrayBuffer();\n\t}\n\n\tif (\n\t\tnormalizedContentType.includes(\"application/pdf\") ||\n\t\tnormalizedContentType.includes(\"image/\") ||\n\t\tnormalizedContentType.includes(\"video/\")\n\t) {\n\t\tconst blob = await request.blob();\n\t\treturn blob;\n\t}\n\n\tif (\n\t\tnormalizedContentType.includes(\"application/stream\") ||\n\t\trequest.body instanceof ReadableStream\n\t) {\n\t\treturn request.body;\n\t}\n\n\treturn await request.text();\n}\n\nexport function isAPIError(error: any): error is APIError {\n\treturn error instanceof APIError || error?.name === \"APIError\";\n}\n\nexport function tryDecode(str: string) {\n\ttry {\n\t\treturn str.includes(\"%\") ? decodeURIComponent(str) : str;\n\t} catch {\n\t\treturn str;\n\t}\n}\n\ntype Success<T> = {\n\tdata: T;\n\terror: null;\n};\n\ntype Failure<E> = {\n\tdata: null;\n\terror: E;\n};\n\ntype Result<T, E = Error> = Success<T> | Failure<E>;\n\nexport async function tryCatch<T, E = Error>(promise: Promise<T>): Promise<Result<T, E>> {\n\ttry {\n\t\tconst data = await promise;\n\t\treturn { data, error: null };\n\t} catch (error) {\n\t\treturn { data: null, error: error as E };\n\t}\n}\n\n/**\n * Check if an object is a `Request`\n * - `instanceof`: works for native Request instances\n * - `toString`: handles where instanceof check fails but the object is still a valid Request\n */\nexport function isRequest(obj: unknown): obj is Request {\n\treturn obj instanceof Request || Object.prototype.toString.call(obj) === \"[object Request]\";\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n} from \"@better-auth/core/context\";\nimport type { BaseModelNames } from \"@better-auth/core/db\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\n\nexport function getWithHooks(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: BetterAuthOptions;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t},\n) {\n\tconst hooks = ctx.hooks;\n\tasync function createWithHooks<T extends Record<string, any>>(\n\t\tdata: T,\n\t\tmodel: BaseModelNames,\n\t\tcustomCreateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(actualData as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customCreated = customCreateFn\n\t\t\t? await customCreateFn.fn(actualData)\n\t\t\t: null;\n\t\tconst created =\n\t\t\t!customCreateFn || customCreateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).create<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: actualData as any,\n\t\t\t\t\t\tforceAllowId: true,\n\t\t\t\t\t})\n\t\t\t\t: customCreated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(created as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tasync function updateWithHooks<T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).update<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\tasync function updateManyWithHooks<_T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\tasync function deleteWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entityToDelete: T | null = null;\n\n\t\ttry {\n\t\t\tconst entities = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tentityToDelete = entities[0] || null;\n\t\t} catch {\n\t\t\t// If we can't find the entity, we'll still proceed with deletion\n\t\t}\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entityToDelete as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).delete({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entityToDelete as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\tasync function deleteManyWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entitiesToDelete: T[] = [];\n\n\t\ttry {\n\t\t\tentitiesToDelete = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t});\n\t\t} catch {\n\t\t\t// If we can't find the entities, we'll still proceed with deletion\n\t\t}\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entity as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entity as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\treturn {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t};\n}\n","import type { AuthContext } from \"@better-auth/core\";\nimport { symmetricDecrypt, symmetricEncrypt } from \"../crypto\";\n\nexport function decryptOAuthToken(token: string, ctx: AuthContext) {\n\tif (!token) return token;\n\tif (ctx.options.account?.encryptOAuthTokens) {\n\t\treturn symmetricDecrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n\nexport function setTokenUtil(\n\ttoken: string | null | undefined,\n\tctx: AuthContext,\n) {\n\tif (ctx.options.account?.encryptOAuthTokens && token) {\n\t\treturn symmetricEncrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n","import { hkdf } from \"@noble/hashes/hkdf.js\";\nimport { sha256 } from \"@noble/hashes/sha2.js\";\nimport {\n\tbase64url,\n\tcalculateJwkThumbprint,\n\tEncryptJWT,\n\tjwtDecrypt,\n\tjwtVerify,\n\tSignJWT,\n} from \"jose\";\n\nexport async function signJWT(\n\tpayload: any,\n\tsecret: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst jwt = await new SignJWT(payload)\n\t\t.setProtectedHeader({ alg: \"HS256\" })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)\n\t\t.sign(new TextEncoder().encode(secret));\n\n\treturn jwt;\n}\n\nexport async function verifyJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n): Promise<T | null> {\n\ttry {\n\t\tconst verified = await jwtVerify(token, new TextEncoder().encode(secret));\n\t\treturn verified.payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\n// \"BetterAuth.js Generated Encryption Key\"\nconst info: Uint8Array = new Uint8Array([\n\t66, 101, 116, 116, 101, 114, 65, 117, 116, 104, 46, 106, 115, 32, 71, 101,\n\t110, 101, 114, 97, 116, 101, 100, 32, 69, 110, 99, 114, 121, 112, 116, 105,\n\t111, 110, 32, 75, 101, 121,\n]);\n\nconst now = () => (Date.now() / 1000) | 0;\n\nconst alg = \"dir\";\nconst enc = \"A256CBC-HS512\"; // 64 bytes key\n\nexport async function symmetricEncodeJWT<T extends Record<string, any>>(\n\tpayload: T,\n\tsecret: string,\n\tsalt: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst encryptionSecret = hkdf(\n\t\tsha256,\n\t\tnew TextEncoder().encode(secret),\n\t\tnew TextEncoder().encode(salt),\n\t\tinfo,\n\t\t64,\n\t);\n\n\tconst thumbprint = await calculateJwkThumbprint(\n\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\"sha256\",\n\t);\n\n\treturn await new EncryptJWT(payload)\n\t\t.setProtectedHeader({ alg, enc, kid: thumbprint })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(now() + expiresIn)\n\t\t.setJti(crypto.randomUUID())\n\t\t.encrypt(encryptionSecret);\n}\n\nexport async function symmetricDecodeJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n\tsalt: string,\n): Promise<T | null> {\n\tif (!token) return null;\n\ttry {\n\t\tconst { payload } = await jwtDecrypt(\n\t\t\ttoken,\n\t\t\tasync ({ kid }) => {\n\t\t\t\tconst encryptionSecret = hkdf(\n\t\t\t\t\tsha256,\n\t\t\t\t\tnew TextEncoder().encode(secret),\n\t\t\t\t\tnew TextEncoder().encode(salt),\n\t\t\t\t\tinfo,\n\t\t\t\t\t64,\n\t\t\t\t);\n\t\t\t\tif (kid === undefined) return encryptionSecret;\n\n\t\t\t\tconst thumbprint = await calculateJwkThumbprint(\n\t\t\t\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\t\t\t\"sha256\",\n\t\t\t\t);\n\t\t\t\tif (kid === thumbprint) return encryptionSecret;\n\n\t\t\t\tthrow new Error(\"no matching decryption secret\");\n\t\t\t},\n\t\t\t{\n\t\t\t\tclockTolerance: 15,\n\t\t\t\tkeyManagementAlgorithms: [alg],\n\t\t\t\tcontentEncryptionAlgorithms: [enc, \"A256GCM\"],\n\t\t\t},\n\t\t);\n\t\treturn payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number, title: string = ''): void {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts something is hash */\nexport function ahash(h: CHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash must wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'digestInto() output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput, errorTitle = ''): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  return abytes(data, undefined, errorTitle);\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\n/** Merges default options and passed options. */\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Common interface for all hashes. */\nexport interface Hash<T> {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: Uint8Array): this;\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  destroy(): void;\n  _cloneInto(to?: T): T;\n  clone(): T;\n}\n\n/** PseudoRandom (number) Generator */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash constructor */\nexport type HasherCons<T, Opts = undefined> = Opts extends undefined ? () => T : (opts?: Opts) => T;\n/** Optional hash params. */\nexport type HashInfo = {\n  oid?: Uint8Array; // DER encoded OID in bytes\n};\n/** Hash function */\nexport type CHash<T extends Hash<T> = Hash<any>, Opts = undefined> = {\n  outputLen: number;\n  blockLen: number;\n} & HashInfo &\n  (Opts extends undefined\n    ? {\n        (msg: Uint8Array): Uint8Array;\n        create(): T;\n      }\n    : {\n        (msg: Uint8Array, opts?: Opts): Uint8Array;\n        create(opts?: Opts): T;\n      });\n/** XOF with output */\nexport type CHashXOF<T extends HashXOF<T> = HashXOF<any>, Opts = undefined> = CHash<T, Opts>;\n\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher<T extends Hash<T>, Opts = undefined>(\n  hashCons: HasherCons<T, Opts>,\n  info: HashInfo = {}\n): CHash<T, Opts> {\n  const hashC: any = (msg: Uint8Array, opts?: Opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: Opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix: number): Required<HashInfo> => ({\n  oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { isDevelopment, isTest } from \"@better-auth/core/env\";\nimport { isValidIP, normalizeIP } from \"@better-auth/core/utils\";\n\n// Localhost IP used for test and development environments\nconst LOCALHOST_IP = \"127.0.0.1\";\n\nexport function getIp(\n\treq: Request | Headers,\n\toptions: BetterAuthOptions,\n): string | null {\n\tif (options.advanced?.ipAddress?.disableIpTracking) {\n\t\treturn null;\n\t}\n\n\tconst headers = \"headers\" in req ? req.headers : req;\n\n\tconst defaultHeaders = [\"x-forwarded-for\"];\n\n\tconst ipHeaders =\n\t\toptions.advanced?.ipAddress?.ipAddressHeaders || defaultHeaders;\n\n\tfor (const key of ipHeaders) {\n\t\tconst value = \"get\" in headers ? headers.get(key) : headers[key];\n\t\tif (typeof value === \"string\") {\n\t\t\tconst ip = value.split(\",\")[0]!.trim();\n\t\t\tif (isValidIP(ip)) {\n\t\t\t\treturn normalizeIP(ip, {\n\t\t\t\t\tipv6Subnet: options.advanced?.ipAddress?.ipv6Subnet,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to localhost IP in development/test environments when no IP found in headers\n\tif (isTest() || isDevelopment()) {\n\t\treturn LOCALHOST_IP;\n\t}\n\n\treturn null;\n}\n","import type { AuthContext, HookEndpointContext } from \"@better-auth/core\";\nimport type { AuthEndpoint, AuthMiddleware } from \"@better-auth/core/api\";\nimport {\n\thasRequestState,\n\trunWithEndpointContext,\n\trunWithRequestState,\n} from \"@better-auth/core/context\";\nimport { shouldPublishLog } from \"@better-auth/core/env\";\nimport type {\n\tEndpointContext,\n\tEndpointOptions,\n\tInputContext,\n} from \"better-call\";\nimport { APIError, toResponse } from \"better-call\";\nimport { createDefu } from \"defu\";\n\ntype InternalContext = Partial<\n\tInputContext<string, any> & EndpointContext<string, any>\n> & {\n\tpath: string;\n\tasResponse?: boolean | undefined;\n\tcontext: AuthContext & {\n\t\tlogger: AuthContext[\"logger\"];\n\t\treturned?: unknown | undefined;\n\t\tresponseHeaders?: Headers | undefined;\n\t};\n};\n\nconst defuReplaceArrays = createDefu((obj, key, value) => {\n\tif (Array.isArray(obj[key]) && Array.isArray(value)) {\n\t\tobj[key] = value;\n\t\treturn true;\n\t}\n});\n\nconst hooksSourceWeakMap = new WeakMap<\n\tAuthMiddleware,\n\t`user` | `plugin:${string}`\n>();\n\ntype UserInputContext = Partial<\n\tInputContext<string, any> & EndpointContext<string, any>\n>;\n\nexport function toAuthEndpoints<\n\tconst E extends Record<\n\t\tstring,\n\t\tOmit<AuthEndpoint<string, EndpointOptions, any>, \"wrap\">\n\t>,\n>(endpoints: E, ctx: AuthContext | Promise<AuthContext>): E {\n\tconst api: Record<\n\t\tstring,\n\t\t((\n\t\t\tcontext: EndpointContext<string, any> & InputContext<string, any>,\n\t\t) => Promise<any>) & {\n\t\t\tpath?: string | undefined;\n\t\t\toptions?: EndpointOptions | undefined;\n\t\t}\n\t> = {};\n\n\tfor (const [key, endpoint] of Object.entries(endpoints)) {\n\t\tapi[key] = async (context?: UserInputContext) => {\n\t\t\tconst run = async () => {\n\t\t\t\tconst authContext = await ctx;\n\t\t\t\tlet internalContext: InternalContext = {\n\t\t\t\t\t...context,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\t...authContext,\n\t\t\t\t\t\treturned: undefined,\n\t\t\t\t\t\tresponseHeaders: undefined,\n\t\t\t\t\t\tsession: null,\n\t\t\t\t\t},\n\t\t\t\t\tpath: endpoint.path,\n\t\t\t\t\theaders: context?.headers ? new Headers(context?.headers) : undefined,\n\t\t\t\t};\n\t\t\t\treturn runWithEndpointContext(internalContext, async () => {\n\t\t\t\t\tconst { beforeHooks, afterHooks } = getHooks(authContext);\n\t\t\t\t\tconst before = await runBeforeHooks(internalContext, beforeHooks);\n\t\t\t\t\t/**\n\t\t\t\t\t * If `before.context` is returned, it should\n\t\t\t\t\t * get merged with the original context\n\t\t\t\t\t */\n\t\t\t\t\tif (\n\t\t\t\t\t\t\"context\" in before &&\n\t\t\t\t\t\tbefore.context &&\n\t\t\t\t\t\ttypeof before.context === \"object\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst { headers, ...rest } = before.context as {\n\t\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Headers should be merged differently\n\t\t\t\t\t\t * so the hook doesn't override the whole\n\t\t\t\t\t\t * header\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (headers) {\n\t\t\t\t\t\t\theaders.forEach((value, key) => {\n\t\t\t\t\t\t\t\t(internalContext.headers as Headers).set(key, value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinternalContext = defuReplaceArrays(rest, internalContext);\n\t\t\t\t\t} else if (before) {\n\t\t\t\t\t\t/* Return before hook response if it's anything other than a context return */\n\t\t\t\t\t\treturn context?.asResponse\n\t\t\t\t\t\t\t? toResponse(before, {\n\t\t\t\t\t\t\t\t\theaders: context?.headers,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: context?.returnHeaders\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\theaders: context?.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: before,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: before;\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalContext.asResponse = false;\n\t\t\t\t\tinternalContext.returnHeaders = true;\n\t\t\t\t\tinternalContext.returnStatus = true;\n\t\t\t\t\tconst result = (await runWithEndpointContext(internalContext, () =>\n\t\t\t\t\t\t(endpoint as any)(internalContext as any),\n\t\t\t\t\t).catch((e: any) => {\n\t\t\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * API Errors from response are caught\n\t\t\t\t\t\t\t * and returned to hooks\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tresponse: e,\n\t\t\t\t\t\t\t\tstatus: e.statusCode,\n\t\t\t\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t})) as {\n\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\tresponse: any;\n\t\t\t\t\t\tstatus: number;\n\t\t\t\t\t};\n\n\t\t\t\t\t//if response object is returned we skip after hooks and post processing\n\t\t\t\t\tif (result && result instanceof Response) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalContext.context.returned = result.response;\n\t\t\t\t\tinternalContext.context.responseHeaders = result.headers;\n\n\t\t\t\t\tconst after = await runAfterHooks(internalContext, afterHooks);\n\n\t\t\t\t\tif (after.response) {\n\t\t\t\t\t\tresult.response = after.response;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresult.response instanceof APIError &&\n\t\t\t\t\t\tshouldPublishLog(authContext.logger.level, \"debug\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\tresult.response.stack = result.response.errorStack;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result.response instanceof APIError && !context?.asResponse) {\n\t\t\t\t\t\tthrow result.response;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst response = context?.asResponse\n\t\t\t\t\t\t? toResponse(result.response, {\n\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\tstatus: result.status,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: context?.returnHeaders\n\t\t\t\t\t\t\t? context?.returnStatus\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\t\t\t\t\tstatus: result.status,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: context?.returnStatus\n\t\t\t\t\t\t\t\t? { response: result.response, status: result.status }\n\t\t\t\t\t\t\t\t: result.response;\n\t\t\t\t\treturn response;\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (await hasRequestState()) {\n\t\t\t\treturn run();\n\t\t\t} else {\n\t\t\t\tconst store = new WeakMap();\n\t\t\t\treturn runWithRequestState(store, run);\n\t\t\t}\n\t\t};\n\t\tapi[key].path = endpoint.path;\n\t\tapi[key].options = endpoint.options;\n\t}\n\treturn api as unknown as E;\n}\n\nasync function runBeforeHooks(\n\tcontext: InternalContext,\n\thooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[],\n) {\n\tlet modifiedContext: Partial<InternalContext> = {};\n\n\tfor (const hook of hooks) {\n\t\tlet matched = false;\n\t\ttry {\n\t\t\tmatched = hook.matcher(context);\n\t\t} catch (error) {\n\t\t\t// manually handle unexpected errors during hook matcher execution to prevent accidental exposure of internal details\n\t\t\t// Also provides debug information about which plugin the hook failed and error info\n\t\t\tconst hookSource = hooksSourceWeakMap.get(hook.handler) ?? \"unknown\";\n\t\t\tcontext.context.logger.error(\n\t\t\t\t`An error occurred during ${hookSource} hook matcher execution:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: `An error occurred during hook matcher execution. Check the logs for more details.`,\n\t\t\t});\n\t\t}\n\t\tif (matched) {\n\t\t\tconst result = await hook\n\t\t\t\t.handler({\n\t\t\t\t\t...context,\n\t\t\t\t\treturnHeaders: false,\n\t\t\t\t})\n\t\t\t\t.catch((e: unknown) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\te instanceof APIError &&\n\t\t\t\t\t\tshouldPublishLog(context.context.logger.level, \"debug\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\te.stack = e.errorStack;\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t\tif (result && typeof result === \"object\") {\n\t\t\t\tif (\"context\" in result && typeof result.context === \"object\") {\n\t\t\t\t\tconst { headers, ...rest } =\n\t\t\t\t\t\tresult.context as Partial<InternalContext>;\n\t\t\t\t\tif (headers instanceof Headers) {\n\t\t\t\t\t\tif (modifiedContext.headers) {\n\t\t\t\t\t\t\theaders.forEach((value, key) => {\n\t\t\t\t\t\t\t\tmodifiedContext.headers?.set(key, value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmodifiedContext.headers = headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodifiedContext = defuReplaceArrays(rest, modifiedContext);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn { context: modifiedContext };\n}\n\nasync function runAfterHooks(\n\tcontext: InternalContext,\n\thooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[],\n) {\n\tfor (const hook of hooks) {\n\t\tif (hook.matcher(context)) {\n\t\t\tconst result = (await hook.handler(context).catch((e) => {\n\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\tif (shouldPublishLog(context.context.logger.level, \"debug\")) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\te.stack = e.errorStack;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tresponse: e,\n\t\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t})) as {\n\t\t\t\tresponse: any;\n\t\t\t\theaders: Headers;\n\t\t\t};\n\t\t\tif (result.headers) {\n\t\t\t\tresult.headers.forEach((value, key) => {\n\t\t\t\t\tif (!context.context.responseHeaders) {\n\t\t\t\t\t\tcontext.context.responseHeaders = new Headers({\n\t\t\t\t\t\t\t[key]: value,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (key.toLowerCase() === \"set-cookie\") {\n\t\t\t\t\t\t\tcontext.context.responseHeaders.append(key, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.context.responseHeaders.set(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (result.response) {\n\t\t\t\tcontext.context.returned = result.response;\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tresponse: context.context.returned,\n\t\theaders: context.context.responseHeaders,\n\t};\n}\n\nfunction getHooks(authContext: AuthContext) {\n\tconst plugins = authContext.options.plugins || [];\n\tconst beforeHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[] = [];\n\tconst afterHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[] = [];\n\tconst beforeHookHandler = authContext.options.hooks?.before;\n\tif (beforeHookHandler) {\n\t\thooksSourceWeakMap.set(beforeHookHandler, \"user\");\n\t\tbeforeHooks.push({\n\t\t\tmatcher: () => true,\n\t\t\thandler: beforeHookHandler,\n\t\t});\n\t}\n\tconst afterHookHandler = authContext.options.hooks?.after;\n\tif (afterHookHandler) {\n\t\thooksSourceWeakMap.set(afterHookHandler, \"user\");\n\t\tafterHooks.push({\n\t\t\tmatcher: () => true,\n\t\t\thandler: afterHookHandler,\n\t\t});\n\t}\n\tconst pluginBeforeHooks = plugins\n\t\t.filter((plugin) => plugin.hooks?.before)\n\t\t.map((plugin) => plugin.hooks?.before!)\n\t\t.flat();\n\tconst pluginAfterHooks = plugins\n\t\t.filter((plugin) => plugin.hooks?.after)\n\t\t.map((plugin) => plugin.hooks?.after!)\n\t\t.flat();\n\n\t/**\n\t * Add plugin added hooks at last\n\t */\n\tif (pluginBeforeHooks.length) beforeHooks.push(...pluginBeforeHooks);\n\tif (pluginAfterHooks.length) afterHooks.push(...pluginAfterHooks);\n\n\treturn {\n\t\tbeforeHooks,\n\t\tafterHooks,\n\t};\n}\n","import type { HasRequiredKeys, Prettify } from \"./helper\";\nimport { toResponse } from \"./to-response\";\nimport type { Middleware } from \"./middleware\";\nimport {\n\tcreateInternalContext,\n\ttype InferBody,\n\ttype InferHeaders,\n\ttype InferMethod,\n\ttype InferParam,\n\ttype InferQuery,\n\ttype InferRequest,\n\ttype InferUse,\n\ttype InputContext,\n\ttype Method,\n} from \"./context\";\nimport type { CookieOptions, CookiePrefixOptions } from \"./cookies\";\nimport { APIError, ValidationError, type statusCodes, type Status, BetterCallError } from \"./error\";\nimport type { OpenAPIParameter, OpenAPISchemaType } from \"./openapi\";\nimport type { StandardSchemaV1 } from \"./standard-schema\";\nimport { isAPIError, tryCatch } from \"./utils\";\n\nexport interface EndpointBaseOptions {\n\t/**\n\t * Query Schema\n\t */\n\tquery?: StandardSchemaV1;\n\t/**\n\t * Error Schema\n\t */\n\terror?: StandardSchemaV1;\n\t/**\n\t * If true headers will be required to be passed in the context\n\t */\n\trequireHeaders?: boolean;\n\t/**\n\t * If true request object will be required\n\t */\n\trequireRequest?: boolean;\n\t/**\n\t * Clone the request object from the router\n\t */\n\tcloneRequest?: boolean;\n\t/**\n\t * If true the body will be undefined\n\t */\n\tdisableBody?: boolean;\n\t/**\n\t * Endpoint metadata\n\t */\n\tmetadata?: {\n\t\t/**\n\t\t * Open API definition\n\t\t */\n\t\topenapi?: {\n\t\t\tsummary?: string;\n\t\t\tdescription?: string;\n\t\t\ttags?: string[];\n\t\t\toperationId?: string;\n\t\t\tparameters?: OpenAPIParameter[];\n\t\t\trequestBody?: {\n\t\t\t\tcontent: {\n\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tresponses?: {\n\t\t\t\t[status: string]: {\n\t\t\t\t\tdescription: string;\n\t\t\t\t\tcontent?: {\n\t\t\t\t\t\t\"application/json\"?: {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\"text/plain\"?: {\n\t\t\t\t\t\t\tschema?: {\n\t\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\"text/html\"?: {\n\t\t\t\t\t\t\tschema?: {\n\t\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t/**\n\t\t * Infer body and query type from ts interface\n\t\t *\n\t\t * useful for generic and dynamic types\n\t\t *\n\t\t * @example\n\t\t * ```ts\n\t\t * const endpoint = createEndpoint(\"/path\", {\n\t\t * \t\tmethod: \"POST\",\n\t\t * \t\tbody: z.record(z.string()),\n\t\t * \t\t$Infer: {\n\t\t * \t\t\tbody: {} as {\n\t\t * \t\t\t\ttype: InferTypeFromOptions<Option> // custom type inference\n\t\t * \t\t\t}\n\t\t * \t\t}\n\t\t * \t}, async(ctx)=>{\n\t\t * \t\tconst body = ctx.body\n\t\t * \t})\n\t\t * ```\n\t\t */\n\t\t$Infer?: {\n\t\t\t/**\n\t\t\t * Body\n\t\t\t */\n\t\t\tbody?: any;\n\t\t\t/**\n\t\t\t * Query\n\t\t\t */\n\t\t\tquery?: Record<string, any>;\n\t\t};\n\t\t/**\n\t\t * If enabled, endpoint won't be exposed over a router\n\t\t * @deprecated Use path-less endpoints instead\n\t\t */\n\t\tSERVER_ONLY?: boolean;\n\t\t/**\n\t\t * If enabled, endpoint won't be exposed as an action to the client\n\t\t * @deprecated Use path-less endpoints instead\n\t\t */\n\t\tisAction?: boolean;\n\t\t/**\n\t\t * Defines the places where the endpoint will be available\n\t\t *\n\t\t * Possible options:\n\t\t * - `rpc` - the endpoint is exposed to the router, can be invoked directly and is available to the client\n\t\t * - `server` - the endpoint is exposed to the router, can be invoked directly, but is not available to the client\n\t\t * - `http` - the endpoint is only exposed to the router\n\t\t * @default \"rpc\"\n\t\t */\n\t\tscope?: \"rpc\" | \"server\" | \"http\";\n\t\t/**\n\t\t * List of allowed media types (MIME types) for the endpoint\n\t\t *\n\t\t * if provided, only the media types in the list will be allowed to be passed in the body\n\t\t *\n\t\t * @example\n\t\t * ```ts\n\t\t * const endpoint = createEndpoint(\"/path\", {\n\t\t * \t\tmethod: \"POST\",\n\t\t * \t\tallowedMediaTypes: [\"application/json\", \"application/x-www-form-urlencoded\"],\n\t\t * \t}, async(ctx)=>{\n\t\t * \t\tconst body = ctx.body\n\t\t * \t})\n\t\t * ```\n\t\t */\n\t\tallowedMediaTypes?: string[];\n\t\t/**\n\t\t * Extra metadata\n\t\t */\n\t\t[key: string]: any;\n\t};\n\t/**\n\t * List of middlewares to use\n\t */\n\tuse?: Middleware[];\n\t/**\n\t * A callback to run before any API error is throw or returned\n\t *\n\t * @param e - The API error\n\t * @returns - The response to return\n\t */\n\tonAPIError?: (e: APIError) => void | Promise<void>;\n\t/**\n\t * A callback to run before a validation error is thrown\n\t * You can customize the validation error message by throwing your own APIError\n\t */\n\tonValidationError?: ({\n\t\tissues,\n\t\tmessage,\n\t}: { message: string; issues: readonly StandardSchemaV1.Issue[] }) => void | Promise<void>;\n}\n\nexport type EndpointBodyMethodOptions =\n\t| {\n\t\t\t/**\n\t\t\t * Request Method\n\t\t\t */\n\t\t\tmethod: \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | (\"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\")[];\n\t\t\t/**\n\t\t\t * Body Schema\n\t\t\t */\n\t\t\tbody?: StandardSchemaV1;\n\t  }\n\t| {\n\t\t\t/**\n\t\t\t * Request Method\n\t\t\t */\n\t\t\tmethod: \"GET\" | \"HEAD\" | (\"GET\" | \"HEAD\")[];\n\t\t\t/**\n\t\t\t * Body Schema\n\t\t\t */\n\t\t\tbody?: never;\n\t  }\n\t| {\n\t\t\t/**\n\t\t\t * Request Method\n\t\t\t */\n\t\t\tmethod: \"*\";\n\t\t\t/**\n\t\t\t * Body Schema\n\t\t\t */\n\t\t\tbody?: StandardSchemaV1;\n\t  }\n\t| {\n\t\t\t/**\n\t\t\t * Request Method\n\t\t\t */\n\t\t\tmethod: (\"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | \"GET\" | \"HEAD\")[];\n\t\t\t/**\n\t\t\t * Body Schema\n\t\t\t */\n\t\t\tbody?: StandardSchemaV1;\n\t  };\n\nexport type EndpointOptions = EndpointBaseOptions & EndpointBodyMethodOptions;\n\nexport type EndpointContext<Path extends string, Options extends EndpointOptions, Context = {}> = {\n\t/**\n\t * Method\n\t *\n\t * The request method\n\t */\n\tmethod: InferMethod<Options>;\n\t/**\n\t * Path\n\t *\n\t * The path of the endpoint\n\t */\n\tpath: Path;\n\t/**\n\t * Body\n\t *\n\t * The body object will be the parsed JSON from the request and validated\n\t * against the body schema if it exists.\n\t */\n\tbody: InferBody<Options>;\n\t/**\n\t * Query\n\t *\n\t * The query object will be the parsed query string from the request\n\t * and validated against the query schema if it exists\n\t */\n\tquery: InferQuery<Options>;\n\t/**\n\t * Params\n\t *\n\t * If the path is `/user/:id` and the request is `/user/1` then the params will\n\t * be `{ id: \"1\" }` and if the path includes a wildcard like `/user/*` then the\n\t * params will be `{ _: \"1\" }` where `_` is the wildcard key. If the wildcard\n\t * is named like `/user/**:name` then the params will be `{ name: string }`\n\t */\n\tparams: InferParam<Path>;\n\t/**\n\t * Request object\n\t *\n\t * If `requireRequest` is set to true in the endpoint options this will be\n\t * required\n\t */\n\trequest: InferRequest<Options>;\n\t/**\n\t * Headers\n\t *\n\t * If `requireHeaders` is set to true in the endpoint options this will be\n\t * required\n\t */\n\theaders: InferHeaders<Options>;\n\t/**\n\t * Set header\n\t *\n\t * If it's called outside of a request it will just be ignored.\n\t */\n\tsetHeader: (key: string, value: string) => void;\n\t/**\n\t * Set the response status code\n\t */\n\tsetStatus: (status: Status) => void;\n\t/**\n\t * Get header\n\t *\n\t * If it's called outside of a request it will just return null\n\t *\n\t * @param key  - The key of the header\n\t * @returns\n\t */\n\tgetHeader: (key: string) => string | null;\n\t/**\n\t * Get a cookie value from the request\n\t *\n\t * @param key - The key of the cookie\n\t * @param prefix - The prefix of the cookie between `__Secure-` and `__Host-`\n\t * @returns - The value of the cookie\n\t */\n\tgetCookie: (key: string, prefix?: CookiePrefixOptions) => string | null;\n\t/**\n\t * Get a signed cookie value from the request\n\t *\n\t * @param key - The key of the cookie\n\t * @param secret - The secret of the signed cookie\n\t * @param prefix - The prefix of the cookie between `__Secure-` and `__Host-`\n\t * @returns - The value of the cookie or null if the cookie is not found or false if the signature is invalid\n\t */\n\tgetSignedCookie: (\n\t\tkey: string,\n\t\tsecret: string,\n\t\tprefix?: CookiePrefixOptions,\n\t) => Promise<string | null | false>;\n\t/**\n\t * Set a cookie value in the response\n\t *\n\t * @param key - The key of the cookie\n\t * @param value - The value to set\n\t * @param options - The options of the cookie\n\t * @returns - The cookie string\n\t */\n\tsetCookie: (key: string, value: string, options?: CookieOptions) => string;\n\t/**\n\t * Set signed cookie\n\t *\n\t * @param key - The key of the cookie\n\t * @param value  - The value to set\n\t * @param secret - The secret to sign the cookie with\n\t * @param options - The options of the cookie\n\t * @returns - The cookie string\n\t */\n\tsetSignedCookie: (\n\t\tkey: string,\n\t\tvalue: string,\n\t\tsecret: string,\n\t\toptions?: CookieOptions,\n\t) => Promise<string>;\n\t/**\n\t * JSON\n\t *\n\t * a helper function to create a JSON response with\n\t * the correct headers\n\t * and status code. If `asResponse` is set to true in\n\t * the context then\n\t * it will return a Response object instead of the\n\t * JSON object.\n\t *\n\t * @param json - The JSON object to return\n\t * @param routerResponse - The response object to\n\t * return if `asResponse` is\n\t * true in the context this will take precedence\n\t */\n\tjson: <R extends Record<string, any> | null>(\n\t\tjson: R,\n\t\trouterResponse?:\n\t\t\t| {\n\t\t\t\t\tstatus?: number;\n\t\t\t\t\theaders?: Record<string, string>;\n\t\t\t\t\tresponse?: Response;\n\t\t\t\t\tbody?: Record<string, string>;\n\t\t\t  }\n\t\t\t| Response,\n\t) => Promise<R>;\n\t/**\n\t * Middleware context\n\t */\n\tcontext: Prettify<Context & InferUse<Options[\"use\"]>>;\n\t/**\n\t * Redirect to a new URL\n\t */\n\tredirect: (url: string) => APIError;\n\t/**\n\t * Return error\n\t */\n\terror: (\n\t\tstatus: keyof typeof statusCodes | Status,\n\t\tbody?: {\n\t\t\tmessage?: string;\n\t\t\tcode?: string;\n\t\t} & Record<string, any>,\n\t\theaders?: HeadersInit,\n\t) => APIError;\n};\n\ntype EndpointHandler<Path extends string, Options extends EndpointOptions, R> = (\n\tcontext: EndpointContext<Path, Options>,\n) => Promise<R>;\n\nexport function createEndpoint<Path extends string, Options extends EndpointOptions, R>(\n\tpath: Path,\n\toptions: Options,\n\thandler: EndpointHandler<Path, Options, R>,\n): StrictEndpoint<Path, Options, R>;\n\nexport function createEndpoint<Options extends EndpointOptions, R>(\n\toptions: Options,\n\thandler: EndpointHandler<never, Options, R>,\n): StrictEndpoint<never, Options, R>;\n\nexport function createEndpoint<Path extends string, Options extends EndpointOptions, R>(\n\tpathOrOptions: Path | Options,\n\thandlerOrOptions: EndpointHandler<Path, Options, R> | Options,\n\thandlerOrNever?: any,\n): StrictEndpoint<Path, Options, R> {\n\tconst path: string | undefined = typeof pathOrOptions === \"string\" ? pathOrOptions : undefined;\n\tconst options: Options =\n\t\ttypeof handlerOrOptions === \"object\" ? handlerOrOptions : (pathOrOptions as Options);\n\tconst handler: EndpointHandler<Path, Options, R> =\n\t\ttypeof handlerOrOptions === \"function\" ? handlerOrOptions : handlerOrNever;\n\n\tif ((options.method === \"GET\" || options.method === \"HEAD\") && options.body) {\n\t\tthrow new BetterCallError(\"Body is not allowed with GET or HEAD methods\");\n\t}\n\n\tif (path && /\\/{2,}/.test(path)) {\n\t\tthrow new BetterCallError(\"Path cannot contain consecutive slashes\");\n\t}\n\ttype Context = InputContext<Path, Options>;\n\n\ttype ResultType<\n\t\tAsResponse extends boolean,\n\t\tReturnHeaders extends boolean,\n\t\tReturnStatus extends boolean,\n\t> = AsResponse extends true\n\t\t? Response\n\t\t: ReturnHeaders extends true\n\t\t\t? ReturnStatus extends true\n\t\t\t\t? {\n\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\tstatus: number;\n\t\t\t\t\t\tresponse: Awaited<R>;\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\tresponse: Awaited<R>;\n\t\t\t\t\t}\n\t\t\t: ReturnStatus extends true\n\t\t\t\t? {\n\t\t\t\t\t\tstatus: number;\n\t\t\t\t\t\tresponse: Awaited<R>;\n\t\t\t\t\t}\n\t\t\t\t: Awaited<R>;\n\n\tconst internalHandler = async <\n\t\tAsResponse extends boolean = false,\n\t\tReturnHeaders extends boolean = false,\n\t\tReturnStatus extends boolean = false,\n\t>(\n\t\t...inputCtx: HasRequiredKeys<Context> extends true\n\t\t\t? [\n\t\t\t\t\tContext & {\n\t\t\t\t\t\tasResponse?: AsResponse;\n\t\t\t\t\t\treturnHeaders?: ReturnHeaders;\n\t\t\t\t\t\treturnStatus?: ReturnStatus;\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\t: [\n\t\t\t\t\t(Context & {\n\t\t\t\t\t\tasResponse?: AsResponse;\n\t\t\t\t\t\treturnHeaders?: ReturnHeaders;\n\t\t\t\t\t\treturnStatus?: ReturnStatus;\n\t\t\t\t\t})?,\n\t\t\t\t]\n\t): Promise<ResultType<AsResponse, ReturnHeaders, ReturnStatus>> => {\n\t\tconst context = (inputCtx[0] || {}) as InputContext<any, any>;\n\t\tconst { data: internalContext, error: validationError } = await tryCatch(\n\t\t\tcreateInternalContext(context, {\n\t\t\t\toptions,\n\t\t\t\tpath,\n\t\t\t}),\n\t\t);\n\n\t\tif (validationError) {\n\t\t\t// If it's not a validation error, we throw it\n\t\t\tif (!(validationError instanceof ValidationError)) throw validationError;\n\n\t\t\t// Check if the endpoint has a custom onValidationError callback\n\t\t\tif (options.onValidationError) {\n\t\t\t\t// This can possibly throw an APIError in order to customize the validation error message\n\t\t\t\tawait options.onValidationError({\n\t\t\t\t\tmessage: validationError.message,\n\t\t\t\t\tissues: validationError.issues,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow new APIError(400, {\n\t\t\t\tmessage: validationError.message,\n\t\t\t\tcode: \"VALIDATION_ERROR\",\n\t\t\t});\n\t\t}\n\t\tconst response = await handler(internalContext as any).catch(async (e) => {\n\t\t\tif (isAPIError(e)) {\n\t\t\t\tconst onAPIError = options.onAPIError;\n\t\t\t\tif (onAPIError) {\n\t\t\t\t\tawait onAPIError(e);\n\t\t\t\t}\n\t\t\t\tif (context.asResponse) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow e;\n\t\t});\n\t\tconst headers = internalContext.responseHeaders;\n\t\tconst status = internalContext.responseStatus;\n\n\t\treturn (\n\t\t\tcontext.asResponse\n\t\t\t\t? toResponse(response, {\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tstatus,\n\t\t\t\t\t})\n\t\t\t\t: context.returnHeaders\n\t\t\t\t\t? context.returnStatus\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\theaders,\n\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\theaders,\n\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t: context.returnStatus\n\t\t\t\t\t\t? { response, status }\n\t\t\t\t\t\t: response\n\t\t) as ResultType<AsResponse, ReturnHeaders, ReturnStatus>;\n\t};\n\tinternalHandler.options = options;\n\tinternalHandler.path = path;\n\treturn internalHandler as unknown as StrictEndpoint<Path, Options, R>;\n}\n\ncreateEndpoint.create = <E extends { use?: Middleware[] }>(opts?: E) => {\n\treturn <Path extends string, Opts extends EndpointOptions, R extends Promise<any>>(\n\t\tpath: Path,\n\t\toptions: Opts,\n\t\thandler: (ctx: EndpointContext<Path, Opts, InferUse<E[\"use\"]>>) => R,\n\t) => {\n\t\treturn createEndpoint(\n\t\t\tpath,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tuse: [...(options?.use || []), ...(opts?.use || [])],\n\t\t\t},\n\t\t\thandler,\n\t\t);\n\t};\n};\n\nexport type StrictEndpoint<Path extends string, Options extends EndpointOptions, R = any> = {\n\t// asResponse cases\n\t(context: InputContext<Path, Options> & { asResponse: true }): Promise<Response>;\n\n\t// returnHeaders & returnStatus cases\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnHeaders: true; returnStatus: true },\n\t): Promise<{ headers: Headers; status: number; response: Awaited<R> }>;\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnHeaders: true; returnStatus: false },\n\t): Promise<{ headers: Headers; response: Awaited<R> }>;\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnHeaders: false; returnStatus: true },\n\t): Promise<{ status: number; response: Awaited<R> }>;\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnHeaders: false; returnStatus: false },\n\t): Promise<R>;\n\n\t// individual flag cases\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnHeaders: true },\n\t): Promise<{ headers: Headers; response: Awaited<R> }>;\n\t(\n\t\tcontext: InputContext<Path, Options> & { returnStatus: true },\n\t): Promise<{ status: number; response: Awaited<R> }>;\n\n\t// default case\n\t(context?: InputContext<Path, Options>): Promise<R>;\n\n\toptions: Options;\n\tpath: Path;\n};\n\nexport type Endpoint<\n\tPath extends string = string,\n\tOptions extends EndpointOptions = EndpointOptions,\n\tHandler extends (inputCtx: any) => Promise<any> = (inputCtx: any) => Promise<any>,\n> = Handler & {\n\toptions: Options;\n\tpath: Path;\n};\n","import { signCookieValue } from \"./crypto\";\nimport { tryDecode } from \"./utils\";\n\nexport type CookiePrefixOptions = \"host\" | \"secure\";\n\nexport type CookieOptions = {\n\t/**\n\t * Domain of the cookie\n\t *\n\t * The Domain attribute specifies which server can receive a cookie. If specified, cookies are\n\t * available on the specified server and its subdomains. If the it is not\n\t * specified, the cookies are available on the server that sets it but not on\n\t * its subdomains.\n\t *\n\t * @example\n\t * `domain: \"example.com\"`\n\t */\n\tdomain?: string;\n\t/**\n\t * A lifetime of a cookie. Permanent cookies are deleted after the date specified in the\n\t * Expires attribute:\n\t *\n\t * Expires has been available for longer than Max-Age, however Max-Age is less error-prone, and\n\t * takes precedence when both are set. The rationale behind this is that when you set an\n\t * Expires date and time, they're relative to the client the cookie is being set on. If the\n\t * server is set to a different time, this could cause errors\n\t */\n\texpires?: Date;\n\t/**\n\t * Forbids JavaScript from accessing the cookie, for example, through the Document.cookie\n\t * property. Note that a cookie that has been created with HttpOnly will still be sent with\n\t * JavaScript-initiated requests, for example, when calling XMLHttpRequest.send() or fetch().\n\t * This mitigates attacks against cross-site scripting\n\t */\n\thttpOnly?: boolean;\n\t/**\n\t * Indicates the number of seconds until the cookie expires. A zero or negative number will\n\t * expire the cookie immediately. If both Expires and Max-Age are set, Max-Age has precedence.\n\t *\n\t * @example 604800 - 7 days\n\t */\n\tmaxAge?: number;\n\t/**\n\t * Indicates the path that must exist in the requested URL for the browser to send the Cookie\n\t * header.\n\t *\n\t * @example\n\t * \"/docs\"\n\t * // -> the request paths /docs, /docs/, /docs/Web/, and /docs/Web/HTTP will all match. the request paths /, /fr/docs will not match.\n\t */\n\tpath?: string;\n\t/**\n\t * Indicates that the cookie is sent to the server only when a request is made with the https:\n\t * scheme (except on localhost), and therefore, is more resistant to man-in-the-middle attacks.\n\t */\n\tsecure?: boolean;\n\t/**\n\t * Controls whether or not a cookie is sent with cross-site requests, providing some protection\n\t * against cross-site request forgery attacks (CSRF).\n\t *\n\t * Strict -  Means that the browser sends the cookie only for same-site requests, that is,\n\t * requests originating from the same site that set the cookie. If a request originates from a\n\t * different domain or scheme (even with the same domain), no cookies with the SameSite=Strict\n\t * attribute are sent.\n\t *\n\t * Lax - Means that the cookie is not sent on cross-site requests, such as on requests to load\n\t * images or frames, but is sent when a user is navigating to the origin site from an external\n\t * site (for example, when following a link). This is the default behavior if the SameSite\n\t * attribute is not specified.\n\t *\n\t * None - Means that the browser sends the cookie with both cross-site and same-site requests.\n\t * The Secure attribute must also be set when setting this value.\n\t */\n\tsameSite?: \"Strict\" | \"Lax\" | \"None\" | \"strict\" | \"lax\" | \"none\";\n\t/**\n\t * Indicates that the cookie should be stored using partitioned storage. Note that if this is\n\t * set, the Secure directive must also be set.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/Privacy/Privacy_sandbox/Partitioned_cookies\n\t */\n\tpartitioned?: boolean;\n\t/**\n\t * Cooke Prefix\n\t *\n\t * - secure: `__Secure-` -> `__Secure-cookie-name`\n\t * - host: `__Host-` -> `__Host-cookie-name`\n\t *\n\t * `secure` must be set to true to use prefixes\n\t */\n\tprefix?: CookiePrefixOptions;\n};\n\nexport const getCookieKey = (key: string, prefix?: CookiePrefixOptions) => {\n\tlet finalKey = key;\n\tif (prefix) {\n\t\tif (prefix === \"secure\") {\n\t\t\tfinalKey = \"__Secure-\" + key;\n\t\t} else if (prefix === \"host\") {\n\t\t\tfinalKey = \"__Host-\" + key;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\treturn finalKey;\n};\n\n/**\n * Parse an HTTP Cookie header string and returning an object of all cookie\n * name-value pairs.\n *\n * Inspired by https://github.com/unjs/cookie-es/blob/main/src/cookie/parse.ts\n *\n * @param str the string representing a `Cookie` header value\n */\nexport function parseCookies(str: string) {\n\tif (typeof str !== \"string\") {\n\t\tthrow new TypeError(\"argument str must be a string\");\n\t}\n\n\tconst cookies: Map<string, string> = new Map();\n\n\tlet index = 0;\n\twhile (index < str.length) {\n\t\tconst eqIdx = str.indexOf(\"=\", index);\n\n\t\tif (eqIdx === -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlet endIdx = str.indexOf(\";\", index);\n\n\t\tif (endIdx === -1) {\n\t\t\tendIdx = str.length;\n\t\t} else if (endIdx < eqIdx) {\n\t\t\tindex = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst key = str.slice(index, eqIdx).trim();\n\t\tif (!cookies.has(key)) {\n\t\t\tlet val = str.slice(eqIdx + 1, endIdx).trim();\n\t\t\tif (val.codePointAt(0) === 0x22) {\n\t\t\t\tval = val.slice(1, -1);\n\t\t\t}\n\t\t\tcookies.set(key, tryDecode(val));\n\t\t}\n\n\t\tindex = endIdx + 1;\n\t}\n\n\treturn cookies;\n}\n\nconst _serialize = (key: string, value: string, opt: CookieOptions = {}) => {\n\tlet cookie: string;\n\n\tif (opt?.prefix === \"secure\") {\n\t\tcookie = `${`__Secure-${key}`}=${value}`;\n\t} else if (opt?.prefix === \"host\") {\n\t\tcookie = `${`__Host-${key}`}=${value}`;\n\t} else {\n\t\tcookie = `${key}=${value}`;\n\t}\n\n\tif (key.startsWith(\"__Secure-\") && !opt.secure) {\n\t\topt.secure = true;\n\t}\n\n\tif (key.startsWith(\"__Host-\")) {\n\t\tif (!opt.secure) {\n\t\t\topt.secure = true;\n\t\t}\n\n\t\tif (opt.path !== \"/\") {\n\t\t\topt.path = \"/\";\n\t\t}\n\n\t\tif (opt.domain) {\n\t\t\topt.domain = undefined;\n\t\t}\n\t}\n\n\tif (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n\t\tif (opt.maxAge > 34560000) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\",\n\t\t\t);\n\t\t}\n\t\tcookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n\t}\n\n\tif (opt.domain && opt.prefix !== \"host\") {\n\t\tcookie += `; Domain=${opt.domain}`;\n\t}\n\n\tif (opt.path) {\n\t\tcookie += `; Path=${opt.path}`;\n\t}\n\n\tif (opt.expires) {\n\t\tif (opt.expires.getTime() - Date.now() > 34560000_000) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\",\n\t\t\t);\n\t\t}\n\t\tcookie += `; Expires=${opt.expires.toUTCString()}`;\n\t}\n\n\tif (opt.httpOnly) {\n\t\tcookie += \"; HttpOnly\";\n\t}\n\n\tif (opt.secure) {\n\t\tcookie += \"; Secure\";\n\t}\n\n\tif (opt.sameSite) {\n\t\tcookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n\t}\n\n\tif (opt.partitioned) {\n\t\tif (!opt.secure) {\n\t\t\topt.secure = true;\n\t\t}\n\t\tcookie += \"; Partitioned\";\n\t}\n\n\treturn cookie;\n};\n\nexport const serializeCookie = (key: string, value: string, opt?: CookieOptions) => {\n\tvalue = encodeURIComponent(value);\n\treturn _serialize(key, value, opt);\n};\n\nexport const serializeSignedCookie = async (\n\tkey: string,\n\tvalue: string,\n\tsecret: string,\n\topt?: CookieOptions,\n) => {\n\tvalue = await signCookieValue(value, secret);\n\treturn _serialize(key, value, opt);\n};\n","//https://github.com/axtgr/wildcard-match\n\n/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char: string) {\n\tif (\n\t\tchar === \"-\" ||\n\t\tchar === \"^\" ||\n\t\tchar === \"$\" ||\n\t\tchar === \"+\" ||\n\t\tchar === \".\" ||\n\t\tchar === \"(\" ||\n\t\tchar === \")\" ||\n\t\tchar === \"|\" ||\n\t\tchar === \"[\" ||\n\t\tchar === \"]\" ||\n\t\tchar === \"{\" ||\n\t\tchar === \"}\" ||\n\t\tchar === \"*\" ||\n\t\tchar === \"?\" ||\n\t\tchar === \"\\\\\"\n\t) {\n\t\treturn `\\\\${char}`;\n\t} else {\n\t\treturn char;\n\t}\n}\n\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str: string) {\n\tlet result = \"\";\n\tfor (let i = 0; i < str.length; i++) {\n\t\tresult += escapeRegExpChar(str[i]!);\n\t}\n\treturn result;\n}\n\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(\n\tpattern: string | string[],\n\tseparator: string | boolean = true,\n): string {\n\tif (Array.isArray(pattern)) {\n\t\tconst regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`);\n\t\treturn `(?:${regExpPatterns.join(\"|\")})`;\n\t}\n\n\tlet separatorSplitter = \"\";\n\tlet separatorMatcher = \"\";\n\tlet wildcard = \".\";\n\n\tif (separator === true) {\n\t\t// In this case forward slashes in patterns match both forward and backslashes in samples:\n\t\t//\n\t\t// `foo/bar` will match `foo/bar`\n\t\t//           will match `foo\\bar`\n\t\t//\n\t\tseparatorSplitter = \"/\";\n\t\tseparatorMatcher = \"[/\\\\\\\\]\";\n\t\twildcard = \"[^/\\\\\\\\]\";\n\t} else if (separator) {\n\t\tseparatorSplitter = separator;\n\t\tseparatorMatcher = escapeRegExpString(separatorSplitter);\n\n\t\tif (separatorMatcher.length > 1) {\n\t\t\tseparatorMatcher = `(?:${separatorMatcher})`;\n\t\t\twildcard = `((?!${separatorMatcher}).)`;\n\t\t} else {\n\t\t\twildcard = `[^${separatorMatcher}]`;\n\t\t}\n\t}\n\n\t// When a separator is explicitly specified in a pattern,\n\t// it MUST match ONE OR MORE separators in a sample:\n\t//\n\t// `foo/bar/` will match  `foo//bar///`\n\t//            won't match `foo/bar`\n\t//\n\t// When a pattern doesn't have a trailing separator,\n\t// a sample can still optionally have them:\n\t//\n\t// `foo/bar` will match `foo/bar//`\n\t//\n\t// So we use different quantifiers depending on the index of a segment.\n\tconst requiredSeparator = separator ? `${separatorMatcher}+?` : \"\";\n\tconst optionalSeparator = separator ? `${separatorMatcher}*?` : \"\";\n\n\tconst segments = separator ? pattern.split(separatorSplitter) : [pattern];\n\tlet result = \"\";\n\n\tfor (let s = 0; s < segments.length; s++) {\n\t\tconst segment = segments[s]!;\n\t\tconst nextSegment = segments[s + 1]!;\n\t\tlet currentSeparator = \"\";\n\n\t\tif (!segment && s > 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (separator) {\n\t\t\tif (s === segments.length - 1) {\n\t\t\t\tcurrentSeparator = optionalSeparator;\n\t\t\t} else if (nextSegment !== \"**\") {\n\t\t\t\tcurrentSeparator = requiredSeparator;\n\t\t\t} else {\n\t\t\t\tcurrentSeparator = \"\";\n\t\t\t}\n\t\t}\n\n\t\tif (separator && segment === \"**\") {\n\t\t\tif (currentSeparator) {\n\t\t\t\tresult += s === 0 ? \"\" : currentSeparator;\n\t\t\t\tresult += `(?:${wildcard}*?${currentSeparator})*?`;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (let c = 0; c < segment.length; c++) {\n\t\t\tconst char = segment[c]!;\n\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tif (c < segment.length - 1) {\n\t\t\t\t\tresult += escapeRegExpChar(segment[c + 1]!);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t} else if (char === \"?\") {\n\t\t\t\tresult += wildcard;\n\t\t\t} else if (char === \"*\") {\n\t\t\t\tresult += `${wildcard}*?`;\n\t\t\t} else {\n\t\t\t\tresult += escapeRegExpChar(char);\n\t\t\t}\n\t\t}\n\n\t\tresult += currentSeparator;\n\t}\n\n\treturn result;\n}\n\ninterface WildcardMatchOptions {\n\t/** Separator to be used to split patterns and samples into segments */\n\tseparator?: string | boolean;\n\n\t/** Flags to pass to the RegExp */\n\tflags?: string;\n}\n\n// This overrides the function's signature because for the end user\n// the function is always bound to a RegExp\ninterface isMatch {\n\t/**\n\t * Tests if a sample string matches the pattern(s)\n\t *\n\t * ```js\n\t * isMatch('foo') //=> true\n\t * ```\n\t */\n\t(sample: string): boolean;\n\n\t/** Compiled regular expression */\n\tregexp: RegExp;\n\n\t/** Original pattern or array of patterns that was used to compile the RegExp */\n\tpattern: string | string[];\n\n\t/** Options that were used to compile the RegExp */\n\toptions: WildcardMatchOptions;\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n\tif (typeof sample !== \"string\") {\n\t\tthrow new TypeError(`Sample must be a string, but ${typeof sample} given`);\n\t}\n\n\treturn regexp.test(sample);\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n\tpattern: string | string[],\n\toptions?: string | boolean | WildcardMatchOptions,\n) {\n\tif (typeof pattern !== \"string\" && !Array.isArray(pattern)) {\n\t\tthrow new TypeError(\n\t\t\t`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`,\n\t\t);\n\t}\n\n\tif (typeof options === \"string\" || typeof options === \"boolean\") {\n\t\toptions = { separator: options };\n\t}\n\n\tif (\n\t\targuments.length === 2 &&\n\t\t!(\n\t\t\ttypeof options === \"undefined\" ||\n\t\t\t(typeof options === \"object\" &&\n\t\t\t\toptions !== null &&\n\t\t\t\t!Array.isArray(options))\n\t\t)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`,\n\t\t);\n\t}\n\n\toptions = options || {};\n\n\tif (options.separator === \"\\\\\") {\n\t\tthrow new Error(\n\t\t\t\"\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead\",\n\t\t);\n\t}\n\n\tconst regexpPattern = transform(pattern, options.separator);\n\tconst regexp = new RegExp(`^${regexpPattern}$`, options.flags);\n\n\tconst fn = isMatch.bind(null, regexp) as isMatch;\n\tfn.options = options;\n\tfn.pattern = pattern;\n\tfn.regexp = regexp;\n\treturn fn;\n}\n\nexport { wildcardMatch };\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { isProduction } from \"@better-auth/core/env\";\nimport { HIDE_METADATA } from \"../../utils/hide-metadata\";\n\nfunction sanitize(input: string): string {\n\t// Replace & last to avoid double-encoding existing HTML entities\n\t// Match & only when it's not already part of an HTML entity\n\treturn input\n\t\t.replace(/</g, \"&lt;\")\n\t\t.replace(/>/g, \"&gt;\")\n\t\t.replace(/\"/g, \"&quot;\")\n\t\t.replace(/'/g, \"&#39;\")\n\t\t.replace(/&(?!amp;|lt;|gt;|quot;|#39;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, \"&amp;\");\n}\n\nconst html = (\n\toptions: BetterAuthOptions,\n\tcode: string = \"Unknown\",\n\tdescription: string | null = null,\n) => {\n\tconst custom = options.onAPIError?.customizeDefaultErrorPage;\n\treturn `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Error</title>\n    <style>\n      * {\n        box-sizing: border-box;\n      }\n      body {\n        font-family: ${custom?.font?.defaultFamily || \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif\"};\n        background: ${custom?.colors?.background || \"var(--background)\"};\n        color: var(--foreground);\n        margin: 0;\n      }\n      :root,\n      :host {\n        --spacing: 0.25rem;\n        --container-md: 28rem;\n        --text-sm: ${custom?.size?.textSm || \"0.875rem\"};\n        --text-sm--line-height: calc(1.25 / 0.875);\n        --text-2xl: ${custom?.size?.text2xl || \"1.5rem\"};\n        --text-2xl--line-height: calc(2 / 1.5);\n        --text-4xl: ${custom?.size?.text4xl || \"2.25rem\"};\n        --text-4xl--line-height: calc(2.5 / 2.25);\n        --text-6xl: ${custom?.size?.text6xl || \"3rem\"};\n        --text-6xl--line-height: 1;\n        --font-weight-medium: 500;\n        --font-weight-semibold: 600;\n        --font-weight-bold: 700;\n        --default-transition-duration: 150ms;\n        --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n        --radius: ${custom?.size?.radiusSm || \"0.625rem\"};\n        --default-mono-font-family: ${custom?.font?.monoFamily || \"var(--font-geist-mono)\"};\n        --primary: ${custom?.colors?.primary || \"black\"};\n        --primary-foreground: ${custom?.colors?.primaryForeground || \"white\"};\n        --background: ${custom?.colors?.background || \"white\"};\n        --foreground: ${custom?.colors?.foreground || \"oklch(0.271 0 0)\"};\n        --border: ${custom?.colors?.border || \"oklch(0.89 0 0)\"};\n        --destructive: ${custom?.colors?.destructive || \"oklch(0.55 0.15 25.723)\"};\n        --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.545 0 0)\"};\n        --corner-border: ${custom?.colors?.cornerBorder || \"#404040\"};\n      }\n\n      button, .btn {\n        cursor: pointer;\n        background: none;\n        border: none;\n        color: inherit;\n        font: inherit;\n        transition: all var(--default-transition-duration)\n          var(--default-transition-timing-function);\n      }\n      button:hover, .btn:hover {\n        opacity: 0.8;\n      }\n\n      @media (prefers-color-scheme: dark) {\n        :root,\n        :host {\n          --primary: ${custom?.colors?.primary || \"white\"};\n          --primary-foreground: ${custom?.colors?.primaryForeground || \"black\"};\n          --background: ${custom?.colors?.background || \"oklch(0.15 0 0)\"};\n          --foreground: ${custom?.colors?.foreground || \"oklch(0.98 0 0)\"};\n          --border: ${custom?.colors?.border || \"oklch(0.27 0 0)\"};\n          --destructive: ${custom?.colors?.destructive || \"oklch(0.65 0.15 25.723)\"};\n          --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.65 0 0)\"};\n          --corner-border: ${custom?.colors?.cornerBorder || \"#a0a0a0\"};\n        }\n      }\n      @media (max-width: 640px) {\n        :root, :host {\n          --text-6xl: 2.5rem;\n          --text-2xl: 1.25rem;\n          --text-sm: 0.8125rem;\n        }\n      }\n      @media (max-width: 480px) {\n        :root, :host {\n          --text-6xl: 2rem;\n          --text-2xl: 1.125rem;\n        }\n      }\n    </style>\n  </head>\n  <body style=\"width: 100vw; min-height: 100vh; overflow-x: hidden; overflow-y: auto;\">\n    <div\n        style=\"\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            gap: 1.5rem;\n            position: relative;\n            width: 100%;\n            min-height: 100vh;\n            padding: 1rem;\n        \"\n        >\n${\n\tcustom?.disableBackgroundGrid\n\t\t? \"\"\n\t\t: `\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          background-image: linear-gradient(to right, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px),\n            linear-gradient(to bottom, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px);\n          background-size: 40px 40px;\n          opacity: 0.6;\n          pointer-events: none;\n          width: 100vw;\n          height: 100vh;\n        \"\n      ></div>\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          background: ${custom?.colors?.background || \"var(--background)\"};\n          mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          -webkit-mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          pointer-events: none;\n        \"\n      ></div>\n`\n}\n\n<div\n  style=\"\n    position: relative;\n    z-index: 10;\n    border: 2px solid var(--border);\n    background: ${custom?.colors?.cardBackground || \"var(--background)\"};\n    padding: 1.5rem;\n    max-width: 42rem;\n    width: 100%;\n  \"\n>\n    ${\n\t\t\tcustom?.disableCornerDecorations\n\t\t\t\t? \"\"\n\t\t\t\t: `\n        <!-- Corner decorations -->\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>\n  \n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>`\n\t\t}\n\n        <div style=\"text-align: center; margin-bottom: 1.5rem;\">\n          <div style=\"margin-bottom: 1.5rem;\">\n            <div\n              style=\"\n                display: inline-block;\n                border: 2px solid ${custom?.disableTitleBorder ? \"transparent\" : custom?.colors?.titleBorder || \"var(--destructive)\"};\n                padding: 0.375rem 1rem;\n              \"\n            >\n              <h1\n                style=\"\n                  font-size: var(--text-6xl);\n                  font-weight: var(--font-weight-semibold);\n                  color: ${custom?.colors?.titleColor || \"var(--foreground)\"};\n                  letter-spacing: -0.02em;\n                  margin: 0;\n                \"\n              >\n                ERROR\n              </h1>\n            </div>\n            <div\n              style=\"\n                height: 2px;\n                background-color: var(--border);\n                width: calc(100% + 3rem);\n                margin-left: -1.5rem;\n                margin-top: 1.5rem;\n              \"\n            ></div>\n          </div>\n\n          <h2\n            style=\"\n              font-size: var(--text-2xl);\n              font-weight: var(--font-weight-semibold);\n              color: var(--foreground);\n              margin: 0 0 1rem;\n            \"\n          >\n            Something went wrong\n          </h2>\n\n          <div\n            style=\"\n                display: inline-flex;\n                align-items: center;\n                gap: 0.5rem;\n                border: 2px solid var(--border);\n                background-color: var(--muted);\n                padding: 0.375rem 0.75rem;\n                margin: 0 0 1rem;\n                flex-wrap: wrap;\n                justify-content: center;\n            \"\n            >\n            <span\n                style=\"\n                font-size: 0.75rem;\n                color: var(--muted-foreground);\n                font-weight: var(--font-weight-semibold);\n                \"\n            >\n                CODE:\n            </span>\n            <span\n                style=\"\n                font-size: var(--text-sm);\n                font-family: var(--default-mono-font-family, monospace);\n                color: var(--foreground);\n                word-break: break-all;\n                \"\n            >\n                ${sanitize(code)}\n            </span>\n            </div>\n\n          <p\n            style=\"\n              color: var(--muted-foreground);\n              max-width: 28rem;\n              margin: 0 auto;\n              font-size: var(--text-sm);\n              line-height: 1.5;\n              text-wrap: pretty;\n            \"\n          >\n            ${\n\t\t\t\t\t\t\t!description\n\t\t\t\t\t\t\t\t? \"We encountered an unexpected error. Please try again or return to the home page. If you're a developer, you can find more information about the error \" +\n\t\t\t\t\t\t\t\t\t`<a href='https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}' target='_blank' rel=\"noopener noreferrer\" style='color: var(--foreground); text-decoration: underline;'>here</a>.`\n\t\t\t\t\t\t\t\t: description\n\t\t\t\t\t\t}\n          </p>\n        </div>\n\n        <div\n          style=\"\n            display: flex;\n            gap: 0.75rem;\n            margin-top: 1.5rem;\n            justify-content: center;\n            flex-wrap: wrap;\n          \"\n        >\n          <a\n            href=\"/\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: var(--primary);\n                color: var(--primary-foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Go Home\n            </div>\n          </a>\n          <a\n            href=\"https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}?askai=${encodeURIComponent(`What does the error code ${code} mean?`)}\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: transparent;\n                color: var(--foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Ask AI\n            </div>\n          </a>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>`;\n};\n\nexport const error = createAuthEndpoint(\n\t\"/error\",\n\t{\n\t\tmethod: \"GET\",\n\t\tmetadata: {\n\t\t\t...HIDE_METADATA,\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Displays an error page\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"text/html\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"The HTML content of the error page\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst url = new URL(c.request?.url || \"\");\n\t\tconst unsanitizedCode = url.searchParams.get(\"error\") || \"UNKNOWN\";\n\t\tconst unsanitizedDescription =\n\t\t\turl.searchParams.get(\"error_description\") || null;\n\n\t\tconst isValid = /^[\\'A-Za-z0-9_-]+$/.test(unsanitizedCode || \"\");\n\t\tconst safeCode = isValid ? unsanitizedCode : \"UNKNOWN\";\n\t\tconst safeDescription = unsanitizedDescription\n\t\t\t? sanitize(unsanitizedDescription)\n\t\t\t: null;\n\n\t\tconst queryParams = new URLSearchParams();\n\t\tqueryParams.set(\"error\", safeCode);\n\t\tif (unsanitizedDescription) {\n\t\t\tqueryParams.set(\"error_description\", unsanitizedDescription);\n\t\t}\n\n\t\tconst options = c.context.options;\n\t\tconst errorURL = options.onAPIError?.errorURL;\n\n\t\tif (errorURL) {\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 302,\n\t\t\t\theaders: {\n\t\t\t\t\tLocation: `${errorURL}${errorURL.includes(\"?\") ? \"&\" : \"?\"}${queryParams.toString()}`,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (isProduction && !options.onAPIError?.customizeDefaultErrorPage) {\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 302,\n\t\t\t\theaders: {\n\t\t\t\t\tLocation: `/?${queryParams.toString()}`,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn new Response(html(c.context.options, safeCode, safeDescription), {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"text/html\",\n\t\t\t},\n\t\t});\n\t},\n);\n","import { concat, uint64be } from './buffer_utils.js';\nimport { checkIvLength } from './check_iv_length.js';\nimport { checkCekLength } from './check_cek_length.js';\nimport { JOSENotSupported, JWEDecryptionFailed, JWEInvalid } from '../util/errors.js';\nimport { checkEncCryptoKey } from './crypto_key.js';\nimport { invalidKeyInput } from './invalid_key_input.js';\nimport { isCryptoKey } from './is_key_like.js';\nasync function timingSafeEqual(a, b) {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    const algorithm = { name: 'HMAC', hash: 'SHA-256' };\n    const key = (await crypto.subtle.generateKey(algorithm, false, ['sign']));\n    const aHmac = new Uint8Array(await crypto.subtle.sign(algorithm, key, a));\n    const bHmac = new Uint8Array(await crypto.subtle.sign(algorithm, key, b));\n    let out = 0;\n    let i = -1;\n    while (++i < 32) {\n        out |= aHmac[i] ^ bHmac[i];\n    }\n    return out === 0;\n}\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = await timingSafeEqual(tag, expectedTag);\n    }\n    catch {\n    }\n    if (!macCheckPassed) {\n        throw new JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await crypto.subtle.decrypt({ iv: iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch {\n    }\n    if (!plaintext) {\n        throw new JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'decrypt');\n        encKey = cek;\n    }\n    try {\n        return new Uint8Array(await crypto.subtle.decrypt({\n            additionalData: aad,\n            iv: iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, concat(ciphertext, tag)));\n    }\n    catch {\n        throw new JWEDecryptionFailed();\n    }\n}\nexport async function decrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'CryptoKey', 'KeyObject', 'Uint8Array', 'JSON Web Key'));\n    }\n    if (!iv) {\n        throw new JWEInvalid('JWE Initialization Vector missing');\n    }\n    if (!tag) {\n        throw new JWEInvalid('JWE Authentication Tag missing');\n    }\n    checkIvLength(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tBetterAuthPluginDBSchema,\n\tDBFieldAttribute,\n} from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport { APIError } from \"better-call\";\nimport type { Account, Session, User } from \"../types\";\n\n// Cache for parsed schemas to avoid reparsing on every request\nconst cache = new WeakMap<\n\tBetterAuthOptions,\n\tMap<string, Record<string, DBFieldAttribute>>\n>();\n\nfunction parseOutputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t},\n) {\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (\n\t\t\tfield.returned === false &&\n\t\t\tkey !== \"id\" // id is always returned\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData as T;\n}\n\nfunction getFields(\n\toptions: BetterAuthOptions,\n\ttable: string,\n\tmode: \"input\" | \"output\",\n) {\n\tconst cacheKey = `${table}:${mode}`;\n\tif (!cache.has(options)) {\n\t\tcache.set(options, new Map());\n\t}\n\tconst tableCache = cache.get(options)!;\n\tif (tableCache.has(cacheKey)) {\n\t\treturn tableCache.get(cacheKey)!;\n\t}\n\tconst coreSchema =\n\t\tmode === \"output\" ? (getAuthTables(options)[table]?.fields ?? {}) : {};\n\tconst additionalFields =\n\t\ttable === \"user\" || table === \"session\" || table === \"account\"\n\t\t\t? options[table]?.additionalFields\n\t\t\t: undefined;\n\tlet schema: Record<string, DBFieldAttribute> = {\n\t\t...coreSchema,\n\t\t...(additionalFields ?? {}),\n\t};\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.schema && plugin.schema[table]) {\n\t\t\tschema = {\n\t\t\t\t...schema,\n\t\t\t\t...plugin.schema[table].fields,\n\t\t\t};\n\t\t}\n\t}\n\ttableCache.set(cacheKey, schema);\n\treturn schema;\n}\n\nexport function parseUserOutput<T extends User>(\n\toptions: BetterAuthOptions,\n\tuser: T,\n) {\n\tconst schema = getFields(options, \"user\", \"output\");\n\treturn parseOutputData(user, { fields: schema });\n}\n\nexport function parseSessionOutput<T extends Session>(\n\toptions: BetterAuthOptions,\n\tsession: T,\n) {\n\tconst schema = getFields(options, \"session\", \"output\");\n\treturn parseOutputData(session, { fields: schema });\n}\n\nexport function parseAccountOutput<T extends Account>(\n\toptions: BetterAuthOptions,\n\taccount: T,\n) {\n\tconst schema = getFields(options, \"account\", \"output\");\n\tconst parsed = parseOutputData(account, { fields: schema });\n\t// destructuring for type inference\n\t// runtime filtering is already done by `parseOutputData`\n\tconst {\n\t\taccessToken: _accessToken,\n\t\trefreshToken: _refreshToken,\n\t\tidToken: _idToken,\n\t\taccessTokenExpiresAt: _accessTokenExpiresAt,\n\t\trefreshTokenExpiresAt: _refreshTokenExpiresAt,\n\t\tpassword: _password,\n\t\t...rest\n\t} = parsed;\n\treturn rest;\n}\n\nexport function parseInputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\taction?: (\"create\" | \"update\") | undefined;\n\t},\n) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = Object.assign(\n\t\tObject.create(null),\n\t\tnull,\n\t);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key]!.input === false) {\n\t\t\t\tif (fields[key]!.defaultValue !== undefined) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: `${key} is not allowed to be set`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.validator?.input && data[key] !== undefined) {\n\t\t\t\tconst result = fields[key]!.validator.input[\"~standard\"].validate(\n\t\t\t\t\tdata[key],\n\t\t\t\t);\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Async validation is not supported for additional fields\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (\"issues\" in result && result.issues) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: result.issues[0]?.message || \"Validation Error\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tparsedData[key] = result.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.transform?.input && data[key] !== undefined) {\n\t\t\t\tparsedData[key] = fields[key]!.transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.defaultValue !== undefined && action === \"create\") {\n\t\t\tif (typeof fields[key]!.defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key]!.defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.required && action === \"create\") {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `${key} is required`,\n\t\t\t});\n\t\t}\n\t}\n\treturn parsedData as Partial<T>;\n}\n\nexport function parseUserInput(\n\toptions: BetterAuthOptions,\n\tuser: Record<string, any> = {},\n\taction: \"create\" | \"update\",\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user, { fields: schema, action });\n}\n\nexport function parseAdditionalUserInput(\n\toptions: BetterAuthOptions,\n\tuser?: Record<string, any> | undefined,\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\n\nexport function parseAccountInput(\n\toptions: BetterAuthOptions,\n\taccount: Partial<Account>,\n) {\n\tconst schema = getFields(options, \"account\", \"input\");\n\treturn parseInputData(account, { fields: schema });\n}\n\nexport function parseSessionInput(\n\toptions: BetterAuthOptions,\n\tsession: Partial<Session>,\n) {\n\tconst schema = getFields(options, \"session\", \"input\");\n\treturn parseInputData(session, { fields: schema });\n}\n\nexport function mergeSchema<S extends BetterAuthPluginDBSchema>(\n\tschema: S,\n\tnewSchema?:\n\t\t| {\n\t\t\t\t[K in keyof S]?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tmodelName?: string | undefined;\n\t\t\t\t\t\t\tfields?:\n\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t[P: string]: string;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tif (!newSchema) {\n\t\treturn schema;\n\t}\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) {\n\t\t\tschema[table]!.modelName = newModelName;\n\t\t}\n\t\tfor (const field in schema[table]!.fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tschema[table]!.fields[field]!.fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport { getAuthTables } from \".\";\n\nexport function getSchema(config: BetterAuthOptions) {\n\tconst tables = getAuthTables(config);\n\tconst schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t> = {};\n\tfor (const key in tables) {\n\t\tconst table = tables[key]!;\n\t\tconst fields = table.fields;\n\t\tconst actualFields: Record<string, DBFieldAttribute> = {};\n\t\tObject.entries(fields).forEach(([key, field]) => {\n\t\t\tactualFields[field.fieldName || key] = field;\n\t\t\tif (field.references) {\n\t\t\t\tconst refTable = tables[field.references.model];\n\t\t\t\tif (refTable) {\n\t\t\t\t\tactualFields[field.fieldName || key]!.references = {\n\t\t\t\t\t\t...field.references,\n\t\t\t\t\t\tmodel: refTable.modelName,\n\t\t\t\t\t\tfield: field.references.field,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (schema[table.modelName]) {\n\t\t\tschema[table.modelName]!.fields = {\n\t\t\t\t...schema[table.modelName]!.fields,\n\t\t\t\t...actualFields,\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\t\tschema[table.modelName] = {\n\t\t\tfields: actualFields,\n\t\t\torder: table.order || Infinity,\n\t\t};\n\t}\n\treturn schema;\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport type { MemoryDB } from \"../adapters/memory-adapter\";\n\nexport async function getBaseAdapter(\n\toptions: BetterAuthOptions,\n\thandleDirectDatabase: (\n\t\toptions: BetterAuthOptions,\n\t) => Promise<DBAdapter<BetterAuthOptions>>,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\tlet adapter: DBAdapter<BetterAuthOptions>;\n\n\tif (!options.database) {\n\t\tconst tables = getAuthTables(options);\n\t\tconst memoryDB = Object.keys(tables).reduce<MemoryDB>((acc, key) => {\n\t\t\tacc[key] = [];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst { memoryAdapter } = await import(\"../adapters/memory-adapter\");\n\t\tadapter = memoryAdapter(memoryDB)(options);\n\t} else if (typeof options.database === \"function\") {\n\t\tadapter = options.database(options);\n\t} else {\n\t\tadapter = await handleDirectDatabase(options);\n\t}\n\n\t// patch for 1.3.x to ensure we have a transaction function in the adapter\n\tif (!adapter.transaction) {\n\t\tlogger.warn(\n\t\t\t\"Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.\",\n\t\t);\n\t\tadapter.transaction = async (cb) => {\n\t\t\treturn cb(adapter);\n\t\t};\n\t}\n\n\treturn adapter;\n}\n","import { APIError } from \"./error\";\nimport { isAPIError } from \"./utils\";\n\nfunction isJSONSerializable(value: any) {\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n\t\treturn true;\n\t}\n\tif (t !== \"object\") {\n\t\treturn false;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tif (value.buffer) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t(value.constructor && value.constructor.name === \"Object\") ||\n\t\ttypeof value.toJSON === \"function\"\n\t);\n}\n\nfunction safeStringify(\n\tobj: any,\n\treplacer?: (key: string, value: any) => any,\n\tspace?: string | number,\n): string {\n\tlet id = 0;\n\tconst seen = new WeakMap<object, number>(); // ref -> counter\n\n\tconst safeReplacer = (key: string, value: any) => {\n\t\t// Handle bigint first\n\t\tif (typeof value === \"bigint\") {\n\t\t\treturn value.toString();\n\t\t}\n\n\t\t// Then handle circular references\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tif (seen.has(value)) {\n\t\t\t\treturn `[Circular ref-${seen.get(value)}]`;\n\t\t\t}\n\t\t\tseen.set(value, id++);\n\t\t}\n\n\t\t// Finally apply any custom replacer\n\t\tif (replacer) {\n\t\t\treturn replacer(key, value);\n\t\t}\n\n\t\treturn value;\n\t};\n\n\treturn JSON.stringify(obj, safeReplacer, space);\n}\n\nexport type JSONResponse = {\n\tbody: Record<string, any>;\n\trouterResponse: ResponseInit | undefined;\n\tstatus?: number;\n\theaders?: Record<string, string> | Headers;\n\t_flag: \"json\";\n};\n\nfunction isJSONResponse(value: any): value is JSONResponse {\n\tif (!value || typeof value !== \"object\") {\n\t\treturn false;\n\t}\n\treturn \"_flag\" in value && value._flag === \"json\";\n}\n\nexport function toResponse(data?: any, init?: ResponseInit): Response {\n\tif (data instanceof Response) {\n\t\tif (init?.headers instanceof Headers) {\n\t\t\tinit.headers.forEach((value, key) => {\n\t\t\t\tdata.headers.set(key, value);\n\t\t\t});\n\t\t}\n\t\treturn data;\n\t}\n\tconst isJSON = isJSONResponse(data);\n\tif (isJSON) {\n\t\tconst body = data.body;\n\t\tconst routerResponse = data.routerResponse;\n\t\tif (routerResponse instanceof Response) {\n\t\t\treturn routerResponse;\n\t\t}\n\t\tconst headers = new Headers();\n\t\tif (routerResponse?.headers) {\n\t\t\tconst headers = new Headers(routerResponse.headers);\n\t\t\tfor (const [key, value] of headers.entries()) {\n\t\t\t\theaders.set(key, value);\n\t\t\t}\n\t\t}\n\t\tif (data.headers) {\n\t\t\tfor (const [key, value] of new Headers(data.headers).entries()) {\n\t\t\t\theaders.set(key, value);\n\t\t\t}\n\t\t}\n\t\tif (init?.headers) {\n\t\t\tfor (const [key, value] of new Headers(init.headers).entries()) {\n\t\t\t\theaders.set(key, value);\n\t\t\t}\n\t\t}\n\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\t\treturn new Response(JSON.stringify(body), {\n\t\t\t...routerResponse,\n\t\t\theaders,\n\t\t\tstatus: data.status ?? init?.status ?? routerResponse?.status,\n\t\t\tstatusText: init?.statusText ?? routerResponse?.statusText,\n\t\t});\n\t}\n\tif (isAPIError(data)) {\n\t\treturn toResponse(data.body, {\n\t\t\tstatus: init?.status ?? data.statusCode,\n\t\t\tstatusText: data.status.toString(),\n\t\t\theaders: init?.headers || data.headers,\n\t\t});\n\t}\n\tlet body = data;\n\tlet headers = new Headers(init?.headers);\n\tif (!data) {\n\t\tif (data === null) {\n\t\t\tbody = JSON.stringify(null);\n\t\t}\n\t\theaders.set(\"content-type\", \"application/json\");\n\t} else if (typeof data === \"string\") {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"text/plain\");\n\t} else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/octet-stream\");\n\t} else if (data instanceof Blob) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", data.type || \"application/octet-stream\");\n\t} else if (data instanceof FormData) {\n\t\tbody = data;\n\t} else if (data instanceof URLSearchParams) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\t} else if (data instanceof ReadableStream) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/octet-stream\");\n\t} else if (isJSONSerializable(data)) {\n\t\tbody = safeStringify(data);\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\t}\n\n\treturn new Response(body, {\n\t\t...init,\n\t\theaders,\n\t});\n}\n","import {\n\tcreateEndpoint,\n\ttype Endpoint,\n\ttype EndpointContext,\n\ttype EndpointOptions,\n} from \"./endpoint\";\nimport {\n\tcreateInternalContext,\n\ttype InferBody,\n\ttype InferBodyInput,\n\ttype InferHeaders,\n\ttype InferHeadersInput,\n\ttype InferMiddlewareBody,\n\ttype InferMiddlewareQuery,\n\ttype InferQuery,\n\ttype InferQueryInput,\n\ttype InferRequest,\n\ttype InferRequestInput,\n\ttype InferUse,\n\ttype InputContext,\n} from \"./context\";\nimport type { Prettify } from \"./helper\";\n\nexport interface MiddlewareOptions extends Omit<EndpointOptions, \"method\"> {}\n\nexport type MiddlewareResponse = null | void | undefined | Record<string, any>;\n\nexport type MiddlewareContext<Options extends MiddlewareOptions, Context = {}> = EndpointContext<\n\tstring,\n\tOptions & {\n\t\tmethod: \"*\";\n\t}\n> & {\n\t/**\n\t * Method\n\t *\n\t * The request method\n\t */\n\tmethod: string;\n\t/**\n\t * Path\n\t *\n\t * The path of the endpoint\n\t */\n\tpath: string;\n\t/**\n\t * Body\n\t *\n\t * The body object will be the parsed JSON from the request and validated\n\t * against the body schema if it exists\n\t */\n\tbody: InferMiddlewareBody<Options>;\n\t/**\n\t * Query\n\t *\n\t * The query object will be the parsed query string from the request\n\t * and validated against the query schema if it exists\n\t */\n\tquery: InferMiddlewareQuery<Options>;\n\t/**\n\t * Params\n\t *\n\t * If the path is `/user/:id` and the request is `/user/1` then the\n\t * params will\n\t * be `{ id: \"1\" }` and if the path includes a wildcard like `/user/*`\n\t * then the\n\t * params will be `{ _: \"1\" }` where `_` is the wildcard key. If the\n\t * wildcard\n\t * is named like `/user/**:name` then the params will be `{ name: string }`\n\t */\n\tparams: string;\n\t/**\n\t * Request object\n\t *\n\t * If `requireRequest` is set to true in the endpoint options this will be\n\t * required\n\t */\n\trequest: InferRequest<Options>;\n\t/**\n\t * Headers\n\t *\n\t * If `requireHeaders` is set to true in the endpoint options this will be\n\t * required\n\t */\n\theaders: InferHeaders<Options>;\n\t/**\n\t * Set header\n\t *\n\t * If it's called outside of a request it will just be ignored.\n\t */\n\tsetHeader: (key: string, value: string) => void;\n\t/**\n\t * Get header\n\t *\n\t * If it's called outside of a request it will just return null\n\t *\n\t * @param key  - The key of the header\n\t * @returns\n\t */\n\tgetHeader: (key: string) => string | null;\n\t/**\n\t * JSON\n\t *\n\t * a helper function to create a JSON response with\n\t * the correct headers\n\t * and status code. If `asResponse` is set to true in\n\t * the context then\n\t * it will return a Response object instead of the\n\t * JSON object.\n\t *\n\t * @param json - The JSON object to return\n\t * @param routerResponse - The response object to\n\t * return if `asResponse` is\n\t * true in the context this will take precedence\n\t */\n\tjson: <R extends Record<string, any> | null>(\n\t\tjson: R,\n\t\trouterResponse?:\n\t\t\t| {\n\t\t\t\t\tstatus?: number;\n\t\t\t\t\theaders?: Record<string, string>;\n\t\t\t\t\tresponse?: Response;\n\t\t\t  }\n\t\t\t| Response,\n\t) => Promise<R>;\n\t/**\n\t * Middleware context\n\t */\n\tcontext: Prettify<Context>;\n};\n\nexport function createMiddleware<Options extends MiddlewareOptions, R>(\n\toptions: Options,\n\thandler: (context: MiddlewareContext<Options>) => Promise<R>,\n): <InputCtx extends MiddlewareInputContext<Options>>(inputContext: InputCtx) => Promise<R>;\nexport function createMiddleware<Options extends MiddlewareOptions, R>(\n\thandler: (context: MiddlewareContext<Options>) => Promise<R>,\n): <InputCtx extends MiddlewareInputContext<Options>>(inputContext: InputCtx) => Promise<R>;\nexport function createMiddleware(optionsOrHandler: any, handler?: any) {\n\tconst internalHandler = async (inputCtx: InputContext<any, any>) => {\n\t\tconst context = inputCtx as InputContext<any, any>;\n\t\tconst _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n\t\tconst options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n\t\tconst internalContext = await createInternalContext(context, {\n\t\t\toptions,\n\t\t\tpath: \"/\",\n\t\t});\n\n\t\tif (!_handler) {\n\t\t\tthrow new Error(\"handler must be defined\");\n\t\t}\n\t\tconst response = await _handler(internalContext as any);\n\t\tconst headers = internalContext.responseHeaders;\n\t\treturn context.returnHeaders\n\t\t\t? {\n\t\t\t\t\theaders,\n\t\t\t\t\tresponse,\n\t\t\t\t}\n\t\t\t: response;\n\t};\n\tinternalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n\treturn internalHandler;\n}\n\nexport type MiddlewareInputContext<Options extends MiddlewareOptions> = InferBodyInput<Options> &\n\tInferQueryInput<Options> &\n\tInferRequestInput<Options> &\n\tInferHeadersInput<Options> & {\n\t\tasResponse?: boolean;\n\t\treturnHeaders?: boolean;\n\t\tuse?: Middleware[];\n\t};\n\nexport type Middleware<\n\tOptions extends MiddlewareOptions = MiddlewareOptions,\n\tHandler extends (inputCtx: any) => Promise<any> = any,\n> = Handler & {\n\toptions: Options;\n};\n\ncreateMiddleware.create = <\n\tE extends {\n\t\tuse?: Middleware[];\n\t},\n>(\n\topts?: E,\n) => {\n\ttype InferredContext = InferUse<E[\"use\"]>;\n\tfunction fn<Options extends MiddlewareOptions, R>(\n\t\toptions: Options,\n\t\thandler: (ctx: MiddlewareContext<Options, InferredContext>) => Promise<R>,\n\t): (inputContext: MiddlewareInputContext<Options>) => Promise<R>;\n\tfunction fn<Options extends MiddlewareOptions, R>(\n\t\thandler: (ctx: MiddlewareContext<Options, InferredContext>) => Promise<R>,\n\t): (inputContext: MiddlewareInputContext<Options>) => Promise<R>;\n\tfunction fn(optionsOrHandler: any, handler?: any) {\n\t\tif (typeof optionsOrHandler === \"function\") {\n\t\t\treturn createMiddleware(\n\t\t\t\t{\n\t\t\t\t\tuse: opts?.use,\n\t\t\t\t},\n\t\t\t\toptionsOrHandler,\n\t\t\t);\n\t\t}\n\t\tif (!handler) {\n\t\t\tthrow new Error(\"Middleware handler is required\");\n\t\t}\n\t\tconst middleware = createMiddleware(\n\t\t\t{\n\t\t\t\t...optionsOrHandler,\n\t\t\t\tmethod: \"*\",\n\t\t\t\tuse: [...(opts?.use || []), ...(optionsOrHandler.use || [])],\n\t\t\t},\n\t\t\thandler,\n\t\t);\n\t\treturn middleware as any;\n\t}\n\treturn fn;\n};\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { jwtVerify } from \"jose\";\nimport type { ProviderOptions } from \"./index\";\nimport { getOAuth2Tokens } from \"./index\";\n\nexport function createAuthorizationCodeRequest({\n\tcode,\n\tcodeVerifier,\n\tredirectURI,\n\toptions,\n\tauthentication,\n\tdeviceId,\n\theaders,\n\tadditionalParams = {},\n\tresource,\n}: {\n\tcode: string;\n\tredirectURI: string;\n\toptions: Partial<ProviderOptions>;\n\tcodeVerifier?: string | undefined;\n\tdeviceId?: string | undefined;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\theaders?: Record<string, string> | undefined;\n\tadditionalParams?: Record<string, string> | undefined;\n\tresource?: (string | string[]) | undefined;\n}) {\n\tconst body = new URLSearchParams();\n\tconst requestHeaders: Record<string, any> = {\n\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\taccept: \"application/json\",\n\t\t...headers,\n\t};\n\tbody.set(\"grant_type\", \"authorization_code\");\n\tbody.set(\"code\", code);\n\tcodeVerifier && body.set(\"code_verifier\", codeVerifier);\n\toptions.clientKey && body.set(\"client_key\", options.clientKey);\n\tdeviceId && body.set(\"device_id\", deviceId);\n\tbody.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\tif (resource) {\n\t\tif (typeof resource === \"string\") {\n\t\t\tbody.append(\"resource\", resource);\n\t\t} else {\n\t\t\tfor (const _resource of resource) {\n\t\t\t\tbody.append(\"resource\", _resource);\n\t\t\t}\n\t\t}\n\t}\n\t// Use standard Base64 encoding for HTTP Basic Auth (OAuth2 spec, RFC 7617)\n\t// Fixes compatibility with providers like Notion, Twitter, etc.\n\tif (authentication === \"basic\") {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tconst encodedCredentials = base64.encode(\n\t\t\t`${primaryClientId}:${options.clientSecret ?? \"\"}`,\n\t\t);\n\t\trequestHeaders[\"authorization\"] = `Basic ${encodedCredentials}`;\n\t} else {\n\t\tconst primaryClientId = Array.isArray(options.clientId)\n\t\t\t? options.clientId[0]\n\t\t\t: options.clientId;\n\t\tbody.set(\"client_id\", primaryClientId);\n\t\tif (options.clientSecret) {\n\t\t\tbody.set(\"client_secret\", options.clientSecret);\n\t\t}\n\t}\n\n\tfor (const [key, value] of Object.entries(additionalParams)) {\n\t\tif (!body.has(key)) body.append(key, value);\n\t}\n\n\treturn {\n\t\tbody,\n\t\theaders: requestHeaders,\n\t};\n}\n\nexport async function validateAuthorizationCode({\n\tcode,\n\tcodeVerifier,\n\tredirectURI,\n\toptions,\n\ttokenEndpoint,\n\tauthentication,\n\tdeviceId,\n\theaders,\n\tadditionalParams = {},\n\tresource,\n}: {\n\tcode: string;\n\tredirectURI: string;\n\toptions: Partial<ProviderOptions>;\n\tcodeVerifier?: string | undefined;\n\tdeviceId?: string | undefined;\n\ttokenEndpoint: string;\n\tauthentication?: (\"basic\" | \"post\") | undefined;\n\theaders?: Record<string, string> | undefined;\n\tadditionalParams?: Record<string, string> | undefined;\n\tresource?: (string | string[]) | undefined;\n}) {\n\tconst { body, headers: requestHeaders } = createAuthorizationCodeRequest({\n\t\tcode,\n\t\tcodeVerifier,\n\t\tredirectURI,\n\t\toptions,\n\t\tauthentication,\n\t\tdeviceId,\n\t\theaders,\n\t\tadditionalParams,\n\t\tresource,\n\t});\n\n\tconst { data, error } = await betterFetch<object>(tokenEndpoint, {\n\t\tmethod: \"POST\",\n\t\tbody: body,\n\t\theaders: requestHeaders,\n\t});\n\n\tif (error) {\n\t\tthrow error;\n\t}\n\tconst tokens = getOAuth2Tokens(data);\n\treturn tokens;\n}\n\nexport async function validateToken(token: string, jwksEndpoint: string) {\n\tconst { data, error } = await betterFetch<{\n\t\tkeys: {\n\t\t\tkid: string;\n\t\t\tkty: string;\n\t\t\tuse: string;\n\t\t\tn: string;\n\t\t\te: string;\n\t\t\tx5c: string[];\n\t\t}[];\n\t}>(jwksEndpoint, {\n\t\tmethod: \"GET\",\n\t\theaders: {\n\t\t\taccept: \"application/json\",\n\t\t},\n\t});\n\tif (error) {\n\t\tthrow error;\n\t}\n\tconst keys = data[\"keys\"];\n\tconst header = JSON.parse(atob(token.split(\".\")[0]!));\n\tconst key = keys.find((key) => key.kid === header.kid);\n\tif (!key) {\n\t\tthrow new Error(\"Key not found\");\n\t}\n\tconst verified = await jwtVerify(token, key);\n\treturn verified;\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { getBaseAdapter } from \"./adapter-base\";\n\nexport async function getAdapter(\n\toptions: BetterAuthOptions,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\treturn getBaseAdapter(options, async (opts) => {\n\t\tconst { createKyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\tconst { kysely, databaseType, transaction } =\n\t\t\tawait createKyselyAdapter(opts);\n\t\tif (!kysely) {\n\t\t\tthrow new BetterAuthError(\"Failed to initialize database adapter\");\n\t\t}\n\t\tconst { kyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\treturn kyselyAdapter(kysely, {\n\t\t\ttype: databaseType || \"sqlite\",\n\t\t\tdebugLogs:\n\t\t\t\topts.database && \"debugLogs\" in opts.database\n\t\t\t\t\t? opts.database.debugLogs\n\t\t\t\t\t: false,\n\t\t\ttransaction: transaction,\n\t\t})(opts);\n\t});\n}\n","/**\n * RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.\n * @module\n */\nimport { pbkdf2 } from './pbkdf2.ts';\nimport { sha256 } from './sha2.ts';\n// prettier-ignore\nimport {\n  anumber, asyncLoop,\n  checkOpts, clean,\n  type KDFInput, rotl,\n  swap32IfBE,\n  u32\n} from './utils.ts';\n\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(\n  prev: Uint32Array,\n  pi: number,\n  input: Uint32Array,\n  ii: number,\n  out: Uint32Array,\n  oi: number\n) {\n  // Based on https://cr.yp.to/salsa20.html\n  // Xor blocks\n  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n  // Save state to temporary variables (salsa)\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  // Main loop (salsa)\n  for (let i = 0; i < 8; i += 2) {\n    x04 ^= rotl(x00 + x12 | 0,  7); x08 ^= rotl(x04 + x00 | 0,  9);\n    x12 ^= rotl(x08 + x04 | 0, 13); x00 ^= rotl(x12 + x08 | 0, 18);\n    x09 ^= rotl(x05 + x01 | 0,  7); x13 ^= rotl(x09 + x05 | 0,  9);\n    x01 ^= rotl(x13 + x09 | 0, 13); x05 ^= rotl(x01 + x13 | 0, 18);\n    x14 ^= rotl(x10 + x06 | 0,  7); x02 ^= rotl(x14 + x10 | 0,  9);\n    x06 ^= rotl(x02 + x14 | 0, 13); x10 ^= rotl(x06 + x02 | 0, 18);\n    x03 ^= rotl(x15 + x11 | 0,  7); x07 ^= rotl(x03 + x15 | 0,  9);\n    x11 ^= rotl(x07 + x03 | 0, 13); x15 ^= rotl(x11 + x07 | 0, 18);\n    x01 ^= rotl(x00 + x03 | 0,  7); x02 ^= rotl(x01 + x00 | 0,  9);\n    x03 ^= rotl(x02 + x01 | 0, 13); x00 ^= rotl(x03 + x02 | 0, 18);\n    x06 ^= rotl(x05 + x04 | 0,  7); x07 ^= rotl(x06 + x05 | 0,  9);\n    x04 ^= rotl(x07 + x06 | 0, 13); x05 ^= rotl(x04 + x07 | 0, 18);\n    x11 ^= rotl(x10 + x09 | 0,  7); x08 ^= rotl(x11 + x10 | 0,  9);\n    x09 ^= rotl(x08 + x11 | 0, 13); x10 ^= rotl(x09 + x08 | 0, 18);\n    x12 ^= rotl(x15 + x14 | 0,  7); x13 ^= rotl(x12 + x15 | 0,  9);\n    x14 ^= rotl(x13 + x12 | 0, 13); x15 ^= rotl(x14 + x13 | 0, 18);\n  }\n  // Write output (salsa)\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n\nfunction BlockMix(input: Uint32Array, ii: number, out: Uint32Array, oi: number, r: number) {\n  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n  let head = oi + 0;\n  let tail = oi + 16 * r;\n  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\n  for (let i = 0; i < r; i++, head += 16, ii += 16) {\n    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n    if (i > 0) tail += 16; // First iteration overwrites tmp value in tail\n    XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n  }\n}\n\n/**\n * Scrypt options:\n * - `N` is cpu/mem work factor (power of 2 e.g. `2**18`)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n */\nexport type ScryptOpts = {\n  N: number; // cost factor\n  r: number; // block size\n  p: number; // parallelization\n  dkLen?: number; // key length\n  asyncTick?: number; // block execution max time\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password: KDFInput, salt: KDFInput, _opts?: ScryptOpts) {\n  // Maxmem - 1GB+1KB by default\n  const opts = checkOpts(\n    {\n      dkLen: 32,\n      asyncTick: 10,\n      maxmem: 1024 ** 3 + 1024,\n    },\n    _opts\n  );\n  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n  anumber(N, 'N');\n  anumber(r, 'r');\n  anumber(p, 'p');\n  anumber(dkLen, 'dkLen');\n  anumber(asyncTick, 'asyncTick');\n  anumber(maxmem, 'maxmem');\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb must be a function');\n  const blockSize = 128 * r;\n  const blockSize32 = blockSize / 4;\n\n  // Max N is 2^32 (Integrify is 32-bit).\n  // Real limit can be 2^22: some JS engines limit Uint8Array to 4GB.\n  // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,\n  // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:\n  // https://www.rfc-editor.org/errata_search.php?rfc=7914\n  const pow32 = Math.pow(2, 32);\n  if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32)\n    throw new Error('\"N\" expected a power of 2, and 2^1 <= N <= 2^32');\n  if (p < 1 || p > ((pow32 - 1) * 32) / blockSize)\n    throw new Error('\"p\" expected integer 1..((2^32 - 1) * 32) / (128 * r)');\n  if (dkLen < 1 || dkLen > (pow32 - 1) * 32)\n    throw new Error('\"dkLen\" expected integer 1..(2^32 - 1) * 32');\n  const memUsed = blockSize * (N + p);\n  if (memUsed > maxmem)\n    throw new Error('\"maxmem\" limit was hit, expected 128*r*(N+p) <= \"maxmem\"=' + maxmem);\n  // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n  // Since it has only one iteration there is no reason to use async variant\n  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });\n  const B32 = u32(B);\n  // Re-used between parallel iterations. Array(iterations) of B\n  const V = u32(new Uint8Array(blockSize * N));\n  const tmp = u32(new Uint8Array(blockSize));\n  let blockMixCb = () => {};\n  if (onProgress) {\n    const totalBlockMix = 2 * N * p;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n    let blockMixCnt = 0;\n    blockMixCb = () => {\n      blockMixCnt++;\n      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n        onProgress(blockMixCnt / totalBlockMix);\n    };\n  }\n  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\n\nfunction scryptOutput(\n  password: KDFInput,\n  dkLen: number,\n  B: Uint8Array,\n  V: Uint32Array,\n  tmp: Uint32Array\n) {\n  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });\n  clean(B, V, tmp);\n  return res;\n}\n\n/**\n * Scrypt KDF from RFC 7914. See {@link ScryptOpts}.\n * @example\n * scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nexport function scrypt(password: KDFInput, salt: KDFInput, opts: ScryptOpts): Uint8Array {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  swap32IfBE(B32);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    for (let i = 0, pos = 0; i < N - 1; i++) {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    }\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    for (let i = 0; i < N; i++) {\n      // First u32 of the last 64-byte block (u32 is LE)\n      // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32\n      const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    }\n  }\n  swap32IfBE(B32);\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n\n/**\n * Scrypt KDF from RFC 7914. Async version. See {@link ScryptOpts}.\n * @example\n * await scryptAsync('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nexport async function scryptAsync(\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ScryptOpts\n): Promise<Uint8Array> {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  swap32IfBE(B32);\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    let pos = 0;\n    await asyncLoop(N - 1, asyncTick, () => {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    });\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    await asyncLoop(N, asyncTick, () => {\n      // First u32 of the last 64-byte block (u32 is LE)\n      // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32\n      const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    });\n  }\n  swap32IfBE(B32);\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, oidNist, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\n/** Internal 32-byte base SHA2 hash class. */\nabstract class SHA2_32B<T extends SHA2_32B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected abstract A: number;\n  protected abstract B: number;\n  protected abstract C: number;\n  protected abstract D: number;\n  protected abstract E: number;\n  protected abstract F: number;\n  protected abstract G: number;\n  protected abstract H: number;\n\n  constructor(outputLen: number) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B<_SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B<_SHA224> {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal 64-byte base SHA2 hash class. */\nabstract class SHA2_64B<T extends SHA2_64B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected abstract Ah: number;\n  protected abstract Al: number;\n  protected abstract Bh: number;\n  protected abstract Bl: number;\n  protected abstract Ch: number;\n  protected abstract Cl: number;\n  protected abstract Dh: number;\n  protected abstract Dl: number;\n  protected abstract Eh: number;\n  protected abstract El: number;\n  protected abstract Fh: number;\n  protected abstract Fl: number;\n  protected abstract Gh: number;\n  protected abstract Gl: number;\n  protected abstract Hh: number;\n  protected abstract Hl: number;\n\n  constructor(outputLen: number) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B<_SHA512> {\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor() {\n    super(64);\n  }\n}\n\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B<_SHA384> {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B<_SHA512_224> {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B<_SHA512_256> {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256: CHash<_SHA256> = /* @__PURE__ */ createHasher(\n  () => new _SHA256(),\n  /* @__PURE__ */ oidNist(0x01)\n);\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash<_SHA224> = /* @__PURE__ */ createHasher(\n  () => new _SHA224(),\n  /* @__PURE__ */ oidNist(0x04)\n);\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash<_SHA512> = /* @__PURE__ */ createHasher(\n  () => new _SHA512(),\n  /* @__PURE__ */ oidNist(0x03)\n);\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash<_SHA384> = /* @__PURE__ */ createHasher(\n  () => new _SHA384(),\n  /* @__PURE__ */ oidNist(0x02)\n);\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash<_SHA512_256> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_256(),\n  /* @__PURE__ */ oidNist(0x06)\n);\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash<_SHA512_224> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_224(),\n  /* @__PURE__ */ oidNist(0x05)\n);\n","import { concat, uint64be } from './buffer_utils.js';\nimport { checkIvLength } from './check_iv_length.js';\nimport { checkCekLength } from './check_cek_length.js';\nimport { checkEncCryptoKey } from './crypto_key.js';\nimport { invalidKeyInput } from './invalid_key_input.js';\nimport { generateIv } from './iv.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './is_key_like.js';\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({\n        iv: iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));\n    const tag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag, iv };\n}\nasync function gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);\n    }\n    else {\n        checkEncCryptoKey(cek, enc, 'encrypt');\n        encKey = cek;\n    }\n    const encrypted = new Uint8Array(await crypto.subtle.encrypt({\n        additionalData: aad,\n        iv: iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag, iv };\n}\nexport async function encrypt(enc, plaintext, cek, iv, aad) {\n    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError(invalidKeyInput(cek, 'CryptoKey', 'KeyObject', 'Uint8Array', 'JSON Web Key'));\n    }\n    if (iv) {\n        checkIvLength(enc, iv);\n    }\n    else {\n        iv = generateIv(enc);\n    }\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array) {\n                checkCekLength(cek, parseInt(enc.slice(-3), 10));\n            }\n            return cbcEncrypt(enc, plaintext, cek, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array) {\n                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));\n            }\n            return gcmEncrypt(enc, plaintext, cek, iv, aad);\n        default:\n            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n}\n","import { digest } from '../lib/digest.js';\nimport { encode as b64u } from '../util/base64url.js';\nimport { JOSENotSupported, JWKInvalid } from '../util/errors.js';\nimport { encode } from '../lib/buffer_utils.js';\nimport { isKeyLike } from '../lib/is_key_like.js';\nimport { isJWK } from '../lib/is_jwk.js';\nimport { exportJWK } from '../key/export.js';\nimport { invalidKeyInput } from '../lib/invalid_key_input.js';\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new JWKInvalid(`${description} missing or invalid`);\n    }\n};\nexport async function calculateJwkThumbprint(key, digestAlgorithm) {\n    let jwk;\n    if (isJWK(key)) {\n        jwk = key;\n    }\n    else if (isKeyLike(key)) {\n        jwk = await exportJWK(key);\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    digestAlgorithm ??= 'sha256';\n    if (digestAlgorithm !== 'sha256' &&\n        digestAlgorithm !== 'sha384' &&\n        digestAlgorithm !== 'sha512') {\n        throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'AKP':\n            check(jwk.alg, '\"alg\" (Algorithm) Parameter');\n            check(jwk.pub, '\"pub\" (Public key) Parameter');\n            components = { alg: jwk.alg, kty: jwk.kty, pub: jwk.pub };\n            break;\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = encode(JSON.stringify(components));\n    return b64u(await digest(digestAlgorithm, data));\n}\nexport async function calculateJwkThumbprintUri(key, digestAlgorithm) {\n    digestAlgorithm ??= 'sha256';\n    const thumbprint = await calculateJwkThumbprint(key, digestAlgorithm);\n    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;\n}\n","import { encode as b64u } from '../../util/base64url.js';\nimport { sign } from '../../lib/sign.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { concat, encode } from '../../lib/buffer_utils.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payloadS;\n        let payloadB;\n        if (b64) {\n            payloadS = b64u(this.#payload);\n            payloadB = encode(payloadS);\n        }\n        else {\n            payloadB = this.#payload;\n            payloadS = '';\n        }\n        let protectedHeaderString;\n        let protectedHeaderBytes;\n        if (this.#protectedHeader) {\n            protectedHeaderString = b64u(JSON.stringify(this.#protectedHeader));\n            protectedHeaderBytes = encode(protectedHeaderString);\n        }\n        else {\n            protectedHeaderString = '';\n            protectedHeaderBytes = new Uint8Array();\n        }\n        const data = concat(protectedHeaderBytes, encode('.'), payloadB);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: payloadS,\n        };\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = protectedHeaderString;\n        }\n        return jws;\n    }\n}\n","/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nimport { hmac } from './hmac.ts';\n// prettier-ignore\nimport {\n  ahash, anumber,\n  asyncLoop, checkOpts, clean, createView, kdfInputToBytes,\n  type CHash,\n  type Hash,\n  type KDFInput\n} from './utils.ts';\n\n/**\n * PBKDF2 options:\n * * c: iterations, should probably be higher than 100_000\n * * dkLen: desired length of derived key in bytes\n * * asyncTick: max time in ms for which async function can block execution\n */\nexport type Pbkdf2Opt = {\n  c: number;\n  dkLen?: number;\n  asyncTick?: number;\n};\n// Common start and end for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {\n  ahash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  anumber(c, 'c');\n  anumber(dkLen, 'dkLen');\n  anumber(asyncTick, 'asyncTick');\n  if (c < 1) throw new Error('iterations (c) must be >= 1');\n  const password = kdfInputToBytes(_password, 'password');\n  const salt = kdfInputToBytes(_salt, 'salt');\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  clean(u);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nexport function pbkdf2(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Uint8Array {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 +  + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nexport async function pbkdf2Async(\n  hash: CHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 +  + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, () => {\n      // Uc = PRF(Password, Uc1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n","interface CookieAttributes {\n\tvalue: string;\n\t\"max-age\"?: number | undefined;\n\texpires?: Date | undefined;\n\tdomain?: string | undefined;\n\tpath?: string | undefined;\n\tsecure?: boolean | undefined;\n\thttponly?: boolean | undefined;\n\tsamesite?: (\"strict\" | \"lax\" | \"none\") | undefined;\n\t[key: string]: any;\n}\n\nexport const SECURE_COOKIE_PREFIX = \"__Secure-\";\nexport const HOST_COOKIE_PREFIX = \"__Host-\";\n\n/**\n * Remove __Secure- or __Host- prefix from cookie name.\n */\nexport function stripSecureCookiePrefix(cookieName: string): string {\n\tif (cookieName.startsWith(SECURE_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(SECURE_COOKIE_PREFIX.length);\n\t}\n\tif (cookieName.startsWith(HOST_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(HOST_COOKIE_PREFIX.length);\n\t}\n\treturn cookieName;\n}\n\n/**\n * Split `Set-Cookie` header, handling commas in `Expires` dates.\n */\nexport function splitSetCookieHeader(setCookie: string): string[] {\n\tif (!setCookie) return [];\n\n\tconst result: string[] = [];\n\tlet current = \"\";\n\tlet i = 0;\n\n\twhile (i < setCookie.length) {\n\t\tconst c = setCookie[i];\n\n\t\tif (c === \",\") {\n\t\t\tconst lower = current.toLowerCase();\n\t\t\tif (lower.includes(\"expires=\") && !lower.includes(\"gmt\")) {\n\t\t\t\tcurrent += c;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tconst trimmed = current.trim();\n\t\t\t\tif (trimmed) {\n\t\t\t\t\tresult.push(trimmed);\n\t\t\t\t}\n\t\t\t\tcurrent = \"\";\n\t\t\t\ti++;\n\t\t\t\tif (i < setCookie.length && setCookie[i] === \" \") {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent += c;\n\t\ti++;\n\t}\n\n\tconst trimmed = current.trim();\n\tif (trimmed) {\n\t\tresult.push(trimmed);\n\t}\n\n\treturn result;\n}\n\nexport function parseSetCookieHeader(\n\tsetCookie: string,\n): Map<string, CookieAttributes> {\n\tconst cookies = new Map<string, CookieAttributes>();\n\tconst cookieArray = splitSetCookieHeader(setCookie);\n\n\tcookieArray.forEach((cookieString) => {\n\t\tconst parts = cookieString.split(\";\").map((part) => part.trim());\n\t\tconst [nameValue, ...attributes] = parts;\n\t\tconst [name, ...valueParts] = (nameValue || \"\").split(\"=\");\n\n\t\tconst value = valueParts.join(\"=\");\n\n\t\tif (!name || value === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrObj: CookieAttributes = { value };\n\n\t\tattributes.forEach((attribute) => {\n\t\t\tconst [attrName, ...attrValueParts] = attribute!.split(\"=\");\n\t\t\tconst attrValue = attrValueParts.join(\"=\");\n\n\t\t\tconst normalizedAttrName = attrName!.trim().toLowerCase();\n\n\t\t\tswitch (normalizedAttrName) {\n\t\t\t\tcase \"max-age\":\n\t\t\t\t\tattrObj[\"max-age\"] = attrValue\n\t\t\t\t\t\t? parseInt(attrValue.trim(), 10)\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"expires\":\n\t\t\t\t\tattrObj.expires = attrValue ? new Date(attrValue.trim()) : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"domain\":\n\t\t\t\t\tattrObj.domain = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"path\":\n\t\t\t\t\tattrObj.path = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"secure\":\n\t\t\t\t\tattrObj.secure = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"httponly\":\n\t\t\t\t\tattrObj.httponly = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"samesite\":\n\t\t\t\t\tattrObj.samesite = attrValue\n\t\t\t\t\t\t? (attrValue.trim().toLowerCase() as \"strict\" | \"lax\" | \"none\")\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Handle any other attributes\n\t\t\t\t\tattrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\tcookies.set(name, attrObj);\n\t});\n\n\treturn cookies;\n}\n\nexport function setCookieToHeader(headers: Headers) {\n\treturn (context: { response: Response }) => {\n\t\tconst setCookieHeader = context.response.headers.get(\"set-cookie\");\n\t\tif (!setCookieHeader) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cookieMap = new Map<string, string>();\n\n\t\tconst existingCookiesHeader = headers.get(\"cookie\") || \"\";\n\t\texistingCookiesHeader.split(\";\").forEach((cookie) => {\n\t\t\tconst [name, ...rest] = cookie!.trim().split(\"=\");\n\t\t\tif (name && rest.length > 0) {\n\t\t\t\tcookieMap.set(name, rest.join(\"=\"));\n\t\t\t}\n\t\t});\n\n\t\tconst cookies = parseSetCookieHeader(setCookieHeader);\n\t\tcookies.forEach((value, name) => {\n\t\t\tcookieMap.set(name, value.value);\n\t\t});\n\n\t\tconst updatedCookies = Array.from(cookieMap.entries())\n\t\t\t.map(([name, value]) => `${name}=${value}`)\n\t\t\t.join(\"; \");\n\t\theaders.set(\"cookie\", updatedCookies);\n\t};\n}\n","import type { AsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport { getAsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport type { EndpointContext, InputContext } from \"better-call\";\nimport type { AuthContext } from \"../types\";\nimport { __getBetterAuthGlobal } from \"./global\";\n\nexport type AuthEndpointContext = Partial<\n\tInputContext<string, any> & EndpointContext<string, any>\n> & {\n\tcontext: AuthContext;\n};\n\nconst ensureAsyncStorage = async () => {\n\tconst betterAuthGlobal = __getBetterAuthGlobal();\n\tif (!betterAuthGlobal.context.endpointContextAsyncStorage) {\n\t\tconst AsyncLocalStorage = await getAsyncLocalStorage();\n\t\tbetterAuthGlobal.context.endpointContextAsyncStorage =\n\t\t\tnew AsyncLocalStorage<AuthEndpointContext>();\n\t}\n\treturn betterAuthGlobal.context\n\t\t.endpointContextAsyncStorage as AsyncLocalStorage<AuthEndpointContext>;\n};\n\n/**\n * This is for internal use only. Most users should use `getCurrentAuthContext` instead.\n *\n * It is exposed for advanced use cases where you need direct access to the AsyncLocalStorage instance.\n */\nexport async function getCurrentAuthContextAsyncLocalStorage() {\n\treturn ensureAsyncStorage();\n}\n\nexport async function getCurrentAuthContext(): Promise<AuthEndpointContext> {\n\tconst als = await ensureAsyncStorage();\n\tconst context = als.getStore();\n\tif (!context) {\n\t\tthrow new Error(\n\t\t\t\"No auth context found. Please make sure you are calling this function within a `runWithEndpointContext` callback.\",\n\t\t);\n\t}\n\treturn context;\n}\n\nexport async function runWithEndpointContext<T>(\n\tcontext: AuthEndpointContext,\n\tfn: () => T,\n): Promise<T> {\n\tconst als = await ensureAsyncStorage();\n\treturn als.run(context, fn);\n}\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\nimport { setOAuthState } from \"../api/middlewares/oauth\";\nimport { generateRandomString } from \"../crypto\";\nimport type { StateData } from \"../state\";\nimport { generateGenericState, parseGenericState, StateError } from \"../state\";\n\nexport async function generateState(\n\tc: GenericEndpointContext,\n\tlink:\n\t\t| {\n\t\t\t\temail: string;\n\t\t\t\tuserId: string;\n\t\t  }\n\t\t| undefined,\n\tadditionalData: Record<string, any> | false | undefined,\n) {\n\tconst callbackURL = c.body?.callbackURL || c.context.options.baseURL;\n\tif (!callbackURL) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"callbackURL is required\",\n\t\t});\n\t}\n\n\tconst codeVerifier = generateRandomString(128);\n\n\tconst stateData: StateData = {\n\t\t...(additionalData ? additionalData : {}),\n\t\tcallbackURL,\n\t\tcodeVerifier,\n\t\terrorURL: c.body?.errorCallbackURL,\n\t\tnewUserURL: c.body?.newUserCallbackURL,\n\t\tlink,\n\t\texpiresAt: Date.now() + 10 * 60 * 1000,\n\t\trequestSignUp: c.body?.requestSignUp,\n\t};\n\n\tawait setOAuthState(stateData);\n\n\ttry {\n\t\treturn generateGenericState(c, stateData);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to create verification\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\tmessage: \"Unable to create verification\",\n\t\t\tcause: error,\n\t\t});\n\t}\n}\n\nexport async function parseState(c: GenericEndpointContext) {\n\tconst state = c.query.state || c.body.state;\n\tconst errorURL =\n\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\n\tlet parsedData: StateData;\n\n\ttry {\n\t\tparsedData = await parseGenericState(c, state);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to parse state\", error);\n\n\t\tif (\n\t\t\terror instanceof StateError &&\n\t\t\terror.code === \"state_security_mismatch\"\n\t\t) {\n\t\t\tthrow c.redirect(`${errorURL}?error=state_mismatch`);\n\t\t}\n\n\t\tthrow c.redirect(`${errorURL}?error=please_restart_the_process`);\n\t}\n\n\tif (!parsedData.errorURL) {\n\t\tparsedData.errorURL = errorURL;\n\t}\n\n\tif (parsedData) {\n\t\tawait setOAuthState(parsedData);\n\t}\n\n\treturn parsedData;\n}\n","import { getWebcryptoSubtle } from \"@better-auth/utils\";\nconst algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n\nexport const getCryptoKey = async (secret: string | BufferSource) => {\n\tconst secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await getWebcryptoSubtle().importKey(\"raw\", secretBuf, algorithm, false, [\n\t\t\"sign\",\n\t\t\"verify\",\n\t]);\n};\n\nexport const verifySignature = async (\n\tbase64Signature: string,\n\tvalue: string,\n\tsecret: CryptoKey,\n): Promise<boolean> => {\n\ttry {\n\t\tconst signatureBinStr = atob(base64Signature);\n\t\tconst signature = new Uint8Array(signatureBinStr.length);\n\t\tfor (let i = 0, len = signatureBinStr.length; i < len; i++) {\n\t\t\tsignature[i] = signatureBinStr.charCodeAt(i);\n\t\t}\n\t\treturn await getWebcryptoSubtle().verify(\n\t\t\talgorithm,\n\t\t\tsecret,\n\t\t\tsignature,\n\t\t\tnew TextEncoder().encode(value),\n\t\t);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nconst makeSignature = async (value: string, secret: string | BufferSource): Promise<string> => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await getWebcryptoSubtle().sign(\n\t\talgorithm.name,\n\t\tkey,\n\t\tnew TextEncoder().encode(value),\n\t);\n\t// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\n\nexport const signCookieValue = async (value: string, secret: string | BufferSource) => {\n\tconst signature = await makeSignature(value, secret);\n\tvalue = `${value}.${signature}`;\n\tvalue = encodeURIComponent(value);\n\treturn value;\n};\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { isDevelopment, logger } from \"@better-auth/core/env\";\nimport { APIError, createEmailVerificationToken } from \"../api\";\nimport { setAccountCookie } from \"../cookies/session-store\";\nimport type { Account, User } from \"../types\";\nimport { setTokenUtil } from \"./utils\";\n\nexport async function handleOAuthUserInfo(\n\tc: GenericEndpointContext,\n\topts: {\n\t\tuserInfo: Omit<User, \"createdAt\" | \"updatedAt\">;\n\t\taccount: Omit<Account, \"id\" | \"userId\" | \"createdAt\" | \"updatedAt\">;\n\t\tcallbackURL?: string | undefined;\n\t\tdisableSignUp?: boolean | undefined;\n\t\toverrideUserInfo?: boolean | undefined;\n\t\tisTrustedProvider?: boolean | undefined;\n\t},\n) {\n\tconst { userInfo, account, callbackURL, disableSignUp, overrideUserInfo } =\n\t\topts;\n\tconst dbUser = await c.context.internalAdapter\n\t\t.findOAuthUser(\n\t\t\tuserInfo.email.toLowerCase(),\n\t\t\taccount.accountId,\n\t\t\taccount.providerId,\n\t\t)\n\t\t.catch((e) => {\n\t\t\tlogger.error(\n\t\t\t\t\"Better auth was unable to query your database.\\nError: \",\n\t\t\t\te,\n\t\t\t);\n\t\t\tconst errorURL =\n\t\t\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\t\t\tthrow c.redirect(`${errorURL}?error=internal_server_error`);\n\t\t});\n\tlet user = dbUser?.user;\n\tconst isRegister = !user;\n\n\tif (dbUser) {\n\t\tconst linkedAccount =\n\t\t\tdbUser.linkedAccount ??\n\t\t\tdbUser.accounts.find(\n\t\t\t\t(acc) =>\n\t\t\t\t\tacc.providerId === account.providerId &&\n\t\t\t\t\tacc.accountId === account.accountId,\n\t\t\t);\n\t\tif (!linkedAccount) {\n\t\t\tconst accountLinking = c.context.options.account?.accountLinking;\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\t\t\tconst isTrustedProvider =\n\t\t\t\topts.isTrustedProvider ||\n\t\t\t\ttrustedProviders?.includes(account.providerId);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !userInfo.emailVerified) ||\n\t\t\t\taccountLinking?.enabled === false ||\n\t\t\t\taccountLinking?.disableImplicitLinking === true\n\t\t\t) {\n\t\t\t\tif (isDevelopment()) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\terror: \"account not linked\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.linkAccount({\n\t\t\t\t\tproviderId: account.providerId,\n\t\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t\t\tuserId: dbUser.user.id,\n\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\tscope: account.scope,\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Unable to link account\", e);\n\t\t\t\treturn {\n\t\t\t\t\terror: \"unable to link account\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst freshTokens =\n\t\t\t\tc.context.options.account?.updateAccountOnSignIn !== false\n\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries({\n\t\t\t\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\t\t\t\trefreshToken: await setTokenUtil(\n\t\t\t\t\t\t\t\t\taccount.refreshToken,\n\t\t\t\t\t\t\t\t\tc.context,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\t\t\t\tscope: account.scope,\n\t\t\t\t\t\t\t}).filter(([_, value]) => value !== undefined),\n\t\t\t\t\t\t)\n\t\t\t\t\t: {};\n\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, {\n\t\t\t\t\t...linkedAccount,\n\t\t\t\t\t...freshTokens,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (Object.keys(freshTokens).length > 0) {\n\t\t\t\tawait c.context.internalAdapter.updateAccount(\n\t\t\t\t\tlinkedAccount.id,\n\t\t\t\t\tfreshTokens,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (overrideUserInfo) {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\t// update user info from the provider if overrideUserInfo is true\n\t\t\tuser = await c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t...restUserInfo,\n\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\temailVerified:\n\t\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t\t\t\t? dbUser.user.emailVerified || userInfo.emailVerified\n\t\t\t\t\t\t: userInfo.emailVerified,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tif (disableSignUp) {\n\t\t\treturn {\n\t\t\t\terror: \"signup disabled\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\tconst accountData = {\n\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\tidToken: account.idToken,\n\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\tscope: account.scope,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t};\n\t\t\tconst { user: createdUser, account: createdAccount } =\n\t\t\t\tawait c.context.internalAdapter.createOAuthUser(\n\t\t\t\t\t{\n\t\t\t\t\t\t...restUserInfo,\n\t\t\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t\taccountData,\n\t\t\t\t);\n\t\t\tuser = createdUser;\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, createdAccount);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!userInfo.emailVerified &&\n\t\t\t\tuser &&\n\t\t\t\tc.context.options.emailVerification?.sendOnSignUp &&\n\t\t\t\tc.context.options.emailVerification?.sendVerificationEmail\n\t\t\t) {\n\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\tc.context.secret,\n\t\t\t\t\tuser.email,\n\t\t\t\t\tundefined,\n\t\t\t\t\tc.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\tconst url = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\tawait c.context.runInBackgroundOrAwait(\n\t\t\t\t\tc.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tc.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (e: any) {\n\t\t\tlogger.error(e);\n\t\t\tif (e instanceof APIError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: e.message,\n\t\t\t\t\tdata: null,\n\t\t\t\t\tisRegister: false,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror: \"unable to create user\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t}\n\tif (!user) {\n\t\treturn {\n\t\t\terror: \"unable to create user\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\tconst session = await c.context.internalAdapter.createSession(user.id);\n\tif (!session) {\n\t\treturn {\n\t\t\terror: \"unable to create session\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\treturn {\n\t\tdata: {\n\t\t\tsession,\n\t\t\tuser,\n\t\t},\n\t\terror: null,\n\t\tisRegister,\n\t};\n}\n","import type { AsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport { getAsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport { __getBetterAuthGlobal } from \"./global\";\n\nexport type RequestStateWeakMap = WeakMap<object, any>;\n\nconst ensureAsyncStorage = async () => {\n\tconst betterAuthGlobal = __getBetterAuthGlobal();\n\tif (!betterAuthGlobal.context.requestStateAsyncStorage) {\n\t\tconst AsyncLocalStorage = await getAsyncLocalStorage();\n\t\tbetterAuthGlobal.context.requestStateAsyncStorage =\n\t\t\tnew AsyncLocalStorage<RequestStateWeakMap>();\n\t}\n\treturn betterAuthGlobal.context\n\t\t.requestStateAsyncStorage as AsyncLocalStorage<RequestStateWeakMap>;\n};\n\nexport async function getRequestStateAsyncLocalStorage() {\n\treturn ensureAsyncStorage();\n}\n\nexport async function hasRequestState() {\n\tconst als = await ensureAsyncStorage();\n\treturn als.getStore() !== undefined;\n}\n\nexport async function getCurrentRequestState(): Promise<RequestStateWeakMap> {\n\tconst als = await ensureAsyncStorage();\n\tconst store = als.getStore();\n\tif (!store) {\n\t\tthrow new Error(\n\t\t\t\"No request state found. Please make sure you are calling this function within a `runWithRequestState` callback.\",\n\t\t);\n\t}\n\treturn store;\n}\n\nexport async function runWithRequestState<T>(\n\tstore: RequestStateWeakMap,\n\tfn: () => T,\n): Promise<T> {\n\tconst als = await ensureAsyncStorage();\n\treturn als.run(store, fn);\n}\n\nexport interface RequestState<T> {\n\tget(): Promise<T>;\n\tset(value: T): Promise<void>;\n\n\t// A unique reference used as a key to identify this state within the request's WeakMap. Useful for debugging purposes.\n\treadonly ref: Readonly<object>;\n}\n\n/**\n * Defines a request-scoped state with lazy initialization.\n *\n * @param initFn - A function that initializes the state. It is called the first time `get()` is invoked within each request context, and only once per context.\n * @returns A RequestState object with `get` and `set` methods, and a unique `ref` for debugging.\n *\n * @example\n * const userState = defineRequestState(() => ({ id: '', name: '' }));\n * // Later, within a request context:\n * const user = await userState.get();\n */\nexport function defineRequestState<T>(\n\tinitFn: () => T | Promise<T>,\n): RequestState<T>;\nexport function defineRequestState(\n\tinitFn: () => any | Promise<any>,\n): RequestState<any> {\n\tconst ref = Object.freeze({});\n\treturn {\n\t\tget ref(): Readonly<object> {\n\t\t\treturn ref;\n\t\t},\n\t\tasync get() {\n\t\t\tconst store = await getCurrentRequestState();\n\t\t\tif (!store.has(ref)) {\n\t\t\t\tconst initialValue = await initFn();\n\t\t\t\tstore.set(ref, initialValue);\n\t\t\t\treturn initialValue;\n\t\t\t}\n\t\t\treturn store.get(ref);\n\t\t},\n\n\t\tasync set(value) {\n\t\t\tconst store = await getCurrentRequestState();\n\t\t\tstore.set(ref, value);\n\t\t},\n\t};\n}\n","import type { AuthContext, BetterAuthOptions } from \"@better-auth/core\";\nimport { runWithAdapter } from \"@better-auth/core/context\";\nimport { BASE_ERROR_CODES, BetterAuthError } from \"@better-auth/core/error\";\nimport { getEndpoints, router } from \"../api\";\nimport { getTrustedOrigins } from \"../context/helpers\";\nimport type { Auth } from \"../types\";\nimport { getBaseURL, getOrigin } from \"../utils/url\";\n\nexport const createBetterAuth = <Options extends BetterAuthOptions>(\n\toptions: Options,\n\tinitFn: (options: Options) => Promise<AuthContext>,\n): Auth<Options> => {\n\tconst authContext = initFn(options);\n\tconst { api } = getEndpoints(authContext, options);\n\tconst errorCodes = options.plugins?.reduce((acc, plugin) => {\n\t\tif (plugin.$ERROR_CODES) {\n\t\t\treturn {\n\t\t\t\t...acc,\n\t\t\t\t...plugin.$ERROR_CODES,\n\t\t\t};\n\t\t}\n\t\treturn acc;\n\t}, {});\n\treturn {\n\t\thandler: async (request: Request) => {\n\t\t\tconst ctx = await authContext;\n\t\t\tconst basePath = ctx.options.basePath || \"/api/auth\";\n\t\t\tif (!ctx.options.baseURL) {\n\t\t\t\tconst baseURL = getBaseURL(\n\t\t\t\t\tundefined,\n\t\t\t\t\tbasePath,\n\t\t\t\t\trequest,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.options.advanced?.trustedProxyHeaders,\n\t\t\t\t);\n\t\t\t\tif (baseURL) {\n\t\t\t\t\tctx.baseURL = baseURL;\n\t\t\t\t\tctx.options.baseURL = getOrigin(ctx.baseURL) || undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Could not get base URL from request. Please provide a valid base URL.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.trustedOrigins = await getTrustedOrigins(ctx.options, request);\n\t\t\tconst { handler } = router(ctx, options);\n\t\t\treturn runWithAdapter(ctx.adapter, () => handler(request));\n\t\t},\n\t\tapi,\n\t\toptions: options,\n\t\t$context: authContext,\n\t\t$ERROR_CODES: {\n\t\t\t...errorCodes,\n\t\t\t...BASE_ERROR_CODES,\n\t\t},\n\t} as any;\n};\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { TelemetryContext } from \"../types\";\n\nexport function getTelemetryAuthConfig(\n\toptions: BetterAuthOptions,\n\tcontext?: TelemetryContext | undefined,\n) {\n\treturn {\n\t\tdatabase: context?.database,\n\t\tadapter: context?.adapter,\n\t\temailVerification: {\n\t\t\tsendVerificationEmail: !!options.emailVerification?.sendVerificationEmail,\n\t\t\tsendOnSignUp: !!options.emailVerification?.sendOnSignUp,\n\t\t\tsendOnSignIn: !!options.emailVerification?.sendOnSignIn,\n\t\t\tautoSignInAfterVerification:\n\t\t\t\t!!options.emailVerification?.autoSignInAfterVerification,\n\t\t\texpiresIn: options.emailVerification?.expiresIn,\n\t\t\tonEmailVerification: !!options.emailVerification?.onEmailVerification,\n\t\t\tafterEmailVerification:\n\t\t\t\t!!options.emailVerification?.afterEmailVerification,\n\t\t},\n\t\temailAndPassword: {\n\t\t\tenabled: !!options.emailAndPassword?.enabled,\n\t\t\tdisableSignUp: !!options.emailAndPassword?.disableSignUp,\n\t\t\trequireEmailVerification:\n\t\t\t\t!!options.emailAndPassword?.requireEmailVerification,\n\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength,\n\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength,\n\t\t\tsendResetPassword: !!options.emailAndPassword?.sendResetPassword,\n\t\t\tresetPasswordTokenExpiresIn:\n\t\t\t\toptions.emailAndPassword?.resetPasswordTokenExpiresIn,\n\t\t\tonPasswordReset: !!options.emailAndPassword?.onPasswordReset,\n\t\t\tpassword: {\n\t\t\t\thash: !!options.emailAndPassword?.password?.hash,\n\t\t\t\tverify: !!options.emailAndPassword?.password?.verify,\n\t\t\t},\n\t\t\tautoSignIn: !!options.emailAndPassword?.autoSignIn,\n\t\t\trevokeSessionsOnPasswordReset:\n\t\t\t\t!!options.emailAndPassword?.revokeSessionsOnPasswordReset,\n\t\t},\n\t\tsocialProviders: Object.keys(options.socialProviders || {}).map((p) => {\n\t\t\tconst provider =\n\t\t\t\toptions.socialProviders?.[p as keyof typeof options.socialProviders];\n\t\t\tif (!provider) return {};\n\t\t\treturn {\n\t\t\t\tid: p,\n\t\t\t\tmapProfileToUser: !!provider.mapProfileToUser,\n\t\t\t\tdisableDefaultScope: !!provider.disableDefaultScope,\n\t\t\t\tdisableIdTokenSignIn: !!provider.disableIdTokenSignIn,\n\t\t\t\tdisableImplicitSignUp: provider.disableImplicitSignUp,\n\t\t\t\tdisableSignUp: provider.disableSignUp,\n\t\t\t\tgetUserInfo: !!provider.getUserInfo,\n\t\t\t\toverrideUserInfoOnSignIn: !!provider.overrideUserInfoOnSignIn,\n\t\t\t\tprompt: provider.prompt,\n\t\t\t\tverifyIdToken: !!provider.verifyIdToken,\n\t\t\t\tscope: provider.scope,\n\t\t\t\trefreshAccessToken: !!provider.refreshAccessToken,\n\t\t\t};\n\t\t}),\n\t\tplugins: options.plugins?.map((p) => p.id.toString()),\n\t\tuser: {\n\t\t\tmodelName: options.user?.modelName,\n\t\t\tfields: options.user?.fields,\n\t\t\tadditionalFields: options.user?.additionalFields,\n\t\t\tchangeEmail: {\n\t\t\t\tenabled: options.user?.changeEmail?.enabled,\n\t\t\t\tsendChangeEmailVerification:\n\t\t\t\t\t!!options.user?.changeEmail?.sendChangeEmailVerification,\n\t\t\t},\n\t\t},\n\t\tverification: {\n\t\t\tmodelName: options.verification?.modelName,\n\t\t\tdisableCleanup: options.verification?.disableCleanup,\n\t\t\tfields: options.verification?.fields,\n\t\t},\n\t\tsession: {\n\t\t\tmodelName: options.session?.modelName,\n\t\t\tadditionalFields: options.session?.additionalFields,\n\t\t\tcookieCache: {\n\t\t\t\tenabled: options.session?.cookieCache?.enabled,\n\t\t\t\tmaxAge: options.session?.cookieCache?.maxAge,\n\t\t\t\tstrategy: options.session?.cookieCache?.strategy,\n\t\t\t},\n\t\t\tdisableSessionRefresh: options.session?.disableSessionRefresh,\n\t\t\texpiresIn: options.session?.expiresIn,\n\t\t\tfields: options.session?.fields,\n\t\t\tfreshAge: options.session?.freshAge,\n\t\t\tpreserveSessionInDatabase: options.session?.preserveSessionInDatabase,\n\t\t\tstoreSessionInDatabase: options.session?.storeSessionInDatabase,\n\t\t\tupdateAge: options.session?.updateAge,\n\t\t},\n\t\taccount: {\n\t\t\tmodelName: options.account?.modelName,\n\t\t\tfields: options.account?.fields,\n\t\t\tencryptOAuthTokens: options.account?.encryptOAuthTokens,\n\t\t\tupdateAccountOnSignIn: options.account?.updateAccountOnSignIn,\n\t\t\taccountLinking: {\n\t\t\t\tenabled: options.account?.accountLinking?.enabled,\n\t\t\t\ttrustedProviders: options.account?.accountLinking?.trustedProviders,\n\t\t\t\tupdateUserInfoOnLink:\n\t\t\t\t\toptions.account?.accountLinking?.updateUserInfoOnLink,\n\t\t\t\tallowUnlinkingAll: options.account?.accountLinking?.allowUnlinkingAll,\n\t\t\t},\n\t\t},\n\t\thooks: {\n\t\t\tafter: !!options.hooks?.after,\n\t\t\tbefore: !!options.hooks?.before,\n\t\t},\n\t\tsecondaryStorage: !!options.secondaryStorage,\n\t\tadvanced: {\n\t\t\tcookiePrefix: !!options.advanced?.cookiePrefix, //this shouldn't be tracked\n\t\t\tcookies: !!options.advanced?.cookies,\n\t\t\tcrossSubDomainCookies: {\n\t\t\t\tdomain: !!options.advanced?.crossSubDomainCookies?.domain,\n\t\t\t\tenabled: options.advanced?.crossSubDomainCookies?.enabled,\n\t\t\t\tadditionalCookies:\n\t\t\t\t\toptions.advanced?.crossSubDomainCookies?.additionalCookies,\n\t\t\t},\n\t\t\tdatabase: {\n\t\t\t\tuseNumberId:\n\t\t\t\t\t!!options.advanced?.database?.useNumberId ||\n\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\",\n\t\t\t\tgenerateId: options.advanced?.database?.generateId,\n\t\t\t\tdefaultFindManyLimit: options.advanced?.database?.defaultFindManyLimit,\n\t\t\t},\n\t\t\tuseSecureCookies: options.advanced?.useSecureCookies,\n\t\t\tipAddress: {\n\t\t\t\tdisableIpTracking: options.advanced?.ipAddress?.disableIpTracking,\n\t\t\t\tipAddressHeaders: options.advanced?.ipAddress?.ipAddressHeaders,\n\t\t\t},\n\t\t\tdisableCSRFCheck: options.advanced?.disableCSRFCheck,\n\t\t\tcookieAttributes: {\n\t\t\t\texpires: options.advanced?.defaultCookieAttributes?.expires,\n\t\t\t\tsecure: options.advanced?.defaultCookieAttributes?.secure,\n\t\t\t\tsameSite: options.advanced?.defaultCookieAttributes?.sameSite,\n\t\t\t\tdomain: !!options.advanced?.defaultCookieAttributes?.domain,\n\t\t\t\tpath: options.advanced?.defaultCookieAttributes?.path,\n\t\t\t\thttpOnly: options.advanced?.defaultCookieAttributes?.httpOnly,\n\t\t\t},\n\t\t},\n\t\ttrustedOrigins: options.trustedOrigins?.length,\n\t\trateLimit: {\n\t\t\tstorage: options.rateLimit?.storage,\n\t\t\tmodelName: options.rateLimit?.modelName,\n\t\t\twindow: options.rateLimit?.window,\n\t\t\tcustomStorage: !!options.rateLimit?.customStorage,\n\t\t\tenabled: options.rateLimit?.enabled,\n\t\t\tmax: options.rateLimit?.max,\n\t\t},\n\t\tonAPIError: {\n\t\t\terrorURL: options.onAPIError?.errorURL,\n\t\t\tonError: !!options.onAPIError?.onError,\n\t\t\tthrow: options.onAPIError?.throw,\n\t\t},\n\t\tlogger: {\n\t\t\tdisabled: options.logger?.disabled,\n\t\t\tlevel: options.logger?.level,\n\t\t\tlog: !!options.logger?.log,\n\t\t},\n\t\tdatabaseHooks: {\n\t\t\tuser: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.user?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.user?.create?.before,\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.user?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.user?.update?.before,\n\t\t\t\t},\n\t\t\t},\n\t\t\tsession: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.session?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.session?.create?.before,\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.session?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.session?.update?.before,\n\t\t\t\t},\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.account?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.account?.create?.before,\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.account?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.account?.update?.before,\n\t\t\t\t},\n\t\t\t},\n\t\t\tverification: {\n\t\t\t\tcreate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.verification?.create?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.verification?.create?.before,\n\t\t\t\t},\n\t\t\t\tupdate: {\n\t\t\t\t\tafter: !!options.databaseHooks?.verification?.update?.after,\n\t\t\t\t\tbefore: !!options.databaseHooks?.verification?.update?.before,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n}\n","import { BetterAuthError } from \"@better-auth/core/error\";\nimport { getKyselyDatabaseType } from \"../adapters/kysely-adapter/dialect\";\nimport { getAdapter } from \"../db/adapter-kysely\";\nimport { getMigrations } from \"../db/get-migration\";\nimport type { BetterAuthOptions } from \"../types\";\nimport { createAuthContext } from \"./create-context\";\n\nexport const init = async (options: BetterAuthOptions) => {\n\tconst adapter = await getAdapter(options);\n\n\t// Get database type using Kysely's dialect detection\n\tconst getDatabaseType = (database: BetterAuthOptions[\"database\"]) =>\n\t\tgetKyselyDatabaseType(database) || \"unknown\";\n\n\t// Use base context creation\n\tconst ctx = await createAuthContext(adapter, options, getDatabaseType);\n\n\t// Add runMigrations with Kysely support\n\tctx.runMigrations = async function () {\n\t\t// only run migrations if database is provided and it's not an adapter\n\t\tif (!options.database || \"updateMany\" in options.database) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Database is not provided or it's an adapter. Migrations are only supported with a database instance.\",\n\t\t\t);\n\t\t}\n\t\tconst { runMigrations } = await getMigrations(options);\n\t\tawait runMigrations();\n\t};\n\n\treturn ctx;\n};\n","import type {\n\tAuthContext,\n\tBetterAuthRateLimitStorage,\n} from \"@better-auth/core\";\nimport {\n\tcreateRateLimitKey,\n\tnormalizePathname,\n\tsafeJSONParse,\n} from \"@better-auth/core/utils\";\nimport type { RateLimit } from \"../../types\";\nimport { getIp } from \"../../utils/get-request-ip\";\nimport { wildcardMatch } from \"../../utils/wildcard\";\n\ninterface MemoryRateLimitEntry {\n\tdata: RateLimit;\n\texpiresAt: number;\n}\n\nconst memory = new Map<string, MemoryRateLimitEntry>();\n\nfunction shouldRateLimit(\n\tmax: number,\n\twindow: number,\n\trateLimitData: RateLimit,\n) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1000;\n\tconst timeSinceLastRequest = now - rateLimitData.lastRequest;\n\treturn timeSinceLastRequest < windowInMs && rateLimitData.count >= max;\n}\n\nfunction rateLimitResponse(retryAfter: number) {\n\treturn new Response(\n\t\tJSON.stringify({\n\t\t\tmessage: \"Too many requests. Please try again later.\",\n\t\t}),\n\t\t{\n\t\t\tstatus: 429,\n\t\t\tstatusText: \"Too Many Requests\",\n\t\t\theaders: {\n\t\t\t\t\"X-Retry-After\": retryAfter.toString(),\n\t\t\t},\n\t\t},\n\t);\n}\n\nfunction getRetryAfter(lastRequest: number, window: number) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1000;\n\treturn Math.ceil((lastRequest + windowInMs - now) / 1000);\n}\n\nfunction createDatabaseStorageWrapper(\n\tctx: AuthContext,\n): BetterAuthRateLimitStorage {\n\tconst model = \"rateLimit\";\n\tconst db = ctx.adapter;\n\treturn {\n\t\tget: async (key: string) => {\n\t\t\tconst res = await db.findMany<RateLimit>({\n\t\t\t\tmodel,\n\t\t\t\twhere: [{ field: \"key\", value: key }],\n\t\t\t});\n\t\t\tconst data = res[0];\n\n\t\t\tif (typeof data?.lastRequest === \"bigint\") {\n\t\t\t\tdata.lastRequest = Number(data.lastRequest);\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\t\tset: async (\n\t\t\tkey: string,\n\t\t\tvalue: RateLimit,\n\t\t\t_update?: boolean | undefined,\n\t\t) => {\n\t\t\ttry {\n\t\t\t\tif (_update) {\n\t\t\t\t\tawait db.updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere: [{ field: \"key\", value: key }],\n\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\t\tlastRequest: value.lastRequest,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait db.create({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\t\tlastRequest: value.lastRequest,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tctx.logger.error(\"Error setting rate limit\", e);\n\t\t\t}\n\t\t},\n\t};\n}\n\nfunction getRateLimitStorage(\n\tctx: AuthContext,\n\trateLimitSettings: {\n\t\twindow: number;\n\t},\n): BetterAuthRateLimitStorage {\n\tif (ctx.options.rateLimit?.customStorage) {\n\t\treturn ctx.options.rateLimit.customStorage;\n\t}\n\tconst storage = ctx.rateLimit.storage;\n\tif (storage === \"secondary-storage\") {\n\t\treturn {\n\t\t\tget: async (key: string) => {\n\t\t\t\tconst data = await ctx.options.secondaryStorage?.get(key);\n\t\t\t\treturn data ? safeJSONParse<RateLimit>(data) : null;\n\t\t\t},\n\t\t\tset: async (\n\t\t\t\tkey: string,\n\t\t\t\tvalue: RateLimit,\n\t\t\t\t_update?: boolean | undefined,\n\t\t\t) => {\n\t\t\t\tconst ttl =\n\t\t\t\t\trateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;\n\t\t\t\tawait ctx.options.secondaryStorage?.set?.(\n\t\t\t\t\tkey,\n\t\t\t\t\tJSON.stringify(value),\n\t\t\t\t\tttl,\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t} else if (storage === \"memory\") {\n\t\treturn {\n\t\t\tasync get(key: string) {\n\t\t\t\tconst entry = memory.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Check if entry has expired\n\t\t\t\tif (Date.now() >= entry.expiresAt) {\n\t\t\t\t\tmemory.delete(key);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn entry.data;\n\t\t\t},\n\t\t\tasync set(key: string, value: RateLimit, _update?: boolean | undefined) {\n\t\t\t\tconst ttl =\n\t\t\t\t\trateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;\n\t\t\t\tconst expiresAt = Date.now() + ttl * 1000;\n\t\t\t\tmemory.set(key, {\n\t\t\t\t\tdata: value,\n\t\t\t\t\texpiresAt,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\treturn createDatabaseStorageWrapper(ctx);\n}\n\nexport async function onRequestRateLimit(req: Request, ctx: AuthContext) {\n\tif (!ctx.rateLimit.enabled) {\n\t\treturn;\n\t}\n\tconst basePath = new URL(ctx.baseURL).pathname;\n\tconst path = normalizePathname(req.url, basePath);\n\tlet currentWindow = ctx.rateLimit.window;\n\tlet currentMax = ctx.rateLimit.max;\n\tconst ip = getIp(req, ctx.options);\n\tif (!ip) {\n\t\treturn;\n\t}\n\tconst key = createRateLimitKey(ip, path);\n\tconst specialRules = getDefaultSpecialRules();\n\tconst specialRule = specialRules.find((rule) => rule.pathMatcher(path));\n\n\tif (specialRule) {\n\t\tcurrentWindow = specialRule.window;\n\t\tcurrentMax = specialRule.max;\n\t}\n\n\tfor (const plugin of ctx.options.plugins || []) {\n\t\tif (plugin.rateLimit) {\n\t\t\tconst matchedRule = plugin.rateLimit.find((rule) =>\n\t\t\t\trule.pathMatcher(path),\n\t\t\t);\n\t\t\tif (matchedRule) {\n\t\t\t\tcurrentWindow = matchedRule.window;\n\t\t\t\tcurrentMax = matchedRule.max;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx.rateLimit.customRules) {\n\t\tconst _path = Object.keys(ctx.rateLimit.customRules).find((p) => {\n\t\t\tif (p.includes(\"*\")) {\n\t\t\t\tconst isMatch = wildcardMatch(p)(path);\n\t\t\t\treturn isMatch;\n\t\t\t}\n\t\t\treturn p === path;\n\t\t});\n\t\tif (_path) {\n\t\t\tconst customRule = ctx.rateLimit.customRules[_path];\n\t\t\tconst resolved =\n\t\t\t\ttypeof customRule === \"function\"\n\t\t\t\t\t? await customRule(req, {\n\t\t\t\t\t\t\twindow: currentWindow,\n\t\t\t\t\t\t\tmax: currentMax,\n\t\t\t\t\t\t})\n\t\t\t\t\t: customRule;\n\t\t\tif (resolved) {\n\t\t\t\tcurrentWindow = resolved.window;\n\t\t\t\tcurrentMax = resolved.max;\n\t\t\t}\n\n\t\t\tif (resolved === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst storage = getRateLimitStorage(ctx, {\n\t\twindow: currentWindow,\n\t});\n\tconst data = await storage.get(key);\n\tconst now = Date.now();\n\n\tif (!data) {\n\t\tawait storage.set(key, {\n\t\t\tkey,\n\t\t\tcount: 1,\n\t\t\tlastRequest: now,\n\t\t});\n\t} else {\n\t\tconst timeSinceLastRequest = now - data.lastRequest;\n\n\t\tif (shouldRateLimit(currentMax, currentWindow, data)) {\n\t\t\tconst retryAfter = getRetryAfter(data.lastRequest, currentWindow);\n\t\t\treturn rateLimitResponse(retryAfter);\n\t\t} else if (timeSinceLastRequest > currentWindow * 1000) {\n\t\t\t// Reset the count if the window has passed since the last request\n\t\t\tawait storage.set(\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\t...data,\n\t\t\t\t\tcount: 1,\n\t\t\t\t\tlastRequest: now,\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t);\n\t\t} else {\n\t\t\tawait storage.set(\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\t...data,\n\t\t\t\t\tcount: data.count + 1,\n\t\t\t\t\tlastRequest: now,\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t}\n}\n\nfunction getDefaultSpecialRules() {\n\tconst specialRules = [\n\t\t{\n\t\t\tpathMatcher(path: string) {\n\t\t\t\treturn (\n\t\t\t\t\tpath.startsWith(\"/sign-in\") ||\n\t\t\t\t\tpath.startsWith(\"/sign-up\") ||\n\t\t\t\t\tpath.startsWith(\"/change-password\") ||\n\t\t\t\t\tpath.startsWith(\"/change-email\")\n\t\t\t\t);\n\t\t\t},\n\t\t\twindow: 10,\n\t\t\tmax: 3,\n\t\t},\n\t];\n\treturn specialRules;\n}\n","import type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport type { ZodType } from \"zod\";\nimport * as z from \"zod\";\n\nexport function toZodSchema<\n\tFields extends Record<string, DBFieldAttribute | never>,\n\tIsClientSide extends boolean,\n>({\n\tfields,\n\tisClientSide,\n}: {\n\tfields: Fields;\n\t/**\n\t * If true, then any fields that have `input: false` will be removed from the schema to prevent user input.\n\t */\n\tisClientSide: IsClientSide;\n}) {\n\tconst zodFields = Object.keys(fields).reduce((acc, key) => {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\treturn acc;\n\t\t}\n\t\tif (isClientSide && field.input === false) {\n\t\t\treturn acc;\n\t\t}\n\n\t\tlet schema: ZodType;\n\t\tif (field.type === \"json\") {\n\t\t\tschema = (z as any).json ? (z as any).json() : z.any();\n\t\t} else if (field.type === \"string[]\" || field.type === \"number[]\") {\n\t\t\tschema = z.array(field.type === \"string[]\" ? z.string() : z.number());\n\t\t} else if (Array.isArray(field.type)) {\n\t\t\tschema = z.any();\n\t\t} else {\n\t\t\tschema = z[field.type]();\n\t\t}\n\n\t\tif (field?.required === false) {\n\t\t\tschema = schema.optional();\n\t\t}\n\t\tif (!isClientSide && field?.returned === false) {\n\t\t\treturn acc;\n\t\t}\n\t\treturn {\n\t\t\t...acc,\n\t\t\t[key]: schema,\n\t\t};\n\t}, {});\n\tconst schema = z.object(zodFields);\n\treturn schema as z.ZodObject<\n\t\tRemoveNeverProps<{\n\t\t\t[key in keyof Fields]: FieldAttributeToSchema<Fields[key], IsClientSide>;\n\t\t}>,\n\t\tz.core.$strip\n\t>;\n}\n\nexport type FieldAttributeToSchema<\n\tField extends DBFieldAttribute | Record<string, never>,\n\t// if it's client side, then field attributes of `input` that are false should be removed\n\tisClientSide extends boolean = false,\n> = Field extends { type: any }\n\t? GetInput<isClientSide, Field, GetRequired<Field, GetType<Field>>>\n\t: Record<string, never>;\n\ntype GetType<F extends DBFieldAttribute> = F extends {\n\ttype: \"string\";\n}\n\t? z.ZodString\n\t: F extends { type: \"number\" }\n\t\t? z.ZodNumber\n\t\t: F extends { type: \"boolean\" }\n\t\t\t? z.ZodBoolean\n\t\t\t: F extends { type: \"date\" }\n\t\t\t\t? z.ZodDate\n\t\t\t\t: z.ZodAny;\n\ntype GetRequired<\n\tF extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = F extends {\n\trequired: true;\n}\n\t? Schema\n\t: z.ZodOptional<Schema>;\n\ntype GetInput<\n\tisClientSide extends boolean,\n\tField extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = Field extends {\n\tinput: false;\n}\n\t? isClientSide extends true\n\t\t? never\n\t\t: Schema\n\t: Schema;\n\ntype RemoveNeverProps<T> = {\n\t[K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\n","import { decode as b64u } from '../../util/base64url.js';\nimport { verify } from '../../lib/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder, encode } from '../../lib/buffer_utils.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { isObject } from '../../lib/is_object.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { validateAlgorithms } from '../../lib/validate_algorithms.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = b64u(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(jws.protected !== undefined ? encode(jws.protected) : new Uint8Array(), encode('.'), typeof jws.payload === 'string'\n        ? b64\n            ? encode(jws.payload)\n            : encoder.encode(jws.payload)\n        : jws.payload);\n    let signature;\n    try {\n        signature = b64u(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const k = await normalizeKey(key, alg);\n    const verified = await verify(alg, k, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = b64u(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key: k };\n    }\n    return result;\n}\n","import { encode as b64u } from '../../util/base64url.js';\nimport { unprotected } from '../../lib/private_symbols.js';\nimport { encrypt } from '../../lib/encrypt.js';\nimport { encryptKeyManagement } from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { concat, encode } from '../../lib/buffer_utils.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nexport class FlattenedEncrypt {\n    #plaintext;\n    #protectedHeader;\n    #sharedUnprotectedHeader;\n    #unprotectedHeader;\n    #aad;\n    #cek;\n    #iv;\n    #keyManagementParameters;\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this.#plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this.#keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this.#keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this.#sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this.#sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this.#aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this.#cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this.#cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this.#iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this.#iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader && !this.#sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader, this.#sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n            ...this.#sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options?.crit, this.#protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (this.#cek && (alg === 'dir' || alg === 'ECDH-ES')) {\n            throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${alg}`);\n        }\n        checkKeyType(alg === 'dir' ? enc : alg, key, 'encrypt');\n        let cek;\n        {\n            let parameters;\n            const k = await normalizeKey(key, alg);\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, k, this.#cek, this.#keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this.#unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this.#unprotectedHeader = { ...this.#unprotectedHeader, ...parameters };\n                    }\n                }\n                else if (!this.#protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                }\n                else {\n                    this.#protectedHeader = { ...this.#protectedHeader, ...parameters };\n                }\n            }\n        }\n        let additionalData;\n        let protectedHeaderS;\n        let protectedHeaderB;\n        let aadMember;\n        if (this.#protectedHeader) {\n            protectedHeaderS = b64u(JSON.stringify(this.#protectedHeader));\n            protectedHeaderB = encode(protectedHeaderS);\n        }\n        else {\n            protectedHeaderS = '';\n            protectedHeaderB = new Uint8Array();\n        }\n        if (this.#aad) {\n            aadMember = b64u(this.#aad);\n            const aadMemberBytes = encode(aadMember);\n            additionalData = concat(protectedHeaderB, encode('.'), aadMemberBytes);\n        }\n        else {\n            additionalData = protectedHeaderB;\n        }\n        const { ciphertext, tag, iv } = await encrypt(enc, this.#plaintext, cek, this.#iv, additionalData);\n        const jwe = {\n            ciphertext: b64u(ciphertext),\n        };\n        if (iv) {\n            jwe.iv = b64u(iv);\n        }\n        if (tag) {\n            jwe.tag = b64u(tag);\n        }\n        if (encryptedKey) {\n            jwe.encrypted_key = b64u(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this.#protectedHeader) {\n            jwe.protected = protectedHeaderS;\n        }\n        if (this.#sharedUnprotectedHeader) {\n            jwe.unprotected = this.#sharedUnprotectedHeader;\n        }\n        if (this.#unprotectedHeader) {\n            jwe.header = this.#unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { refreshAccessToken, validateAuthorizationCode } from \"../oauth2\";\n\nexport interface SlackProfile extends Record<string, any> {\n\tok: boolean;\n\tsub: string;\n\t\"https://slack.com/user_id\": string;\n\t\"https://slack.com/team_id\": string;\n\temail: string;\n\temail_verified: boolean;\n\tdate_email_verified: number;\n\tname: string;\n\tpicture: string;\n\tgiven_name: string;\n\tfamily_name: string;\n\tlocale: string;\n\t\"https://slack.com/team_name\": string;\n\t\"https://slack.com/team_domain\": string;\n\t\"https://slack.com/user_image_24\": string;\n\t\"https://slack.com/user_image_32\": string;\n\t\"https://slack.com/user_image_48\": string;\n\t\"https://slack.com/user_image_72\": string;\n\t\"https://slack.com/user_image_192\": string;\n\t\"https://slack.com/user_image_512\": string;\n\t\"https://slack.com/team_image_34\": string;\n\t\"https://slack.com/team_image_44\": string;\n\t\"https://slack.com/team_image_68\": string;\n\t\"https://slack.com/team_image_88\": string;\n\t\"https://slack.com/team_image_102\": string;\n\t\"https://slack.com/team_image_132\": string;\n\t\"https://slack.com/team_image_230\": string;\n\t\"https://slack.com/team_image_default\": boolean;\n}\n\nexport interface SlackOptions extends ProviderOptions<SlackProfile> {\n\tclientId: string;\n}\n\nexport const slack = (options: SlackOptions) => {\n\treturn {\n\t\tid: \"slack\",\n\t\tname: \"Slack\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\"];\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tconst url = new URL(\"https://slack.com/openid/connect/authorize\");\n\t\t\turl.searchParams.set(\"scope\", _scopes.join(\" \"));\n\t\t\turl.searchParams.set(\"response_type\", \"code\");\n\t\t\turl.searchParams.set(\"client_id\", options.clientId);\n\t\t\turl.searchParams.set(\"redirect_uri\", options.redirectURI || redirectURI);\n\t\t\turl.searchParams.set(\"state\", state);\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://slack.com/api/openid.connect.token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://slack.com/api/openid.connect.token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<SlackProfile>(\n\t\t\t\t\"https://slack.com/api/openid.connect.userInfo\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile[\"https://slack.com/user_id\"],\n\t\t\t\t\tname: profile.name || \"\",\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\timage: profile.picture || profile[\"https://slack.com/user_image_512\"],\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<SlackProfile>;\n};\n","import * as aeskw from './aeskw.js';\nimport * as ecdhes from './ecdhes.js';\nimport * as pbes2kw from './pbes2kw.js';\nimport * as rsaes from './rsaes.js';\nimport { decode as b64u } from '../util/base64url.js';\nimport { JOSENotSupported, JWEInvalid } from '../util/errors.js';\nimport { cekLength } from '../lib/cek.js';\nimport { importJWK } from '../key/import.js';\nimport { isObject } from './is_object.js';\nimport { unwrap as aesGcmKw } from './aesgcmkw.js';\nimport { assertCryptoKey } from './is_key_like.js';\nexport async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!isObject(joseHeader.epk))\n                throw new JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            assertCryptoKey(key);\n            if (!ecdhes.allowed(key))\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await importJWK(joseHeader.epk, alg);\n            assertCryptoKey(epk);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                try {\n                    partyUInfo = b64u(joseHeader.apu);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apu');\n                }\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                try {\n                    partyVInfo = b64u(joseHeader.apv);\n                }\n                catch {\n                    throw new JWEInvalid('Failed to base64url decode the apv');\n                }\n            }\n            const sharedSecret = await ecdhes.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? cekLength(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aeskw.unwrap(alg.slice(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            assertCryptoKey(key);\n            return rsaes.decrypt(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            const p2cLimit = options?.maxPBES2Count || 10_000;\n            if (joseHeader.p2c > p2cLimit)\n                throw new JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            let p2s;\n            try {\n                p2s = b64u(joseHeader.p2s);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the p2s');\n            }\n            return pbes2kw.unwrap(alg, key, encryptedKey, joseHeader.p2c, p2s);\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            return aeskw.unwrap(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            let iv;\n            try {\n                iv = b64u(joseHeader.iv);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the iv');\n            }\n            let tag;\n            try {\n                tag = b64u(joseHeader.tag);\n            }\n            catch {\n                throw new JWEInvalid('Failed to base64url decode the tag');\n            }\n            return aesGcmKw(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\n","import * as aeskw from './aeskw.js';\nimport * as ecdhes from './ecdhes.js';\nimport * as pbes2kw from './pbes2kw.js';\nimport * as rsaes from './rsaes.js';\nimport { encode as b64u } from '../util/base64url.js';\nimport { normalizeKey } from './normalize_key.js';\nimport { generateCek, cekLength } from '../lib/cek.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { exportJWK } from '../key/export.js';\nimport { wrap as aesGcmKw } from './aesgcmkw.js';\nimport { assertCryptoKey } from './is_key_like.js';\nexport async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            assertCryptoKey(key);\n            if (!ecdhes.allowed(key)) {\n                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let ephemeralKey;\n            if (providedParameters.epk) {\n                ephemeralKey = (await normalizeKey(providedParameters.epk, alg));\n            }\n            else {\n                ephemeralKey = (await crypto.subtle.generateKey(key.algorithm, true, ['deriveBits'])).privateKey;\n            }\n            const { x, y, crv, kty } = await exportJWK(ephemeralKey);\n            const sharedSecret = await ecdhes.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? cekLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);\n            parameters = { epk: { x, crv, kty } };\n            if (kty === 'EC')\n                parameters.epk.y = y;\n            if (apu)\n                parameters.apu = b64u(apu);\n            if (apv)\n                parameters.apv = b64u(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || generateCek(enc);\n            const kwAlg = alg.slice(-6);\n            encryptedKey = await aeskw.wrap(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || generateCek(enc);\n            assertCryptoKey(key);\n            encryptedKey = await rsaes.encrypt(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || generateCek(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await pbes2kw.wrap(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || generateCek(enc);\n            encryptedKey = await aeskw.wrap(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || generateCek(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await aesGcmKw(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\n","import type { EndpointOptions } from \"./endpoint\";\nimport { type statusCodes, APIError, ValidationError, type Status } from \"./error\";\nimport type {\n\tInferParamPath,\n\tInferParamWildCard,\n\tIsEmptyObject,\n\tPrettify,\n\tUnionToIntersection,\n} from \"./helper\";\nimport type { Middleware, MiddlewareContext, MiddlewareOptions } from \"./middleware\";\nimport { runValidation } from \"./validator\";\nimport {\n\tgetCookieKey,\n\tparseCookies,\n\tserializeCookie,\n\tserializeSignedCookie,\n\ttype CookieOptions,\n\ttype CookiePrefixOptions,\n} from \"./cookies\";\nimport { getCryptoKey, verifySignature } from \"./crypto\";\nimport type { StandardSchemaV1 } from \"./standard-schema\";\nimport { isRequest } from \"./utils\";\n\nexport type HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\nexport type Method = HTTPMethod | \"*\";\n\nexport type InferBodyInput<\n\tOptions extends EndpointOptions | MiddlewareOptions,\n\tBody = Options[\"metadata\"] extends {\n\t\t$Infer: {\n\t\t\tbody: infer B;\n\t\t};\n\t}\n\t\t? B\n\t\t: Options[\"body\"] extends StandardSchemaV1\n\t\t\t? StandardSchemaV1.InferInput<Options[\"body\"]>\n\t\t\t: undefined,\n> = undefined extends Body\n\t? {\n\t\t\tbody?: Body;\n\t\t}\n\t: {\n\t\t\tbody: Body;\n\t\t};\n\nexport type InferBody<Options extends EndpointOptions | MiddlewareOptions> =\n\tOptions[\"metadata\"] extends {\n\t\t$Infer: {\n\t\t\tbody: infer Body;\n\t\t};\n\t}\n\t\t? Body\n\t\t: Options[\"body\"] extends StandardSchemaV1\n\t\t\t? StandardSchemaV1.InferOutput<Options[\"body\"]>\n\t\t\t: any;\n\nexport type InferQueryInput<\n\tOptions extends EndpointOptions | MiddlewareOptions,\n\tQuery = Options[\"metadata\"] extends {\n\t\t$Infer: {\n\t\t\tquery: infer Query;\n\t\t};\n\t}\n\t\t? Query\n\t\t: Options[\"query\"] extends StandardSchemaV1\n\t\t\t? StandardSchemaV1.InferInput<Options[\"query\"]>\n\t\t\t: Record<string, any> | undefined,\n> = undefined extends Query\n\t? {\n\t\t\tquery?: Query;\n\t\t}\n\t: {\n\t\t\tquery: Query;\n\t\t};\n\nexport type InferQuery<Options extends EndpointOptions | MiddlewareOptions> =\n\tOptions[\"metadata\"] extends {\n\t\t$Infer: {\n\t\t\tquery: infer Query;\n\t\t};\n\t}\n\t\t? Query\n\t\t: Options[\"query\"] extends StandardSchemaV1\n\t\t\t? StandardSchemaV1.InferOutput<Options[\"query\"]>\n\t\t\t: Record<string, any> | undefined;\n\nexport type InferMethod<Options extends EndpointOptions> = Options[\"method\"] extends Array<Method>\n\t? Options[\"method\"][number]\n\t: Options[\"method\"] extends \"*\"\n\t\t? HTTPMethod\n\t\t: Options[\"method\"];\n\nexport type InferInputMethod<\n\tOptions extends EndpointOptions,\n\tMethod = Options[\"method\"] extends Array<any>\n\t\t? Options[\"method\"][number] | undefined\n\t\t: Options[\"method\"] extends \"*\"\n\t\t\t? HTTPMethod\n\t\t\t: Options[\"method\"] | undefined,\n> = undefined extends Method\n\t? {\n\t\t\tmethod?: Method;\n\t\t}\n\t: {\n\t\t\tmethod: Method;\n\t\t};\n\nexport type InferParam<Path extends string> = [Path] extends [never]\n\t? Record<string, any> | undefined\n\t: IsEmptyObject<InferParamPath<Path> & InferParamWildCard<Path>> extends true\n\t\t? Record<string, any> | undefined\n\t\t: Prettify<InferParamPath<Path> & InferParamWildCard<Path>>;\n\nexport type InferParamInput<Path extends string> = [Path] extends [never]\n\t? { params?: Record<string, any> }\n\t: IsEmptyObject<InferParamPath<Path> & InferParamWildCard<Path>> extends true\n\t\t? {\n\t\t\t\tparams?: Record<string, any>;\n\t\t\t}\n\t\t: {\n\t\t\t\tparams: Prettify<InferParamPath<Path> & InferParamWildCard<Path>>;\n\t\t\t};\n\nexport type InferRequest<Option extends EndpointOptions | MiddlewareOptions> =\n\tOption[\"requireRequest\"] extends true ? Request : Request | undefined;\n\nexport type InferRequestInput<Option extends EndpointOptions | MiddlewareOptions> =\n\tOption[\"requireRequest\"] extends true\n\t\t? {\n\t\t\t\trequest: Request;\n\t\t\t}\n\t\t: {\n\t\t\t\trequest?: Request;\n\t\t\t};\n\nexport type InferHeaders<Option extends EndpointOptions | MiddlewareOptions> =\n\tOption[\"requireHeaders\"] extends true ? Headers : Headers | undefined;\n\nexport type InferHeadersInput<Option extends EndpointOptions | MiddlewareOptions> =\n\tOption[\"requireHeaders\"] extends true\n\t\t? {\n\t\t\t\theaders: HeadersInit;\n\t\t\t}\n\t\t: {\n\t\t\t\theaders?: HeadersInit;\n\t\t\t};\n\nexport type InferUse<Opts extends EndpointOptions[\"use\"]> = Opts extends Middleware[]\n\t? UnionToIntersection<Awaited<ReturnType<Opts[number]>>>\n\t: {};\n\nexport type InferMiddlewareBody<Options extends MiddlewareOptions> =\n\tOptions[\"body\"] extends StandardSchemaV1<infer T> ? T : any;\n\nexport type InferMiddlewareQuery<Options extends MiddlewareOptions> =\n\tOptions[\"query\"] extends StandardSchemaV1<infer T> ? T : Record<string, any> | undefined;\n\nexport type InputContext<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n> = InferBodyInput<Options> &\n\tInferInputMethod<Options> &\n\tInferQueryInput<Options> &\n\tInferParamInput<Path> &\n\tInferRequestInput<Options> &\n\tInferHeadersInput<Options> & {\n\t\tasResponse?: boolean;\n\t\treturnHeaders?: boolean;\n\t\treturnStatus?: boolean;\n\t\tuse?: Middleware[];\n\t\tpath?: string;\n\t};\n\nexport const createInternalContext = async (\n\tcontext: InputContext<any, any>,\n\t{\n\t\toptions,\n\t\tpath,\n\t}: {\n\t\toptions: EndpointOptions;\n\t\tpath?: string;\n\t},\n) => {\n\tconst headers = new Headers();\n\tlet responseStatus: Status | undefined = undefined;\n\n\tconst { data, error } = await runValidation(options, context);\n\tif (error) {\n\t\tthrow new ValidationError(error.message, error.issues);\n\t}\n\tconst requestHeaders: Headers | null =\n\t\t\"headers\" in context\n\t\t\t? context.headers instanceof Headers\n\t\t\t\t? context.headers\n\t\t\t\t: new Headers(context.headers)\n\t\t\t: \"request\" in context && isRequest(context.request)\n\t\t\t\t? context.request.headers\n\t\t\t\t: null;\n\tconst requestCookies = requestHeaders?.get(\"cookie\");\n\tconst parsedCookies = requestCookies ? parseCookies(requestCookies) : undefined;\n\n\tconst internalContext = {\n\t\t...context,\n\t\tbody: data.body,\n\t\tquery: data.query,\n\t\tpath: context.path || path || \"virtual:\",\n\t\tcontext: \"context\" in context && context.context ? context.context : {},\n\t\treturned: undefined as any,\n\t\theaders: context?.headers,\n\t\trequest: context?.request,\n\t\tparams: \"params\" in context ? context.params : undefined,\n\t\tmethod:\n\t\t\tcontext.method ??\n\t\t\t(Array.isArray(options.method)\n\t\t\t\t? options.method[0]\n\t\t\t\t: options.method === \"*\"\n\t\t\t\t\t? \"GET\"\n\t\t\t\t\t: options.method),\n\t\tsetHeader: (key: string, value: string) => {\n\t\t\theaders.set(key, value);\n\t\t},\n\t\tgetHeader: (key: string) => {\n\t\t\tif (!requestHeaders) return null;\n\t\t\treturn requestHeaders.get(key);\n\t\t},\n\t\tgetCookie: (key: string, prefix?: CookiePrefixOptions) => {\n\t\t\tconst finalKey = getCookieKey(key, prefix);\n\t\t\tif (!finalKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn parsedCookies?.get(finalKey) || null;\n\t\t},\n\t\tgetSignedCookie: async (key: string, secret: string, prefix?: CookiePrefixOptions) => {\n\t\t\tconst finalKey = getCookieKey(key, prefix);\n\t\t\tif (!finalKey) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst value = parsedCookies?.get(finalKey);\n\t\t\tif (!value) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst signatureStartPos = value.lastIndexOf(\".\");\n\t\t\tif (signatureStartPos < 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst signedValue = value.substring(0, signatureStartPos);\n\t\t\tconst signature = value.substring(signatureStartPos + 1);\n\t\t\tif (signature.length !== 44 || !signature.endsWith(\"=\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst secretKey = await getCryptoKey(secret);\n\t\t\tconst isVerified = await verifySignature(signature, signedValue, secretKey);\n\t\t\treturn isVerified ? signedValue : false;\n\t\t},\n\t\tsetCookie: (key: string, value: string, options?: CookieOptions) => {\n\t\t\tconst cookie = serializeCookie(key, value, options);\n\t\t\theaders.append(\"set-cookie\", cookie);\n\t\t\treturn cookie;\n\t\t},\n\t\tsetSignedCookie: async (\n\t\t\tkey: string,\n\t\t\tvalue: string,\n\t\t\tsecret: string,\n\t\t\toptions?: CookieOptions,\n\t\t) => {\n\t\t\tconst cookie = await serializeSignedCookie(key, value, secret, options);\n\t\t\theaders.append(\"set-cookie\", cookie);\n\t\t\treturn cookie;\n\t\t},\n\t\tredirect: (url: string) => {\n\t\t\theaders.set(\"location\", url);\n\t\t\treturn new APIError(\"FOUND\", undefined, headers);\n\t\t},\n\t\terror: (\n\t\t\tstatus: keyof typeof statusCodes | Status,\n\t\t\tbody?:\n\t\t\t\t| {\n\t\t\t\t\t\tmessage?: string;\n\t\t\t\t\t\tcode?: string;\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\theaders?: HeadersInit,\n\t\t) => {\n\t\t\treturn new APIError(status, body, headers);\n\t\t},\n\t\tsetStatus: (status: Status) => {\n\t\t\tresponseStatus = status;\n\t\t},\n\t\tjson: (\n\t\t\tjson: Record<string, any>,\n\t\t\trouterResponse?:\n\t\t\t\t| {\n\t\t\t\t\t\tstatus?: number;\n\t\t\t\t\t\theaders?: Record<string, string>;\n\t\t\t\t\t\tresponse?: Response;\n\t\t\t\t\t\tbody?: Record<string, any>;\n\t\t\t\t  }\n\t\t\t\t| Response,\n\t\t) => {\n\t\t\tif (!context.asResponse) {\n\t\t\t\treturn json;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tbody: routerResponse?.body || json,\n\t\t\t\trouterResponse,\n\t\t\t\t_flag: \"json\",\n\t\t\t};\n\t\t},\n\t\tresponseHeaders: headers,\n\t\tget responseStatus() {\n\t\t\treturn responseStatus;\n\t\t},\n\t};\n\t//if context was shimmed through the input we want to apply it\n\tfor (const middleware of options.use || []) {\n\t\tconst response = (await middleware({\n\t\t\t...internalContext,\n\t\t\treturnHeaders: true,\n\t\t\tasResponse: false,\n\t\t})) as {\n\t\t\tresponse?: any;\n\t\t\theaders?: Headers;\n\t\t};\n\t\tif (response.response) {\n\t\t\tObject.assign(internalContext.context, response.response);\n\t\t}\n\t\t/**\n\t\t * Apply headers from the middleware to the endpoint headers\n\t\t */\n\t\tif (response.headers) {\n\t\t\tresponse.headers.forEach((value, key) => {\n\t\t\t\tinternalContext.responseHeaders.set(key, value);\n\t\t\t});\n\t\t}\n\t}\n\treturn internalContext;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface VkProfile {\n\tuser: {\n\t\tuser_id: string;\n\t\tfirst_name: string;\n\t\tlast_name: string;\n\t\temail?: string | undefined;\n\t\tphone?: number | undefined;\n\t\tavatar?: string | undefined;\n\t\tsex?: number | undefined;\n\t\tverified?: boolean | undefined;\n\t\tbirthday: string;\n\t};\n}\n\nexport interface VkOption extends ProviderOptions {\n\tclientId: string;\n\tscheme?: (\"light\" | \"dark\") | undefined;\n}\n\nexport const vk = (options: VkOption) => {\n\treturn {\n\t\tid: \"vk\",\n\t\tname: \"VK\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"email\", \"phone\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tconst authorizationEndpoint = \"https://id.vk.com/authorize\";\n\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"vk\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({\n\t\t\tcode,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t\tdeviceId,\n\t\t}) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\tdeviceId,\n\t\t\t\ttokenEndpoint: \"https://id.vk.com/oauth2/auth\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://id.vk.com/oauth2/auth\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(data) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(data);\n\t\t\t}\n\t\t\tif (!data.accessToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst formBody = new URLSearchParams({\n\t\t\t\taccess_token: data.accessToken,\n\t\t\t\tclient_id: options.clientId,\n\t\t\t}).toString();\n\t\t\tconst { data: profile, error } = await betterFetch<VkProfile>(\n\t\t\t\t\"https://id.vk.com/oauth2/user_info\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\",\n\t\t\t\t\t},\n\t\t\t\t\tbody: formBody,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tif (!profile.user.email && !userMap?.email) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.user.user_id,\n\t\t\t\t\tfirst_name: profile.user.first_name,\n\t\t\t\t\tlast_name: profile.user.last_name,\n\t\t\t\t\temail: profile.user.email,\n\t\t\t\t\timage: profile.user.avatar,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\tbirthday: profile.user.birthday,\n\t\t\t\t\tsex: profile.user.sex,\n\t\t\t\t\tname: `${profile.user.first_name} ${profile.user.last_name}`,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<VkProfile>;\n};\n","import { decode as b64u } from '../../util/base64url.js';\nimport { decrypt } from '../../lib/decrypt.js';\nimport { JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { isObject } from '../../lib/is_object.js';\nimport { decryptKeyManagement } from '../../lib/decrypt_key_management.js';\nimport { decoder, concat, encode } from '../../lib/buffer_utils.js';\nimport { generateCek } from '../../lib/cek.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { validateAlgorithms } from '../../lib/validate_algorithms.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nexport async function flattenedDecrypt(jwe, key, options) {\n    if (!isObject(jwe)) {\n        throw new JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new JWEInvalid('JOSE Header missing');\n    }\n    if (jwe.iv !== undefined && typeof jwe.iv !== 'string') {\n        throw new JWEInvalid('JWE Initialization Vector incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (jwe.tag !== undefined && typeof jwe.tag !== 'string') {\n        throw new JWEInvalid('JWE Authentication Tag incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !isObject(jwe.header)) {\n        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) {\n        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        try {\n            const protectedHeader = b64u(jwe.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    validateCrit(JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if ((keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) ||\n        (!keyManagementAlgorithms && alg.startsWith('PBES2'))) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter value not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        try {\n            encryptedKey = b64u(jwe.encrypted_key);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the encrypted_key');\n        }\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    checkKeyType(alg === 'dir' ? enc : alg, key, 'decrypt');\n    const k = await normalizeKey(key, alg);\n    let cek;\n    try {\n        cek = await decryptKeyManagement(alg, k, encryptedKey, joseHeader, options);\n    }\n    catch (err) {\n        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {\n            throw err;\n        }\n        cek = generateCek(enc);\n    }\n    let iv;\n    let tag;\n    if (jwe.iv !== undefined) {\n        try {\n            iv = b64u(jwe.iv);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the iv');\n        }\n    }\n    if (jwe.tag !== undefined) {\n        try {\n            tag = b64u(jwe.tag);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the tag');\n        }\n    }\n    const protectedHeader = jwe.protected !== undefined ? encode(jwe.protected) : new Uint8Array();\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = concat(protectedHeader, encode('.'), encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let ciphertext;\n    try {\n        ciphertext = b64u(jwe.ciphertext);\n    }\n    catch {\n        throw new JWEInvalid('Failed to base64url decode the ciphertext');\n    }\n    const plaintext = await decrypt(enc, cek, ciphertext, iv, tag, additionalData);\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        try {\n            result.additionalAuthenticatedData = b64u(jwe.aad);\n        }\n        catch {\n            throw new JWEInvalid('Failed to base64url decode the aad');\n        }\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key: k };\n    }\n    return result;\n}\n","import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { env } from \"@better-auth/core/env\";\nimport { defu } from \"defu\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { getBaseURL } from \"../utils/url\";\n\nexport async function runPluginInit(ctx: AuthContext) {\n\tlet options = ctx.options;\n\tconst plugins = options.plugins || [];\n\tlet context: AuthContext = ctx;\n\tconst dbHooks: BetterAuthOptions[\"databaseHooks\"][] = [];\n\tfor (const plugin of plugins) {\n\t\tif (plugin.init) {\n\t\t\tconst initPromise = plugin.init(context);\n\t\t\tlet result: ReturnType<Required<BetterAuthPlugin>[\"init\"]>;\n\t\t\tif (isPromise(initPromise)) {\n\t\t\t\tresult = await initPromise;\n\t\t\t} else {\n\t\t\t\tresult = initPromise;\n\t\t\t}\n\t\t\tif (typeof result === \"object\") {\n\t\t\t\tif (result.options) {\n\t\t\t\t\tconst { databaseHooks, ...restOpts } = result.options;\n\t\t\t\t\tif (databaseHooks) {\n\t\t\t\t\t\tdbHooks.push(databaseHooks);\n\t\t\t\t\t}\n\t\t\t\t\toptions = defu(options, restOpts);\n\t\t\t\t}\n\t\t\t\tif (result.context) {\n\t\t\t\t\tcontext = {\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\t...(result.context as Partial<AuthContext>),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Add the global database hooks last\n\tdbHooks.push(options.databaseHooks);\n\tcontext.internalAdapter = createInternalAdapter(context.adapter, {\n\t\toptions,\n\t\tlogger: context.logger,\n\t\thooks: dbHooks.filter((u) => u !== undefined),\n\t\tgenerateId: context.generateId,\n\t});\n\tcontext.options = options;\n\treturn { context };\n}\n\nexport function getInternalPlugins(options: BetterAuthOptions) {\n\tconst plugins: BetterAuthPlugin[] = [];\n\tif (options.advanced?.crossSubDomainCookies?.enabled) {\n\t\t// TODO: add internal plugin\n\t}\n\treturn plugins;\n}\n\nexport async function getTrustedOrigins(\n\toptions: BetterAuthOptions,\n\trequest?: Request,\n): Promise<string[]> {\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath, request);\n\tconst trustedOrigins: (string | undefined | null)[] = baseURL\n\t\t? [new URL(baseURL).origin]\n\t\t: [];\n\tif (options.trustedOrigins) {\n\t\tif (Array.isArray(options.trustedOrigins)) {\n\t\t\ttrustedOrigins.push(...options.trustedOrigins);\n\t\t}\n\t\tif (typeof options.trustedOrigins === \"function\") {\n\t\t\tconst validOrigins = await options.trustedOrigins(request);\n\t\t\ttrustedOrigins.push(...validOrigins);\n\t\t}\n\t}\n\tconst envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;\n\tif (envTrustedOrigins) {\n\t\ttrustedOrigins.push(...envTrustedOrigins.split(\",\"));\n\t}\n\treturn trustedOrigins.filter((v): v is string => Boolean(v));\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface LinearUser {\n\tid: string;\n\tname: string;\n\temail: string;\n\tavatarUrl?: string | undefined;\n\tactive: boolean;\n\tcreatedAt: string;\n\tupdatedAt: string;\n}\n\nexport interface LinearProfile {\n\tdata: {\n\t\tviewer: LinearUser;\n\t};\n}\n\nexport interface LinearOptions extends ProviderOptions<LinearUser> {\n\tclientId: string;\n}\n\nexport const linear = (options: LinearOptions) => {\n\tconst tokenEndpoint = \"https://api.linear.app/oauth/token\";\n\treturn {\n\t\tid: \"linear\",\n\t\tname: \"Linear\",\n\t\tcreateAuthorizationURL({ state, scopes, loginHint, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"linear\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://linear.app/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tconst { data: profile, error } = await betterFetch<LinearProfile>(\n\t\t\t\t\"https://api.linear.app/graphql\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tquery: `\n\t\t\t\t\t\t\tquery {\n\t\t\t\t\t\t\t\tviewer {\n\t\t\t\t\t\t\t\t\tid\n\t\t\t\t\t\t\t\t\tname\n\t\t\t\t\t\t\t\t\temail\n\t\t\t\t\t\t\t\t\tavatarUrl\n\t\t\t\t\t\t\t\t\tactive\n\t\t\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\t\t\tupdatedAt\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t`,\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error || !profile?.data?.viewer) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userData = profile.data.viewer;\n\t\t\tconst userMap = await options.mapProfileToUser?.(userData);\n\t\t\t// Linear does not provide email_verified claim.\n\t\t\t// We default to false for security consistency.\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.data.viewer.id,\n\t\t\t\t\tname: profile.data.viewer.name,\n\t\t\t\t\temail: profile.data.viewer.email,\n\t\t\t\t\timage: profile.data.viewer.avatarUrl,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: userData,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<LinearUser>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface NotionProfile {\n\tobject: \"user\";\n\tid: string;\n\ttype: \"person\" | \"bot\";\n\tname?: string | undefined;\n\tavatar_url?: string | undefined;\n\tperson?:\n\t\t| {\n\t\t\t\temail?: string;\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface NotionOptions extends ProviderOptions<NotionProfile> {\n\tclientId: string;\n}\n\nexport const notion = (options: NotionOptions) => {\n\tconst tokenEndpoint = \"https://api.notion.com/v1/oauth/token\";\n\treturn {\n\t\tid: \"notion\",\n\t\tname: \"Notion\",\n\t\tcreateAuthorizationURL({ state, scopes, loginHint, redirectURI }) {\n\t\t\tconst _scopes: string[] = options.disableDefaultScope ? [] : [];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"notion\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://api.notion.com/v1/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tadditionalParams: {\n\t\t\t\t\towner: \"user\",\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t\tauthentication: \"basic\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<{\n\t\t\t\tbot: {\n\t\t\t\t\towner: {\n\t\t\t\t\t\tuser: NotionProfile;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}>(\"https://api.notion.com/v1/users/me\", {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\"Notion-Version\": \"2022-06-28\",\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (error || !profile) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userProfile = profile.bot?.owner?.user;\n\t\t\tif (!userProfile) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(userProfile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: userProfile.id,\n\t\t\t\t\tname: userProfile.name || \"Notion User\",\n\t\t\t\t\temail: userProfile.person?.email || null,\n\t\t\t\t\timage: userProfile.avatar_url,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: userProfile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<NotionProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface SalesforceProfile {\n\tsub: string;\n\tuser_id: string;\n\torganization_id: string;\n\tpreferred_username?: string | undefined;\n\temail: string;\n\temail_verified?: boolean | undefined;\n\tname: string;\n\tgiven_name?: string | undefined;\n\tfamily_name?: string | undefined;\n\tzoneinfo?: string | undefined;\n\tphotos?:\n\t\t| {\n\t\t\t\tpicture?: string;\n\t\t\t\tthumbnail?: string;\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface SalesforceOptions extends ProviderOptions<SalesforceProfile> {\n\tclientId: string;\n\tenvironment?: (\"sandbox\" | \"production\") | undefined;\n\tloginUrl?: string | undefined;\n\t/**\n\t * Override the redirect URI if auto-detection fails.\n\t * Should match the Callback URL configured in your Salesforce Connected App.\n\t * @example \"http://localhost:3000/api/auth/callback/salesforce\"\n\t */\n\tredirectURI?: string | undefined;\n}\n\nexport const salesforce = (options: SalesforceOptions) => {\n\tconst environment = options.environment ?? \"production\";\n\tconst isSandbox = environment === \"sandbox\";\n\tconst authorizationEndpoint = options.loginUrl\n\t\t? `https://${options.loginUrl}/services/oauth2/authorize`\n\t\t: isSandbox\n\t\t\t? \"https://test.salesforce.com/services/oauth2/authorize\"\n\t\t\t: \"https://login.salesforce.com/services/oauth2/authorize\";\n\n\tconst tokenEndpoint = options.loginUrl\n\t\t? `https://${options.loginUrl}/services/oauth2/token`\n\t\t: isSandbox\n\t\t\t? \"https://test.salesforce.com/services/oauth2/token\"\n\t\t\t: \"https://login.salesforce.com/services/oauth2/token\";\n\n\tconst userInfoEndpoint = options.loginUrl\n\t\t? `https://${options.loginUrl}/services/oauth2/userinfo`\n\t\t: isSandbox\n\t\t\t? \"https://test.salesforce.com/services/oauth2/userinfo\"\n\t\t\t: \"https://login.salesforce.com/services/oauth2/userinfo\";\n\n\treturn {\n\t\tid: \"salesforce\",\n\t\tname: \"Salesforce\",\n\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Id and Client Secret are required for Salesforce. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Salesforce\");\n\t\t\t}\n\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"email\", \"profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"salesforce\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t});\n\t\t},\n\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { data: user } = await betterFetch<SalesforceProfile>(\n\t\t\t\t\tuserInfoEndpoint,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user info from Salesforce\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: user.user_id,\n\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\timage: user.photos?.picture || user.photos?.thumbnail,\n\t\t\t\t\t\temailVerified: user.email_verified ?? false,\n\t\t\t\t\t\t...userMap,\n\t\t\t\t\t},\n\t\t\t\t\tdata: user,\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Salesforce:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\toptions,\n\t} satisfies OAuthProvider<SalesforceProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface DropboxProfile {\n\taccount_id: string;\n\tname: {\n\t\tgiven_name: string;\n\t\tsurname: string;\n\t\tfamiliar_name: string;\n\t\tdisplay_name: string;\n\t\tabbreviated_name: string;\n\t};\n\temail: string;\n\temail_verified: boolean;\n\tprofile_photo_url: string;\n}\n\nexport interface DropboxOptions extends ProviderOptions<DropboxProfile> {\n\tclientId: string;\n\taccessType?: (\"offline\" | \"online\" | \"legacy\") | undefined;\n}\n\nexport const dropbox = (options: DropboxOptions) => {\n\tconst tokenEndpoint = \"https://api.dropboxapi.com/oauth2/token\";\n\n\treturn {\n\t\tid: \"dropbox\",\n\t\tname: \"Dropbox\",\n\t\tcreateAuthorizationURL: async ({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t}) => {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"account_info.read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tconst additionalParams: Record<string, string> = {};\n\t\t\tif (options.accessType) {\n\t\t\t\tadditionalParams.token_access_type = options.accessType;\n\t\t\t}\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"dropbox\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.dropbox.com/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\tadditionalParams,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn await validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://api.dropbox.com/oauth2/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<DropboxProfile>(\n\t\t\t\t\"https://api.dropboxapi.com/2/users/get_current_account\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.account_id,\n\t\t\t\t\tname: profile.name?.display_name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified || false,\n\t\t\t\t\timage: profile.profile_photo_url,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<DropboxProfile>;\n};\n","import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport type { OAuth2Tokens } from \"@better-auth/core/oauth2\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { handleOAuthUserInfo } from \"../../oauth2/link-account\";\nimport { parseState } from \"../../oauth2/state\";\nimport { setTokenUtil } from \"../../oauth2/utils\";\nimport { HIDE_METADATA } from \"../../utils/hide-metadata\";\n\nconst schema = z.object({\n\tcode: z.string().optional(),\n\terror: z.string().optional(),\n\tdevice_id: z.string().optional(),\n\terror_description: z.string().optional(),\n\tstate: z.string().optional(),\n\tuser: z.string().optional(),\n});\n\nexport const callbackOAuth = createAuthEndpoint(\n\t\"/callback/:id\",\n\t{\n\t\tmethod: [\"GET\", \"POST\"],\n\t\toperationId: \"handleOAuthCallback\",\n\t\tbody: schema.optional(),\n\t\tquery: schema.optional(),\n\t\tmetadata: {\n\t\t\t...HIDE_METADATA,\n\t\t\tallowedMediaTypes: [\n\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\"application/json\",\n\t\t\t],\n\t\t},\n\t},\n\tasync (c) => {\n\t\tlet queryOrBody: z.infer<typeof schema>;\n\t\tconst defaultErrorURL =\n\t\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\n\t\t// Handle POST requests by redirecting to GET to ensure cookies are sent\n\t\tif (c.method === \"POST\") {\n\t\t\tconst postData = c.body ? schema.parse(c.body) : {};\n\t\t\tconst queryData = c.query ? schema.parse(c.query) : {};\n\n\t\t\tconst mergedData = schema.parse({ ...postData, ...queryData });\n\t\t\tconst params = new URLSearchParams();\n\n\t\t\tfor (const [key, value] of Object.entries(mergedData)) {\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tparams.set(key, String(value));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst redirectURL = `${c.context.baseURL}/callback/${c.params.id}?${params.toString()}`;\n\t\t\tthrow c.redirect(redirectURL);\n\t\t}\n\n\t\ttry {\n\t\t\tif (c.method === \"GET\") {\n\t\t\t\tqueryOrBody = schema.parse(c.query);\n\t\t\t} else if (c.method === \"POST\") {\n\t\t\t\tqueryOrBody = schema.parse(c.body);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unsupported method\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tc.context.logger.error(\"INVALID_CALLBACK_REQUEST\", e);\n\t\t\tthrow c.redirect(`${defaultErrorURL}?error=invalid_callback_request`);\n\t\t}\n\n\t\tconst {\n\t\t\tcode,\n\t\t\terror,\n\t\t\tstate,\n\t\t\terror_description,\n\t\t\tdevice_id,\n\t\t\tuser: userData,\n\t\t} = queryOrBody;\n\n\t\tif (!state) {\n\t\t\tc.context.logger.error(\"State not found\", error);\n\t\t\tconst sep = defaultErrorURL.includes(\"?\") ? \"&\" : \"?\";\n\t\t\tconst url = `${defaultErrorURL}${sep}state=state_not_found`;\n\t\t\tthrow c.redirect(url);\n\t\t}\n\n\t\tconst {\n\t\t\tcodeVerifier,\n\t\t\tcallbackURL,\n\t\t\tlink,\n\t\t\terrorURL,\n\t\t\tnewUserURL,\n\t\t\trequestSignUp,\n\t\t} = await parseState(c);\n\n\t\tfunction redirectOnError(error: string, description?: string | undefined) {\n\t\t\tconst baseURL = errorURL ?? defaultErrorURL;\n\n\t\t\tconst params = new URLSearchParams({ error });\n\t\t\tif (description) params.set(\"error_description\", description);\n\n\t\t\tconst sep = baseURL.includes(\"?\") ? \"&\" : \"?\";\n\t\t\tconst url = `${baseURL}${sep}${params.toString()}`;\n\n\t\t\tthrow c.redirect(url);\n\t\t}\n\n\t\tif (error) {\n\t\t\tredirectOnError(error, error_description);\n\t\t}\n\n\t\tif (!code) {\n\t\t\tc.context.logger.error(\"Code not found\");\n\t\t\tthrow redirectOnError(\"no_code\");\n\t\t}\n\t\tconst provider = c.context.socialProviders.find(\n\t\t\t(p) => p.id === c.params.id,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Oauth provider with id\",\n\t\t\t\tc.params.id,\n\t\t\t\t\"not found\",\n\t\t\t);\n\t\t\tthrow redirectOnError(\"oauth_provider_not_found\");\n\t\t}\n\n\t\tlet tokens: OAuth2Tokens | null;\n\t\ttry {\n\t\t\ttokens = await provider.validateAuthorizationCode({\n\t\t\t\tcode: code,\n\t\t\t\tcodeVerifier,\n\t\t\t\tdeviceId: device_id,\n\t\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tc.context.logger.error(\"\", e);\n\t\t\tthrow redirectOnError(\"invalid_code\");\n\t\t}\n\t\tif (!tokens) {\n\t\t\tthrow redirectOnError(\"invalid_code\");\n\t\t}\n\t\tconst parsedUserData = userData\n\t\t\t? safeJSONParse<{\n\t\t\t\t\tname?: {\n\t\t\t\t\t\tfirstName?: string;\n\t\t\t\t\t\tlastName?: string;\n\t\t\t\t\t};\n\t\t\t\t\temail?: string;\n\t\t\t\t}>(userData)\n\t\t\t: null;\n\n\t\tconst userInfo = await provider\n\t\t\t.getUserInfo({\n\t\t\t\t...tokens,\n\t\t\t\t/**\n\t\t\t\t * The user object from the provider\n\t\t\t\t * This is only available for some providers like Apple\n\t\t\t\t */\n\t\t\t\tuser: parsedUserData ?? undefined,\n\t\t\t})\n\t\t\t.then((res) => res?.user);\n\n\t\tif (!userInfo) {\n\t\t\tc.context.logger.error(\"Unable to get user info\");\n\t\t\treturn redirectOnError(\"unable_to_get_user_info\");\n\t\t}\n\n\t\tif (!callbackURL) {\n\t\t\tc.context.logger.error(\"No callback URL found\");\n\t\t\tthrow redirectOnError(\"no_callback_url\");\n\t\t}\n\n\t\tif (link) {\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\t\t\tconst isTrustedProvider = trustedProviders?.includes(provider.id);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !userInfo.emailVerified) ||\n\t\t\t\tc.context.options.account?.accountLinking?.enabled === false\n\t\t\t) {\n\t\t\t\tc.context.logger.error(\"Unable to link account - untrusted provider\");\n\t\t\t\treturn redirectOnError(\"unable_to_link_account\");\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.email !== link.email &&\n\t\t\t\tc.context.options.account?.accountLinking?.allowDifferentEmails !== true\n\t\t\t) {\n\t\t\t\treturn redirectOnError(\"email_doesn't_match\");\n\t\t\t}\n\n\t\t\tconst existingAccount = await c.context.internalAdapter.findAccount(\n\t\t\t\tString(userInfo.id),\n\t\t\t);\n\n\t\t\tif (existingAccount) {\n\t\t\t\tif (existingAccount.userId.toString() !== link.userId.toString()) {\n\t\t\t\t\treturn redirectOnError(\"account_already_linked_to_different_user\");\n\t\t\t\t}\n\t\t\t\tconst updateData = Object.fromEntries(\n\t\t\t\t\tObject.entries({\n\t\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\t\t\t\tidToken: tokens.idToken,\n\t\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t\t\t\t}).filter(([_, value]) => value !== undefined),\n\t\t\t\t);\n\t\t\t\tawait c.context.internalAdapter.updateAccount(\n\t\t\t\t\texistingAccount.id,\n\t\t\t\t\tupdateData,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst newAccount = await c.context.internalAdapter.createAccount({\n\t\t\t\t\tuserId: link.userId,\n\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\taccountId: String(userInfo.id),\n\t\t\t\t\t...tokens,\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t\t\t});\n\t\t\t\tif (!newAccount) {\n\t\t\t\t\treturn redirectOnError(\"unable_to_link_account\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet toRedirectTo: string;\n\t\t\ttry {\n\t\t\t\tconst url = callbackURL;\n\t\t\t\ttoRedirectTo = url.toString();\n\t\t\t} catch {\n\t\t\t\ttoRedirectTo = callbackURL;\n\t\t\t}\n\t\t\tthrow c.redirect(toRedirectTo);\n\t\t}\n\n\t\tif (!userInfo.email) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Provider did not return email. This could be due to misconfiguration in the provider settings.\",\n\t\t\t);\n\t\t\treturn redirectOnError(\"email_not_found\");\n\t\t}\n\t\tconst accountData = {\n\t\t\tproviderId: provider.id,\n\t\t\taccountId: String(userInfo.id),\n\t\t\t...tokens,\n\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t};\n\t\tconst result = await handleOAuthUserInfo(c, {\n\t\t\tuserInfo: {\n\t\t\t\t...userInfo,\n\t\t\t\tid: String(userInfo.id),\n\t\t\t\temail: userInfo.email,\n\t\t\t\tname: userInfo.name || userInfo.email,\n\t\t\t},\n\t\t\taccount: accountData,\n\t\t\tcallbackURL,\n\t\t\tdisableSignUp:\n\t\t\t\t(provider.disableImplicitSignUp && !requestSignUp) ||\n\t\t\t\tprovider.options?.disableSignUp,\n\t\t\toverrideUserInfo: provider.options?.overrideUserInfoOnSignIn,\n\t\t});\n\t\tif (result.error) {\n\t\t\tc.context.logger.error(result.error.split(\" \").join(\"_\"));\n\t\t\treturn redirectOnError(result.error.split(\" \").join(\"_\"));\n\t\t}\n\t\tconst { session, user } = result.data!;\n\t\tawait setSessionCookie(c, {\n\t\t\tsession,\n\t\t\tuser,\n\t\t});\n\n\t\tlet toRedirectTo: string;\n\t\ttry {\n\t\t\tconst url = result.isRegister ? newUserURL || callbackURL : callbackURL;\n\t\t\ttoRedirectTo = url.toString();\n\t\t} catch {\n\t\t\ttoRedirectTo = result.isRegister\n\t\t\t\t? newUserURL || callbackURL\n\t\t\t\t: callbackURL;\n\t\t}\n\t\tthrow c.redirect(toRedirectTo);\n\t},\n);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface LinkedInProfile {\n\tsub: string;\n\tname: string;\n\tgiven_name: string;\n\tfamily_name: string;\n\tpicture: string;\n\tlocale: {\n\t\tcountry: string;\n\t\tlanguage: string;\n\t};\n\temail: string;\n\temail_verified: boolean;\n}\n\nexport interface LinkedInOptions extends ProviderOptions<LinkedInProfile> {\n\tclientId: string;\n}\n\nexport const linkedin = (options: LinkedInOptions) => {\n\tconst authorizationEndpoint =\n\t\t\"https://www.linkedin.com/oauth/v2/authorization\";\n\tconst tokenEndpoint = \"https://www.linkedin.com/oauth/v2/accessToken\";\n\n\treturn {\n\t\tid: \"linkedin\",\n\t\tname: \"Linkedin\",\n\t\tcreateAuthorizationURL: async ({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tredirectURI,\n\t\t\tloginHint,\n\t\t}) => {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"profile\", \"email\", \"openid\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"linkedin\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tloginHint,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn await validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<LinkedInProfile>(\n\t\t\t\t\"https://api.linkedin.com/v2/userinfo\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.email_verified || false,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<LinkedInProfile>;\n};\n","import { addRoute, createRouter as createRou3Router, findAllRoutes, findRoute } from \"rou3\";\nimport { type Endpoint, createEndpoint } from \"./endpoint\";\nimport type { Middleware } from \"./middleware\";\nimport { generator, getHTML } from \"./openapi\";\nimport { toResponse } from \"./to-response\";\nimport { getBody, isAPIError, isRequest } from \"./utils\";\n\nexport interface RouterConfig {\n\tthrowError?: boolean;\n\tonError?: (e: unknown) => void | Promise<void> | Response | Promise<Response>;\n\tbasePath?: string;\n\trouterMiddleware?: Array<{\n\t\tpath: string;\n\t\tmiddleware: Middleware;\n\t}>;\n\t/**\n\t * additional Context that needs to passed to endpoints\n\t *\n\t * this will be available on `ctx.context` on endpoints\n\t */\n\trouterContext?: Record<string, any>;\n\t/**\n\t * A callback to run before any response\n\t */\n\tonResponse?: (res: Response) => any | Promise<any>;\n\t/**\n\t * A callback to run before any request\n\t */\n\tonRequest?: (req: Request) => any | Promise<any>;\n\t/**\n\t * List of allowed media types (MIME types) for the router\n\t *\n\t * if provided, only the media types in the list will be allowed to be passed in the body.\n\t *\n\t * If an endpoint has allowed media types, it will override the router's allowed media types.\n\t *\n\t * @example\n\t * ```ts\n\t * const router = createRouter({\n\t * \t\tallowedMediaTypes: [\"application/json\", \"application/x-www-form-urlencoded\"],\n\t * \t})\n\t */\n\tallowedMediaTypes?: string[];\n\t/**\n\t * Skip trailing slashes\n\t *\n\t * @default false\n\t */\n\tskipTrailingSlashes?: boolean;\n\t/**\n\t * Open API route configuration\n\t */\n\topenapi?: {\n\t\t/**\n\t\t * Disable openapi route\n\t\t *\n\t\t * @default false\n\t\t */\n\t\tdisabled?: boolean;\n\t\t/**\n\t\t * A path to display open api using scalar\n\t\t *\n\t\t * @default \"/api/reference\"\n\t\t */\n\t\tpath?: string;\n\t\t/**\n\t\t * Scalar Configuration\n\t\t */\n\t\tscalar?: {\n\t\t\t/**\n\t\t\t * Title\n\t\t\t * @default \"Open API Reference\"\n\t\t\t */\n\t\t\ttitle?: string;\n\t\t\t/**\n\t\t\t * Description\n\t\t\t *\n\t\t\t * @default \"Better Call Open API Reference\"\n\t\t\t */\n\t\t\tdescription?: string;\n\t\t\t/**\n\t\t\t * Logo URL\n\t\t\t */\n\t\t\tlogo?: string;\n\t\t\t/**\n\t\t\t * Scalar theme\n\t\t\t * @default \"saturn\"\n\t\t\t */\n\t\t\ttheme?: string;\n\t\t};\n\t};\n}\n\nexport const createRouter = <E extends Record<string, Endpoint>, Config extends RouterConfig>(\n\tendpoints: E,\n\tconfig?: Config,\n) => {\n\tif (!config?.openapi?.disabled) {\n\t\tconst openapi = {\n\t\t\tpath: \"/api/reference\",\n\t\t\t...config?.openapi,\n\t\t};\n\t\t//@ts-expect-error\n\t\tendpoints[\"openapi\"] = createEndpoint(\n\t\t\topenapi.path,\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t},\n\t\t\tasync (c) => {\n\t\t\t\tconst schema = await generator(endpoints);\n\t\t\t\treturn new Response(getHTML(schema, openapi.scalar), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"text/html\",\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\tconst router = createRou3Router();\n\tconst middlewareRouter = createRou3Router();\n\n\tfor (const endpoint of Object.values(endpoints)) {\n\t\tif (!endpoint.options || !endpoint.path) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (endpoint.options?.metadata?.SERVER_ONLY) continue;\n\n\t\tconst methods = Array.isArray(endpoint.options?.method)\n\t\t\t? endpoint.options.method\n\t\t\t: [endpoint.options?.method];\n\n\t\tfor (const method of methods) {\n\t\t\taddRoute(router, method, endpoint.path, endpoint);\n\t\t}\n\t}\n\n\tif (config?.routerMiddleware?.length) {\n\t\tfor (const { path, middleware } of config.routerMiddleware) {\n\t\t\taddRoute(middlewareRouter, \"*\", path, middleware);\n\t\t}\n\t}\n\n\tconst processRequest = async (request: Request) => {\n\t\tconst url = new URL(request.url);\n\t\tconst pathname = url.pathname;\n\t\tconst path =\n\t\t\tconfig?.basePath && config.basePath !== \"/\"\n\t\t\t\t? pathname\n\t\t\t\t\t\t.split(config.basePath)\n\t\t\t\t\t\t.reduce((acc, curr, index) => {\n\t\t\t\t\t\t\tif (index !== 0) {\n\t\t\t\t\t\t\t\tif (index > 1) {\n\t\t\t\t\t\t\t\t\tacc.push(`${config.basePath}${curr}`);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tacc.push(curr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t}, [] as string[])\n\t\t\t\t\t\t.join(\"\")\n\t\t\t\t: url.pathname;\n\t\tif (!path?.length) {\n\t\t\treturn new Response(null, { status: 404, statusText: \"Not Found\" });\n\t\t}\n\n\t\t// Reject paths with consecutive slashes\n\t\tif (/\\/{2,}/.test(path)) {\n\t\t\treturn new Response(null, { status: 404, statusText: \"Not Found\" });\n\t\t}\n\n\t\tconst route = findRoute(router, request.method, path) as {\n\t\t\tdata: Endpoint & { path: string };\n\t\t\tparams: Record<string, string>;\n\t\t};\n\t\tconst hasTrailingSlash = path.endsWith(\"/\");\n\t\tconst routeHasTrailingSlash = route?.data?.path?.endsWith(\"/\");\n\n\t\t// If the path has a trailing slash and the route doesn't have a trailing slash and skipTrailingSlashes is not set, return 404\n\t\tif (hasTrailingSlash !== routeHasTrailingSlash && !config?.skipTrailingSlashes) {\n\t\t\treturn new Response(null, { status: 404, statusText: \"Not Found\" });\n\t\t}\n\t\tif (!route?.data) return new Response(null, { status: 404, statusText: \"Not Found\" });\n\n\t\tconst query: Record<string, string | string[]> = {};\n\t\turl.searchParams.forEach((value, key) => {\n\t\t\tif (key in query) {\n\t\t\t\tif (Array.isArray(query[key])) {\n\t\t\t\t\t(query[key] as string[]).push(value);\n\t\t\t\t} else {\n\t\t\t\t\tquery[key] = [query[key] as string, value];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tquery[key] = value;\n\t\t\t}\n\t\t});\n\n\t\tconst handler = route.data as Endpoint;\n\n\t\ttry {\n\t\t\t// Determine which allowedMediaTypes to use: endpoint-level overrides router-level\n\t\t\tconst allowedMediaTypes =\n\t\t\t\thandler.options.metadata?.allowedMediaTypes || config?.allowedMediaTypes;\n\t\t\tconst context = {\n\t\t\t\tpath,\n\t\t\t\tmethod: request.method as \"GET\",\n\t\t\t\theaders: request.headers,\n\t\t\t\tparams: route.params ? (JSON.parse(JSON.stringify(route.params)) as any) : {},\n\t\t\t\trequest: request,\n\t\t\t\tbody: handler.options.disableBody\n\t\t\t\t\t? undefined\n\t\t\t\t\t: await getBody(\n\t\t\t\t\t\t\thandler.options.cloneRequest ? request.clone() : request,\n\t\t\t\t\t\t\tallowedMediaTypes,\n\t\t\t\t\t\t),\n\t\t\t\tquery,\n\t\t\t\t_flag: \"router\" as const,\n\t\t\t\tasResponse: true,\n\t\t\t\tcontext: config?.routerContext,\n\t\t\t};\n\t\t\tconst middlewareRoutes = findAllRoutes(middlewareRouter, \"*\", path);\n\t\t\tif (middlewareRoutes?.length) {\n\t\t\t\tfor (const { data: middleware, params } of middlewareRoutes) {\n\t\t\t\t\tconst res = await (middleware as Endpoint)({\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\tasResponse: false,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (res instanceof Response) return res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst response = (await handler(context)) as Response;\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tif (config?.onError) {\n\t\t\t\ttry {\n\t\t\t\t\tconst errorResponse = await config.onError(error);\n\n\t\t\t\t\tif (errorResponse instanceof Response) {\n\t\t\t\t\t\treturn toResponse(errorResponse);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (isAPIError(error)) {\n\t\t\t\t\t\treturn toResponse(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (config?.throwError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isAPIError(error)) {\n\t\t\t\treturn toResponse(error);\n\t\t\t}\n\n\t\t\tconsole.error(`# SERVER_ERROR: `, error);\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 500,\n\t\t\t\tstatusText: \"Internal Server Error\",\n\t\t\t});\n\t\t}\n\t};\n\n\treturn {\n\t\thandler: async (request: Request) => {\n\t\t\tconst onReq = await config?.onRequest?.(request);\n\t\t\tif (onReq instanceof Response) {\n\t\t\t\treturn onReq;\n\t\t\t}\n\t\t\tconst req = isRequest(onReq) ? onReq : request;\n\t\t\tconst res = await processRequest(req);\n\t\t\tconst onRes = await config?.onResponse?.(res);\n\t\t\tif (onRes instanceof Response) {\n\t\t\t\treturn onRes;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\tendpoints,\n\t};\n};\n\nexport type Router = ReturnType<typeof createRouter>;\n","import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { generateId } from \"../../utils\";\nimport { getDate } from \"../../utils/date\";\nimport { validatePassword } from \"../../utils/password\";\nimport { originCheck } from \"../middlewares\";\nimport { sensitiveSessionMiddleware } from \"./session\";\n\nfunction redirectError(\n\tctx: AuthContext,\n\tcallbackURL: string | undefined,\n\tquery?: Record<string, string> | undefined,\n): string {\n\tconst url = callbackURL\n\t\t? new URL(callbackURL, ctx.baseURL)\n\t\t: new URL(`${ctx.baseURL}/error`);\n\tif (query)\n\t\tObject.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\n\nfunction redirectCallback(\n\tctx: AuthContext,\n\tcallbackURL: string,\n\tquery?: Record<string, string> | undefined,\n): string {\n\tconst url = new URL(callbackURL, ctx.baseURL);\n\tif (query)\n\t\tObject.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\n\nexport const requestPasswordReset = createAuthEndpoint(\n\t\"/request-password-reset\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The email address of the user to send a password reset email to.\n\t\t\t */\n\t\t\temail: z.email().meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The email address of the user to send a password reset email to\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The URL to redirect the user to reset their password.\n\t\t\t * If the token isn't valid or expired, it'll be redirected with a query parameter `?\n\t\t\t * error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?\n\t\t\t * token=VALID_TOKEN\n\t\t\t */\n\t\t\tredirectTo: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"requestPasswordReset\",\n\t\t\t\tdescription: \"Send a password reset email to the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.emailAndPassword?.sendResetPassword) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!\",\n\t\t\t);\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Reset password isn't enabled\",\n\t\t\t});\n\t\t}\n\t\tconst { email, redirectTo } = ctx.body;\n\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, {\n\t\t\tincludeAccounts: true,\n\t\t});\n\t\tif (!user) {\n\t\t\t/**\n\t\t\t * We simulate the verification token generation and the database lookup\n\t\t\t * to mitigate timing attacks.\n\t\t\t */\n\t\t\tgenerateId(24);\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(\n\t\t\t\t\"dummy-verification-token\",\n\t\t\t);\n\t\t\tctx.context.logger.error(\"Reset Password: User not found\", { email });\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t\tmessage:\n\t\t\t\t\t\"If this email exists in our system, check your email for the reset link\",\n\t\t\t});\n\t\t}\n\t\tconst defaultExpiresIn = 60 * 60 * 1;\n\t\tconst expiresAt = getDate(\n\t\t\tctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn ||\n\t\t\t\tdefaultExpiresIn,\n\t\t\t\"sec\",\n\t\t);\n\t\tconst verificationToken = generateId(24);\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: user.user.id,\n\t\t\tidentifier: `reset-password:${verificationToken}`,\n\t\t\texpiresAt,\n\t\t});\n\t\tconst callbackURL = redirectTo ? encodeURIComponent(redirectTo) : \"\";\n\t\tconst url = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;\n\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\tctx.context.options.emailAndPassword.sendResetPassword(\n\t\t\t\t{\n\t\t\t\t\tuser: user.user,\n\t\t\t\t\turl,\n\t\t\t\t\ttoken: verificationToken,\n\t\t\t\t},\n\t\t\t\tctx.request,\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tmessage:\n\t\t\t\t\"If this email exists in our system, check your email for the reset link\",\n\t\t});\n\t},\n);\n\nexport const requestPasswordResetCallback = createAuthEndpoint(\n\t\"/reset-password/:token\",\n\t{\n\t\tmethod: \"GET\",\n\t\toperationId: \"forgetPasswordCallback\",\n\t\tquery: z.object({\n\t\t\tcallbackURL: z.string().meta({\n\t\t\t\tdescription: \"The URL to redirect the user to reset their password\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"resetPasswordCallback\",\n\t\t\t\tdescription: \"Redirects the user to the callback URL with the token\",\n\t\t\t\tparameters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"token\",\n\t\t\t\t\t\tin: \"path\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"The token to reset the password\",\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"callbackURL\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"The URL to redirect the user to reset their password\",\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { token } = ctx.params;\n\t\tconst { callbackURL } = ctx.query;\n\t\tif (!token || !callbackURL) {\n\t\t\tthrow ctx.redirect(\n\t\t\t\tredirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }),\n\t\t\t);\n\t\t}\n\t\tconst verification =\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(\n\t\t\t\t`reset-password:${token}`,\n\t\t\t);\n\t\tif (!verification || verification.expiresAt < new Date()) {\n\t\t\tthrow ctx.redirect(\n\t\t\t\tredirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }),\n\t\t\t);\n\t\t}\n\n\t\tthrow ctx.redirect(redirectCallback(ctx.context, callbackURL, { token }));\n\t},\n);\n\nexport const resetPassword = createAuthEndpoint(\n\t\"/reset-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"resetPassword\",\n\t\tquery: z\n\t\t\t.object({\n\t\t\t\ttoken: z.string().optional(),\n\t\t\t})\n\t\t\t.optional(),\n\t\tbody: z.object({\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set\",\n\t\t\t}),\n\t\t\ttoken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The token to reset the password\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"resetPassword\",\n\t\t\t\tdescription: \"Reset the password for a user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst token = ctx.body.token || ctx.query?.token;\n\t\tif (!token) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\n\t\tconst { newPassword } = ctx.body;\n\n\t\tconst minLength = ctx.context.password?.config.minPasswordLength;\n\t\tconst maxLength = ctx.context.password?.config.maxPasswordLength;\n\t\tif (newPassword.length < minLength) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\t\tif (newPassword.length > maxLength) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst id = `reset-password:${token}`;\n\n\t\tconst verification =\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(id);\n\t\tif (!verification || verification.expiresAt < new Date()) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tconst userId = verification.value;\n\t\tconst hashedPassword = await ctx.context.password.hash(newPassword);\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(userId);\n\t\tconst account = accounts.find((ac) => ac.providerId === \"credential\");\n\t\tif (!account) {\n\t\t\tawait ctx.context.internalAdapter.createAccount({\n\t\t\t\tuserId,\n\t\t\t\tproviderId: \"credential\",\n\t\t\t\tpassword: hashedPassword,\n\t\t\t\taccountId: userId,\n\t\t\t});\n\t\t} else {\n\t\t\tawait ctx.context.internalAdapter.updatePassword(userId, hashedPassword);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\n\t\tif (ctx.context.options.emailAndPassword?.onPasswordReset) {\n\t\t\tconst user = await ctx.context.internalAdapter.findUserById(userId);\n\t\t\tif (user) {\n\t\t\t\tawait ctx.context.options.emailAndPassword.onPasswordReset(\n\t\t\t\t\t{\n\t\t\t\t\t\tuser,\n\t\t\t\t\t},\n\t\t\t\t\tctx.request,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(userId);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const verifyPassword = createAuthEndpoint(\n\t\"/verify-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The password to verify\n\t\t\t */\n\t\t\tpassword: z.string().meta({\n\t\t\t\tdescription: \"The password to verify\",\n\t\t\t}),\n\t\t}),\n\t\tmetadata: {\n\t\t\tscope: \"server\",\n\t\t\topenapi: {\n\t\t\t\toperationId: \"verifyPassword\",\n\t\t\t\tdescription: \"Verify the current user's password\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tuse: [sensitiveSessionMiddleware],\n\t},\n\tasync (ctx) => {\n\t\tconst { password } = ctx.body;\n\t\tconst session = ctx.context.session;\n\n\t\tconst isValid = await validatePassword(ctx, {\n\t\t\tpassword,\n\t\t\tuserId: session.user.id,\n\t\t});\n\n\t\tif (!isValid) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t});\n\t\t}\n\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n","import type {\n\tEndpointContext,\n\tEndpointOptions,\n\tStrictEndpoint,\n} from \"better-call\";\nimport { createEndpoint, createMiddleware } from \"better-call\";\nimport { runWithEndpointContext } from \"../context\";\nimport type { AuthContext } from \"../types\";\n\nexport const optionsMiddleware = createMiddleware(async () => {\n\t/**\n\t * This will be passed on the instance of\n\t * the context. Used to infer the type\n\t * here.\n\t */\n\treturn {} as AuthContext;\n});\n\nexport const createAuthMiddleware = createMiddleware.create({\n\tuse: [\n\t\toptionsMiddleware,\n\t\t/**\n\t\t * Only use for post hooks\n\t\t */\n\t\tcreateMiddleware(async () => {\n\t\t\treturn {} as {\n\t\t\t\treturned?: unknown | undefined;\n\t\t\t\tresponseHeaders?: Headers | undefined;\n\t\t\t};\n\t\t}),\n\t],\n});\n\nconst use = [optionsMiddleware];\n\ntype EndpointHandler<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n> = (context: EndpointContext<Path, Options, AuthContext>) => Promise<R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n>(\n\tpath: Path,\n\toptions: Options,\n\thandler: EndpointHandler<Path, Options, R>,\n): StrictEndpoint<Path, Options, R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOptions extends EndpointOptions,\n\tR,\n>(\n\toptions: Options,\n\thandler: EndpointHandler<Path, Options, R>,\n): StrictEndpoint<Path, Options, R>;\n\nexport function createAuthEndpoint<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR,\n>(\n\tpathOrOptions: Path | Opts,\n\thandlerOrOptions: EndpointHandler<Path, Opts, R> | Opts,\n\thandlerOrNever?: any,\n) {\n\tconst path: Path | undefined =\n\t\ttypeof pathOrOptions === \"string\" ? pathOrOptions : undefined;\n\tconst options: Opts =\n\t\ttypeof handlerOrOptions === \"object\"\n\t\t\t? handlerOrOptions\n\t\t\t: (pathOrOptions as Opts);\n\tconst handler: EndpointHandler<Path, Opts, R> =\n\t\ttypeof handlerOrOptions === \"function\" ? handlerOrOptions : handlerOrNever;\n\n\tif (path) {\n\t\treturn createEndpoint(\n\t\t\tpath,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tuse: [...(options?.use || []), ...use],\n\t\t\t},\n\t\t\t// todo: prettify the code, we want to call `runWithEndpointContext` to top level\n\t\t\tasync (ctx) => runWithEndpointContext(ctx as any, () => handler(ctx)),\n\t\t);\n\t}\n\n\treturn createEndpoint(\n\t\t{\n\t\t\t...options,\n\t\t\tuse: [...(options?.use || []), ...use],\n\t\t},\n\t\t// todo: prettify the code, we want to call `runWithEndpointContext` to top level\n\t\tasync (ctx) => runWithEndpointContext(ctx as any, () => handler(ctx)),\n\t);\n}\n\nexport type AuthEndpoint<\n\tPath extends string,\n\tOpts extends EndpointOptions,\n\tR,\n> = ReturnType<typeof createAuthEndpoint<Path, Opts, R>>;\nexport type AuthMiddleware = ReturnType<typeof createAuthMiddleware>;\n","import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tInternalAdapter,\n} from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n\trunWithTransaction,\n} from \"@better-auth/core/context\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { generateId, safeJSONParse } from \"@better-auth/core/utils\";\nimport type { Account, Session, User, Verification } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { getIp } from \"../utils/get-request-ip\";\nimport {\n\tparseSessionInput,\n\tparseSessionOutput,\n\tparseUserOutput,\n} from \"./schema\";\nimport { getWithHooks } from \"./with-hooks\";\n\nexport const createInternalAdapter = (\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: Omit<BetterAuthOptions, \"logger\">;\n\t\tlogger: InternalLogger;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t\tgenerateId: AuthContext[\"generateId\"];\n\t},\n): InternalAdapter => {\n\tconst logger = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7; // 7 days\n\tconst {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t} = getWithHooks(adapter, ctx);\n\n\tasync function refreshUserSessions(user: User) {\n\t\tif (!secondaryStorage) return;\n\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\n\t\tconst now = Date.now();\n\t\tconst list =\n\t\t\tsafeJSONParse<{ token: string; expiresAt: number }[]>(listRaw) || [];\n\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\n\t\tawait Promise.all(\n\t\t\tvalidSessions.map(async ({ token }) => {\n\t\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\t\tif (!cached) return;\n\t\t\t\tconst parsed = safeJSONParse<{ session: Session; user: User }>(cached);\n\t\t\t\tif (!parsed) return;\n\n\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\tMath.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1000,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\ttoken,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tsession: parsed.session,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t}),\n\t\t\t\t\tMath.floor(sessionTTL),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\tcreateOAuthUser: async (\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">,\n\t\t\taccount: Omit<Account, \"userId\" | \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t...user,\n\t\t\t\t\t},\n\t\t\t\t\t\"user\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser!.id,\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t},\n\t\t\t\t\t\"account\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: createdAccount,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async <T>(\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\" | \"emailVerified\"> &\n\t\t\t\tPartial<User> &\n\t\t\t\tRecord<string, any>,\n\t\t) => {\n\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...user,\n\t\t\t\t\temail: user.email?.toLowerCase(),\n\t\t\t\t},\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\treturn createdUser as T & User;\n\t\t},\n\t\tcreateAccount: async <T extends Record<string, any>>(\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account> &\n\t\t\t\tT,\n\t\t) => {\n\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn createdAccount as T & Account;\n\t\t},\n\t\tlistSessions: async (userId: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t);\n\t\t\t\tif (!currentList) return [];\n\n\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tconst seenTokens = new Set<string>();\n\t\t\t\tconst sessions: Session[] = [];\n\n\t\t\t\tfor (const { token, expiresAt } of list) {\n\t\t\t\t\tif (expiresAt <= now || seenTokens.has(token)) continue;\n\t\t\t\t\tseenTokens.add(token);\n\n\t\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\t\tif (!data) continue;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst parsed = (\n\t\t\t\t\t\t\ttypeof data === \"string\" ? JSON.parse(data) : data\n\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (!parsed?.session) continue;\n\n\t\t\t\t\t\tsessions.push(\n\t\t\t\t\t\t\tparseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(parsed.session.expiresAt),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Session>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn sessions;\n\t\t},\n\t\tlistUsers: async (\n\t\t\tlimit?: number | undefined,\n\t\t\toffset?: number | undefined,\n\t\t\tsortBy?:\n\t\t\t\t| {\n\t\t\t\t\t\tfield: string;\n\t\t\t\t\t\tdirection: \"asc\" | \"desc\";\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\twhere?: Where[] | undefined,\n\t\t) => {\n\t\t\tconst users = await (await getCurrentAdapter(adapter)).findMany<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere,\n\t\t\t});\n\t\t\treturn users;\n\t\t},\n\t\tcountTotalUsers: async (where?: Where[] | undefined) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere,\n\t\t\t});\n\t\t\tif (typeof total === \"string\") {\n\t\t\t\treturn parseInt(total);\n\t\t\t}\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId: string) => {\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"session\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tcreateSession: async (\n\t\t\tuserId: string,\n\t\t\tdontRememberMe?: boolean | undefined,\n\t\t\toverride?: (Partial<Session> & Record<string, any>) | undefined,\n\t\t\toverrideAll?: boolean | undefined,\n\t\t) => {\n\t\t\tconst ctx = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx?.headers || ctx?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\t//we're parsing default values for session additional fields\n\t\t\tconst defaultAdditionalFields = parseSessionInput(\n\t\t\t\tctx?.context.options ?? options,\n\t\t\t\t{},\n\t\t\t);\n\t\t\tconst data: Omit<Session, \"id\"> = {\n\t\t\t\tipAddress:\n\t\t\t\t\tctx?.request || ctx?.headers\n\t\t\t\t\t\t? getIp(ctx?.request || ctx?.headers!, ctx?.context.options) || \"\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\t/**\n\t\t\t\t * If the user doesn't want to be remembered\n\t\t\t\t * set the session to expire in 1 day.\n\t\t\t\t * The cookie will be set to expire at the end of the session\n\t\t\t\t */\n\t\t\t\texpiresAt: dontRememberMe\n\t\t\t\t\t? getDate(60 * 60 * 24, \"sec\") // 1 day\n\t\t\t\t\t: getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...(overrideAll ? rest : {}),\n\t\t\t};\n\t\t\tconst res = await createWithHooks(\n\t\t\t\tdata,\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * store the session token for the user\n\t\t\t\t\t\t\t\t * so we can retrieve it later for listing sessions\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] = [];\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\t\t\t\tlist = list.filter(\n\t\t\t\t\t\t\t\t\t\t(session) =>\n\t\t\t\t\t\t\t\t\t\t\tsession.expiresAt > now && session.token !== data.token,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst sorted = [\n\t\t\t\t\t\t\t\t\t...list,\n\t\t\t\t\t\t\t\t\t{ token: data.token, expiresAt: data.expiresAt.getTime() },\n\t\t\t\t\t\t\t\t].sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\t\t\tconst furthestSessionExp =\n\t\t\t\t\t\t\t\t\tsorted.at(-1)?.expiresAt ?? data.expiresAt.getTime();\n\t\t\t\t\t\t\t\tconst furthestSessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (furthestSessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\tfurthestSessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst user = await adapter.findOne<User>({\n\t\t\t\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((data.expiresAt.getTime() - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tdata.token,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn sessionData;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn res as Session;\n\t\t},\n\t\tfindSession: async (\n\t\t\ttoken: string,\n\t\t): Promise<{\n\t\t\tsession: Session & Record<string, any>;\n\t\t\tuser: User & Record<string, any>;\n\t\t} | null> => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.options, {\n\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: token,\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\tconst parsedSession = parseSessionOutput(ctx.options, session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.options, user);\n\t\t\treturn {\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser,\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens: string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[] = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst s = (\n\t\t\t\t\t\t\t\ttypeof sessionStringified === \"string\"\n\t\t\t\t\t\t\t\t\t? JSON.parse(sessionStringified)\n\t\t\t\t\t\t\t\t\t: sessionStringified\n\t\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (!s?.session) continue;\n\t\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsessions.push(session);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// Skip invalid/corrupt session data\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\t\toperator: \"in\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user!,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (\n\t\t\tsessionToken: string,\n\t\t\tsession: Partial<Session> & Record<string, any>,\n\t\t) => {\n\t\t\tconst updatedSession = await updateWithHooks<Session>(\n\t\t\t\tsession,\n\t\t\t\t[{ field: \"token\", value: sessionToken }],\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tasync fn(data) {\n\t\t\t\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\t\t\tif (!currentSession) {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst parsedSession = safeJSONParse<{\n\t\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\t}>(currentSession);\n\t\t\t\t\t\t\t\tif (!parsedSession) return null;\n\n\t\t\t\t\t\t\t\tconst mergedSession = {\n\t\t\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.expiresAt ?? parsedSession.session.expiresAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(parsedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.updatedAt ?? parsedSession.session.updatedAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst updatedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.options,\n\t\t\t\t\t\t\t\t\tmergedSession,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\t\t\tconst expiresMs = new Date(updatedSession.expiresAt).getTime();\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((expiresMs - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tsessionToken,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\t\t\t\t\tuser: parsedSession.user,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst listKey = `active-sessions-${updatedSession.userId}`;\n\t\t\t\t\t\t\t\t\tconst listRaw = await secondaryStorage.get(listKey);\n\t\t\t\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] = listRaw\n\t\t\t\t\t\t\t\t\t\t? safeJSONParse(listRaw) || []\n\t\t\t\t\t\t\t\t\t\t: [];\n\n\t\t\t\t\t\t\t\t\tconst filtered = list\n\t\t\t\t\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t\t\t\t\t(s) => s.token !== sessionToken && s.expiresAt > now,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.concat([{ token: sessionToken, expiresAt: expiresMs }]);\n\n\t\t\t\t\t\t\t\t\tconst sorted = filtered.sort(\n\t\t\t\t\t\t\t\t\t\t(a, b) => a.expiresAt - b.expiresAt,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\t\t\t\tif (furthestSessionExp && furthestSessionExp > now) {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t\tlistKey,\n\t\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.delete(listKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn updatedSession;\n\t\t},\n\t\tdeleteSession: async (token: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\t// remove the session from the active sessions list\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } =\n\t\t\t\t\t\tsafeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\n\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\tconst filtered = list.filter(\n\t\t\t\t\t\t\t(session) => session.expiresAt > now && session.token !== token,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst sorted = filtered.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tfiltered.length > 0 &&\n\t\t\t\t\t\t\tfurthestSessionExp &&\n\t\t\t\t\t\t\tfurthestSessionExp > Date.now()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\tJSON.stringify(filtered),\n\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait secondaryStorage.delete(token);\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"token\", value: token }],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccounts: async (userId: string) => {\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccount: async (accountId: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: accountId }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens: string | string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t\tconst sessions = activeSession\n\t\t\t\t\t\t? safeJSONParse<{ token: string }[]>(activeSession)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\t\tawait secondaryStorage.delete(session.token);\n\t\t\t\t\t}\n\t\t\t\t\tawait secondaryStorage.delete(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const sessionToken of userIdOrSessionTokens) {\n\t\t\t\t\t\tconst session = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\tif (session) {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(sessionToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindOAuthUser: async (\n\t\t\temail: string,\n\t\t\taccountId: string,\n\t\t\tproviderId: string,\n\t\t) => {\n\t\t\t// we need to find account first to avoid missing user if the email changed with the provider for the same account\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<\n\t\t\t\tAccount & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (account) {\n\t\t\t\tif (account.user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: account.user,\n\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tif (user) {\n\t\t\t\t\tconst accounts = await (\n\t\t\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t\t\t).findMany<Account>({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tlinkedAccount: null,\n\t\t\t\t\t\taccounts: accounts || [],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (\n\t\t\temail: string,\n\t\t\toptions?: { includeAccounts: boolean } | undefined,\n\t\t) => {\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tUser & { account: Account[] | undefined }\n\t\t\t>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\t...(options?.includeAccounts ? { account: true } : {}),\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? [],\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId: string) => {\n\t\t\tif (!userId) return null;\n\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn user;\n\t\t},\n\t\tlinkAccount: async (\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\tconst _account = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn _account;\n\t\t},\n\t\tupdateUser: async (\n\t\t\tuserId: string,\n\t\t\tdata: Partial<User> & Record<string, any>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (\n\t\t\temail: string,\n\t\t\tdata: Partial<User & Record<string, any>>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId: string, password: string) => {\n\t\t\tawait updateManyWithHooks(\n\t\t\t\t{\n\t\t\t\t\tpassword,\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindAccounts: async (userId: string) => {\n\t\t\tconst accounts = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn accounts;\n\t\t},\n\t\tfindAccount: async (accountId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByProviderId: async (accountId: string, providerId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByUserId: async (userId: string) => {\n\t\t\tconst account = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn account;\n\t\t},\n\t\tupdateAccount: async (id: string, data: Partial<Account>) => {\n\t\t\tconst account = await updateWithHooks<Account>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tcreateVerificationValue: async (\n\t\t\tdata: Omit<Verification, \"createdAt\" | \"id\" | \"updatedAt\"> &\n\t\t\t\tPartial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification as Verification;\n\t\t},\n\t\tfindVerificationValue: async (identifier: string) => {\n\t\t\tconst verification = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Verification>({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\t\tvalue: identifier,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\",\n\t\t\t\t},\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\t\t\tvalue: new Date(),\n\t\t\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"verification\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lastVerification = verification[0];\n\t\t\treturn lastVerification as Verification | null;\n\t\t},\n\t\tdeleteVerificationValue: async (id: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"identifier\", value: identifier }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tupdateVerificationValue: async (\n\t\t\tid: string,\n\t\t\tdata: Partial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await updateWithHooks<Verification>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification;\n\t\t},\n\t};\n};\n","import { base64Url } from \"@better-auth/utils/base64\";\nimport type { OAuth2Tokens } from \"./oauth-provider\";\n\nexport function getOAuth2Tokens(data: Record<string, any>): OAuth2Tokens {\n\tconst getDate = (seconds: number) => {\n\t\tconst now = new Date();\n\t\treturn new Date(now.getTime() + seconds * 1000);\n\t};\n\n\treturn {\n\t\ttokenType: data.token_type,\n\t\taccessToken: data.access_token,\n\t\trefreshToken: data.refresh_token,\n\t\taccessTokenExpiresAt: data.expires_in\n\t\t\t? getDate(data.expires_in)\n\t\t\t: undefined,\n\t\trefreshTokenExpiresAt: data.refresh_token_expires_in\n\t\t\t? getDate(data.refresh_token_expires_in)\n\t\t\t: undefined,\n\t\tscopes: data?.scope\n\t\t\t? typeof data.scope === \"string\"\n\t\t\t\t? data.scope.split(\" \")\n\t\t\t\t: data.scope\n\t\t\t: [],\n\t\tidToken: data.id_token,\n\t\t// Preserve the raw token response for provider-specific fields\n\t\traw: data,\n\t};\n}\n\nexport async function generateCodeChallenge(codeVerifier: string) {\n\tconst encoder = new TextEncoder();\n\tconst data = encoder.encode(codeVerifier);\n\tconst hash = await crypto.subtle.digest(\"SHA-256\", data);\n\treturn base64Url.encode(new Uint8Array(hash), {\n\t\tpadding: false,\n\t});\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { refreshAccessToken, validateAuthorizationCode } from \"../oauth2\";\nexport interface DiscordProfile extends Record<string, any> {\n\t/** the user's id (i.e. the numerical snowflake) */\n\tid: string;\n\t/** the user's username, not unique across the platform */\n\tusername: string;\n\t/** the user's Discord-tag */\n\tdiscriminator: string;\n\t/** the user's display name, if it is set  */\n\tglobal_name: string | null;\n\t/**\n\t * the user's avatar hash:\n\t * https://discord.com/developers/docs/reference#image-formatting\n\t */\n\tavatar: string | null;\n\t/** whether the user belongs to an OAuth2 application */\n\tbot?: boolean | undefined;\n\t/**\n\t * whether the user is an Official Discord System user (part of the urgent\n\t * message system)\n\t */\n\tsystem?: boolean | undefined;\n\t/** whether the user has two factor enabled on their account */\n\tmfa_enabled: boolean;\n\t/**\n\t * the user's banner hash:\n\t * https://discord.com/developers/docs/reference#image-formatting\n\t */\n\tbanner: string | null;\n\n\t/** the user's banner color encoded as an integer representation of hexadecimal color code */\n\taccent_color: number | null;\n\n\t/**\n\t * the user's chosen language option:\n\t * https://discord.com/developers/docs/reference#locales\n\t */\n\tlocale: string;\n\t/** whether the email on this account has been verified */\n\tverified: boolean;\n\t/** the user's email */\n\temail: string;\n\t/**\n\t * the flags on a user's account:\n\t * https://discord.com/developers/docs/resources/user#user-object-user-flags\n\t */\n\tflags: number;\n\t/**\n\t * the type of Nitro subscription on a user's account:\n\t * https://discord.com/developers/docs/resources/user#user-object-premium-types\n\t */\n\tpremium_type: number;\n\t/**\n\t * the public flags on a user's account:\n\t * https://discord.com/developers/docs/resources/user#user-object-user-flags\n\t */\n\tpublic_flags: number;\n\t/** undocumented field; corresponds to the user's custom nickname */\n\tdisplay_name: string | null;\n\t/**\n\t * undocumented field; corresponds to the Discord feature where you can e.g.\n\t * put your avatar inside of an ice cube\n\t */\n\tavatar_decoration: string | null;\n\t/**\n\t * undocumented field; corresponds to the premium feature where you can\n\t * select a custom banner color\n\t */\n\tbanner_color: string | null;\n\t/** undocumented field; the CDN URL of their profile picture */\n\timage_url: string;\n}\n\nexport interface DiscordOptions extends ProviderOptions<DiscordProfile> {\n\tclientId: string;\n\tprompt?: (\"none\" | \"consent\") | undefined;\n\tpermissions?: number | undefined;\n}\n\nexport const discord = (options: DiscordOptions) => {\n\treturn {\n\t\tid: \"discord\",\n\t\tname: \"Discord\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"identify\", \"email\"];\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tconst hasBotScope = _scopes.includes(\"bot\");\n\t\t\tconst permissionsParam =\n\t\t\t\thasBotScope && options.permissions !== undefined\n\t\t\t\t\t? `&permissions=${options.permissions}`\n\t\t\t\t\t: \"\";\n\t\t\treturn new URL(\n\t\t\t\t`https://discord.com/api/oauth2/authorize?scope=${_scopes.join(\n\t\t\t\t\t\"+\",\n\t\t\t\t)}&response_type=code&client_id=${\n\t\t\t\t\toptions.clientId\n\t\t\t\t}&redirect_uri=${encodeURIComponent(\n\t\t\t\t\toptions.redirectURI || redirectURI,\n\t\t\t\t)}&state=${state}&prompt=${\n\t\t\t\t\toptions.prompt || \"none\"\n\t\t\t\t}${permissionsParam}`,\n\t\t\t);\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://discord.com/api/oauth2/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://discord.com/api/oauth2/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<DiscordProfile>(\n\t\t\t\t\"https://discord.com/api/users/@me\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (profile.avatar === null) {\n\t\t\t\tconst defaultAvatarNumber =\n\t\t\t\t\tprofile.discriminator === \"0\"\n\t\t\t\t\t\t? Number(BigInt(profile.id) >> BigInt(22)) % 6\n\t\t\t\t\t\t: parseInt(profile.discriminator) % 5;\n\t\t\t\tprofile.image_url = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;\n\t\t\t} else {\n\t\t\t\tconst format = profile.avatar.startsWith(\"a_\") ? \"gif\" : \"png\";\n\t\t\t\tprofile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.global_name || profile.username || \"\",\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: profile.verified,\n\t\t\t\t\timage: profile.image_url,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<DiscordProfile>;\n};\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { deleteSessionCookie, setSessionCookie } from \"../../cookies\";\nimport { generateRandomString } from \"../../crypto\";\nimport { parseUserInput, parseUserOutput } from \"../../db/schema\";\nimport type { AdditionalUserFieldsInput } from \"../../types\";\nimport { originCheck } from \"../middlewares\";\nimport { createEmailVerificationToken } from \"./email-verification\";\nimport {\n\tgetSessionFromCtx,\n\tsensitiveSessionMiddleware,\n\tsessionMiddleware,\n} from \"./session\";\n\nconst updateUserBodySchema = z.record(\n\tz.string().meta({\n\t\tdescription: \"Field name must be a string\",\n\t}),\n\tz.any(),\n);\n\nexport const updateUser = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/update-user\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"updateUser\",\n\t\t\tbody: updateUserBodySchema,\n\t\t\tuse: [sessionMiddleware],\n\t\t\tmetadata: {\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as Partial<AdditionalUserFieldsInput<O>> & {\n\t\t\t\t\t\tname?: string | undefined;\n\t\t\t\t\t\timage?: string | undefined | null;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"updateUser\",\n\t\t\t\t\tdescription: \"Update the current user\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The image of the user\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst body = ctx.body as {\n\t\t\t\tname?: string | undefined;\n\t\t\t\timage?: string | undefined;\n\t\t\t\t[key: string]: any;\n\t\t\t};\n\n\t\t\tif (typeof body !== \"object\" || Array.isArray(body)) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"Body must be an object\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (body.email) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst { name, image, ...rest } = body;\n\t\t\tconst session = ctx.context.session;\n\t\t\tconst additionalFields = parseUserInput(\n\t\t\t\tctx.context.options,\n\t\t\t\trest,\n\t\t\t\t\"update\",\n\t\t\t);\n\t\t\tif (\n\t\t\t\timage === undefined &&\n\t\t\t\tname === undefined &&\n\t\t\t\tObject.keys(additionalFields).length === 0\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"No fields to update\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst user = await ctx.context.internalAdapter.updateUser(\n\t\t\t\tsession.user.id,\n\t\t\t\t{\n\t\t\t\t\tname,\n\t\t\t\t\timage,\n\t\t\t\t\t...additionalFields,\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst updatedUser = user ?? {\n\t\t\t\t...session.user,\n\t\t\t\t...(name !== undefined && { name }),\n\t\t\t\t...(image !== undefined && { image }),\n\t\t\t\t...additionalFields,\n\t\t\t};\n\t\t\t/**\n\t\t\t * Update the session cookie with the new user data\n\t\t\t */\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: session.session,\n\t\t\t\tuser: updatedUser,\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t},\n\t);\n\nexport const changePassword = createAuthEndpoint(\n\t\"/change-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"changePassword\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The new password to set\n\t\t\t */\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The current password of the user\n\t\t\t */\n\t\t\tcurrentPassword: z.string().meta({\n\t\t\t\tdescription: \"The current password is required\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * revoke all sessions that are not the\n\t\t\t * current one logged in by the user\n\t\t\t */\n\t\t\trevokeOtherSessions: z\n\t\t\t\t.boolean()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Must be a boolean value\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"changePassword\",\n\t\t\t\tdescription: \"Change the password of the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Password successfully changed\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true, // Only present if revokeOtherSessions is true\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"New session token if other sessions were revoked\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email address of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was created\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { newPassword, currentPassword, revokeOtherSessions } = ctx.body;\n\t\tconst session = ctx.context.session;\n\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\tif (newPassword.length < minPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\n\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\n\t\tif (newPassword.length > maxPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst account = accounts.find(\n\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t);\n\t\tif (!account || !account.password) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND,\n\t\t\t});\n\t\t}\n\t\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\t\tconst verify = await ctx.context.password.verify({\n\t\t\thash: account.password,\n\t\t\tpassword: currentPassword,\n\t\t});\n\t\tif (!verify) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t});\n\t\t}\n\t\tawait ctx.context.internalAdapter.updateAccount(account.id, {\n\t\t\tpassword: passwordHash,\n\t\t});\n\t\tlet token = null;\n\t\tif (revokeOtherSessions) {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\t\t\tif (!newSession) {\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_SESSION,\n\t\t\t\t});\n\t\t\t}\n\t\t\t// set the new session cookie\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: newSession,\n\t\t\t\tuser: session.user,\n\t\t\t});\n\t\t\ttoken = newSession.token;\n\t\t}\n\n\t\treturn ctx.json({\n\t\t\ttoken,\n\t\t\tuser: parseUserOutput(ctx.context.options, session.user),\n\t\t});\n\t},\n);\n\nexport const setPassword = createAuthEndpoint(\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The new password to set\n\t\t\t */\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set is required\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t},\n\tasync (ctx) => {\n\t\tconst { newPassword } = ctx.body;\n\t\tconst session = ctx.context.session;\n\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\tif (newPassword.length < minPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\n\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\n\t\tif (newPassword.length > maxPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst account = accounts.find(\n\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t);\n\t\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\t\tif (!account) {\n\t\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\t\tuserId: session.user.id,\n\t\t\t\tproviderId: \"credential\",\n\t\t\t\taccountId: session.user.id,\n\t\t\t\tpassword: passwordHash,\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"user already has a password\",\n\t\t});\n\t},\n);\n\nexport const deleteUser = createAuthEndpoint(\n\t\"/delete-user\",\n\t{\n\t\tmethod: \"POST\",\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The callback URL to redirect to after the user is deleted\n\t\t\t * this is only used on delete user callback\n\t\t\t */\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The callback URL to redirect to after the user is deleted\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The password of the user. If the password isn't provided, session freshness\n\t\t\t * will be checked.\n\t\t\t */\n\t\t\tpassword: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The password of the user is required to delete the user\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The token to delete the user. If the token is provided, the user will be deleted\n\t\t\t */\n\t\t\ttoken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The token to delete the user is required\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"deleteUser\",\n\t\t\t\tdescription: \"Delete the user\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The callback URL to redirect to after the user is deleted\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpassword: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The user's password. Required if session is not fresh\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The deletion verification token\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"User deletion processed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the operation was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"User deleted\", \"Verification email sent\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Status message of the deletion process\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"success\", \"message\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Delete user is disabled. Enable it in the options\",\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\");\n\t\t}\n\t\tconst session = ctx.context.session;\n\n\t\tif (ctx.body.password) {\n\t\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\t\t\tconst account = accounts.find(\n\t\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t\t);\n\t\t\tif (!account || !account.password) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst verify = await ctx.context.password.verify({\n\t\t\t\thash: account.password,\n\t\t\t\tpassword: ctx.body.password,\n\t\t\t});\n\t\t\tif (!verify) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.body.token) {\n\t\t\t//@ts-expect-error\n\t\t\tawait deleteUserCallback({\n\t\t\t\t...ctx,\n\t\t\t\tquery: {\n\t\t\t\t\ttoken: ctx.body.token,\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"User deleted\",\n\t\t\t});\n\t\t}\n\n\t\tif (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {\n\t\t\tconst token = generateRandomString(32, \"0-9\", \"a-z\");\n\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\tvalue: session.user.id,\n\t\t\t\tidentifier: `delete-account-${token}`,\n\t\t\t\texpiresAt: new Date(\n\t\t\t\t\tDate.now() +\n\t\t\t\t\t\t(ctx.context.options.user.deleteUser?.deleteTokenExpiresIn ||\n\t\t\t\t\t\t\t60 * 60 * 24) *\n\t\t\t\t\t\t\t1000,\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst url = `${\n\t\t\t\tctx.context.baseURL\n\t\t\t}/delete-user/callback?token=${token}&callbackURL=${\n\t\t\t\tctx.body.callbackURL || \"/\"\n\t\t\t}`;\n\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\tctx.context.options.user.deleteUser.sendDeleteAccountVerification(\n\t\t\t\t\t{\n\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t},\n\t\t\t\t\tctx.request,\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Verification email sent\",\n\t\t\t});\n\t\t}\n\n\t\tif (!ctx.body.password && ctx.context.sessionConfig.freshAge !== 0) {\n\t\t\tconst currentAge = new Date(session.session.createdAt).getTime();\n\t\t\tconst freshAge = ctx.context.sessionConfig.freshAge * 1000;\n\t\t\tconst now = Date.now();\n\t\t\tif (now - currentAge > freshAge * 1000) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.SESSION_EXPIRED,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\t\tif (beforeDelete) {\n\t\t\tawait beforeDelete(session.user, ctx.request);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\tdeleteSessionCookie(ctx);\n\t\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\t\tif (afterDelete) {\n\t\t\tawait afterDelete(session.user, ctx.request);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"User deleted\",\n\t\t});\n\t},\n);\n\nexport const deleteUserCallback = createAuthEndpoint(\n\t\"/delete-user/callback\",\n\t{\n\t\tmethod: \"GET\",\n\t\tquery: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to verify the deletion request\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after deletion\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Callback to complete user deletion with verification token\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"User successfully deleted\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the deletion was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"User deleted\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Confirmation message\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"success\", \"message\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Delete user is disabled. Enable it in the options\",\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\");\n\t\t}\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t});\n\t\t}\n\t\tconst token = await ctx.context.internalAdapter.findVerificationValue(\n\t\t\t`delete-account-${ctx.query.token}`,\n\t\t);\n\t\tif (!token || token.expiresAt < new Date()) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tif (token.value !== session.user.id) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\t\tif (beforeDelete) {\n\t\t\tawait beforeDelete(session.user, ctx.request);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteAccounts(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteVerificationValue(token.id);\n\n\t\tdeleteSessionCookie(ctx);\n\n\t\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\t\tif (afterDelete) {\n\t\t\tawait afterDelete(session.user, ctx.request);\n\t\t}\n\t\tif (ctx.query.callbackURL) {\n\t\t\tthrow ctx.redirect(ctx.query.callbackURL || \"/\");\n\t\t}\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"User deleted\",\n\t\t});\n\t},\n);\n\nexport const changeEmail = createAuthEndpoint(\n\t\"/change-email\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tnewEmail: z.email().meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The new email address to set must be a valid email address\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"changeEmail\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Email change request processed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the request was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"Email updated\", \"Verification email sent\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Status message of the email change process\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"422\": {\n\t\t\t\t\t\tdescription: \"Unprocessable Entity. Email already exists\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.changeEmail?.enabled) {\n\t\t\tctx.context.logger.error(\"Change email is disabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Change email is disabled\",\n\t\t\t});\n\t\t}\n\n\t\tconst newEmail = ctx.body.newEmail.toLowerCase();\n\n\t\tif (newEmail === ctx.context.session.user.email) {\n\t\t\tctx.context.logger.error(\"Email is the same\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Email is the same\",\n\t\t\t});\n\t\t}\n\t\tconst existingUser =\n\t\t\tawait ctx.context.internalAdapter.findUserByEmail(newEmail);\n\t\tif (existingUser) {\n\t\t\tctx.context.logger.error(\"Email already exists\");\n\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * If the email is not verified, we can update the email if the option is enabled\n\t\t */\n\t\tif (\n\t\t\tctx.context.session.user.emailVerified !== true &&\n\t\t\tctx.context.options.user.changeEmail.updateEmailWithoutVerification\n\t\t) {\n\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(\n\t\t\t\tctx.context.session.user.email,\n\t\t\t\t{\n\t\t\t\t\temail: newEmail,\n\t\t\t\t},\n\t\t\t);\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: ctx.context.session.session,\n\t\t\t\tuser: {\n\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\temail: newEmail,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\tnewEmail,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\tconst url = `${\n\t\t\t\t\tctx.context.baseURL\n\t\t\t\t}/verify-email?token=${token}&callbackURL=${\n\t\t\t\t\tctx.body.callbackURL || \"/\"\n\t\t\t\t}`;\n\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\t\t\t\temail: newEmail,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tctx.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * If the email is verified, we need to send a verification email\n\t\t */\n\t\tconst sendConfirmationToOldEmail =\n\t\t\tctx.context.session.user.emailVerified &&\n\t\t\t(ctx.context.options.user.changeEmail.sendChangeEmailConfirmation ||\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailVerification);\n\n\t\tif (sendConfirmationToOldEmail) {\n\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\tctx.context.secret,\n\t\t\t\tctx.context.session.user.email,\n\t\t\t\tnewEmail,\n\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t{\n\t\t\t\t\trequestType: \"change-email-confirmation\",\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst url = `${\n\t\t\t\tctx.context.baseURL\n\t\t\t}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\t\tconst sendFn =\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailConfirmation ||\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailVerification;\n\t\t\tif (sendFn) {\n\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\tsendFn(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser: ctx.context.session.user,\n\t\t\t\t\t\t\tnewEmail: newEmail,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tctx.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\n\t\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t\t});\n\t\t}\n\n\t\tconst token = await createEmailVerificationToken(\n\t\t\tctx.context.secret,\n\t\t\tctx.context.session.user.email,\n\t\t\tnewEmail,\n\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t{\n\t\t\t\trequestType: \"change-email-verification\",\n\t\t\t},\n\t\t);\n\t\tconst url = `${\n\t\t\tctx.context.baseURL\n\t\t}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t{\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\t\temail: newEmail,\n\t\t\t\t\t},\n\t\t\t\t\turl,\n\t\t\t\t\ttoken,\n\t\t\t\t},\n\t\t\t\tctx.request,\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { refreshAccessToken, validateAuthorizationCode } from \"../oauth2\";\n\n/**\n * [More info](https://developers.tiktok.com/doc/tiktok-api-v2-get-user-info/)\n */\nexport interface TiktokProfile extends Record<string, any> {\n\tdata: {\n\t\tuser: {\n\t\t\t/**\n\t\t\t * The unique identification of the user in the current application.Open id\n\t\t\t * for the client.\n\t\t\t *\n\t\t\t * To return this field, add `fields=open_id` in the user profile request's query parameter.\n\t\t\t */\n\t\t\topen_id: string;\n\t\t\t/**\n\t\t\t * The unique identification of the user across different apps for the same developer.\n\t\t\t * For example, if a partner has X number of clients,\n\t\t\t * it will get X number of open_id for the same TikTok user,\n\t\t\t * but one persistent union_id for the particular user.\n\t\t\t *\n\t\t\t * To return this field, add `fields=union_id` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tunion_id?: string | undefined;\n\t\t\t/**\n\t\t\t * User's profile image.\n\t\t\t *\n\t\t\t * To return this field, add `fields=avatar_url` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tavatar_url?: string | undefined;\n\t\t\t/**\n\t\t\t * User`s profile image in 100x100 size.\n\t\t\t *\n\t\t\t * To return this field, add `fields=avatar_url_100` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tavatar_url_100?: string | undefined;\n\t\t\t/**\n\t\t\t * User's profile image with higher resolution\n\t\t\t *\n\t\t\t * To return this field, add `fields=avatar_url_100` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tavatar_large_url: string;\n\t\t\t/**\n\t\t\t * User's profile name\n\t\t\t *\n\t\t\t * To return this field, add `fields=display_name` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tdisplay_name: string;\n\t\t\t/**\n\t\t\t * User's username.\n\t\t\t *\n\t\t\t * To return this field, add `fields=username` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tusername: string;\n\t\t\t/** @note Email is currently unsupported by TikTok  */\n\t\t\temail?: string | undefined;\n\t\t\t/**\n\t\t\t * User's bio description if there is a valid one.\n\t\t\t *\n\t\t\t * To return this field, add `fields=bio_description` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tbio_description?: string | undefined;\n\t\t\t/**\n\t\t\t * The link to user's TikTok profile page.\n\t\t\t *\n\t\t\t * To return this field, add `fields=profile_deep_link` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tprofile_deep_link?: string | undefined;\n\t\t\t/**\n\t\t\t * Whether TikTok has provided a verified badge to the account after confirming\n\t\t\t * that it belongs to the user it represents.\n\t\t\t *\n\t\t\t * To return this field, add `fields=is_verified` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tis_verified?: boolean | undefined;\n\t\t\t/**\n\t\t\t * User's followers count.\n\t\t\t *\n\t\t\t * To return this field, add `fields=follower_count` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tfollower_count?: number | undefined;\n\t\t\t/**\n\t\t\t * The number of accounts that the user is following.\n\t\t\t *\n\t\t\t * To return this field, add `fields=following_count` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tfollowing_count?: number | undefined;\n\t\t\t/**\n\t\t\t * The total number of likes received by the user across all of their videos.\n\t\t\t *\n\t\t\t * To return this field, add `fields=likes_count` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tlikes_count?: number | undefined;\n\t\t\t/**\n\t\t\t * The total number of publicly posted videos by the user.\n\t\t\t *\n\t\t\t * To return this field, add `fields=video_count` in the user profile request's query parameter.\n\t\t\t */\n\t\t\tvideo_count?: number | undefined;\n\t\t};\n\t};\n\terror?:\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * The error category in string.\n\t\t\t\t */\n\t\t\t\tcode?: string;\n\t\t\t\t/**\n\t\t\t\t * The error message in string.\n\t\t\t\t */\n\t\t\t\tmessage?: string;\n\t\t\t\t/**\n\t\t\t\t * The error message in string.\n\t\t\t\t */\n\t\t\t\tlog_id?: string;\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface TiktokOptions extends ProviderOptions {\n\t// Client ID is not used in TikTok, we delete it from the options\n\tclientId?: never | undefined;\n\tclientSecret: string;\n\tclientKey: string;\n}\n\nexport const tiktok = (options: TiktokOptions) => {\n\treturn {\n\t\tid: \"tiktok\",\n\t\tname: \"TikTok\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user.info.profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn new URL(\n\t\t\t\t`https://www.tiktok.com/v2/auth/authorize?scope=${_scopes.join(\n\t\t\t\t\t\",\",\n\t\t\t\t)}&response_type=code&client_key=${options.clientKey}&redirect_uri=${encodeURIComponent(\n\t\t\t\t\toptions.redirectURI || redirectURI,\n\t\t\t\t)}&state=${state}`,\n\t\t\t);\n\t\t},\n\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions: {\n\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t},\n\t\t\t\ttokenEndpoint: \"https://open.tiktokapis.com/v2/oauth/token/\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://open.tiktokapis.com/v2/oauth/token/\",\n\t\t\t\t\t\tauthentication: \"post\",\n\t\t\t\t\t\textraParams: {\n\t\t\t\t\t\t\tclient_key: options.clientKey,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tconst fields = [\n\t\t\t\t\"open_id\",\n\t\t\t\t\"avatar_large_url\",\n\t\t\t\t\"display_name\",\n\t\t\t\t\"username\",\n\t\t\t];\n\t\t\tconst { data: profile, error } = await betterFetch<TiktokProfile>(\n\t\t\t\t`https://open.tiktokapis.com/v2/user/info/?fields=${fields.join(\",\")}`,\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\temail: profile.data.user.email || profile.data.user.username,\n\t\t\t\t\tid: profile.data.user.open_id,\n\t\t\t\t\tname: profile.data.user.display_name || profile.data.user.username,\n\t\t\t\t\timage: profile.data.user.avatar_large_url,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<TiktokProfile, TiktokOptions>;\n};\n","import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nfunction checkHasPath(url: string): boolean {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tconst pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n\t\treturn pathname !== \"/\";\n\t} catch {\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t);\n\t}\n}\n\nfunction assertHasProtocol(url: string): void {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`,\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t\t{\n\t\t\t\tcause: error,\n\t\t\t},\n\t\t);\n\t}\n}\n\nfunction withPath(url: string, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\n\tconst hasPath = checkHasPath(url);\n\tif (hasPath) {\n\t\treturn url;\n\t}\n\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\n\tif (!path || path === \"/\") {\n\t\treturn trimmedUrl;\n\t}\n\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\n\nfunction validateProxyHeader(header: string, type: \"host\" | \"proto\"): boolean {\n\tif (!header || header.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif (type === \"proto\") {\n\t\t// Only allow http and https protocols\n\t\treturn header === \"http\" || header === \"https\";\n\t}\n\n\tif (type === \"host\") {\n\t\tconst suspiciousPatterns = [\n\t\t\t/\\.\\./, // Path traversal\n\t\t\t/\\0/, // Null bytes\n\t\t\t/[\\s]/, // Whitespace (except legitimate spaces that should be trimmed)\n\t\t\t/^[.]/, // Starting with dot\n\t\t\t/[<>'\"]/, // HTML/script injection characters\n\t\t\t/javascript:/i, // Protocol injection\n\t\t\t/file:/i, // File protocol\n\t\t\t/data:/i, // Data protocol\n\t\t];\n\n\t\tif (suspiciousPatterns.some((pattern) => pattern.test(header))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Basic hostname validation (allows localhost, IPs, and domains with ports)\n\t\t// This is a simple check, not exhaustive RFC validation\n\t\tconst hostnameRegex =\n\t\t\t/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv4 addresses\n\t\tconst ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv6 addresses in brackets\n\t\tconst ipv6Regex = /^\\[[0-9a-fA-F:]+\\](:[0-9]{1,5})?$/;\n\n\t\t// Allow localhost variations\n\t\tconst localhostRegex = /^localhost(:[0-9]{1,5})?$/i;\n\n\t\treturn (\n\t\t\thostnameRegex.test(header) ||\n\t\t\tipv4Regex.test(header) ||\n\t\t\tipv6Regex.test(header) ||\n\t\t\tlocalhostRegex.test(header)\n\t\t);\n\t}\n\n\treturn false;\n}\n\nexport function getBaseURL(\n\turl?: string,\n\tpath?: string,\n\trequest?: Request,\n\tloadEnv?: boolean,\n\ttrustedProxyHeaders?: boolean | undefined,\n) {\n\tif (url) {\n\t\treturn withPath(url, path);\n\t}\n\n\tif (loadEnv !== false) {\n\t\tconst fromEnv =\n\t\t\tenv.BETTER_AUTH_URL ||\n\t\t\tenv.NEXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_AUTH_URL ||\n\t\t\t(env.BASE_URL !== \"/\" ? env.BASE_URL : undefined);\n\n\t\tif (fromEnv) {\n\t\t\treturn withPath(fromEnv, path);\n\t\t}\n\t}\n\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) {\n\t\tif (\n\t\t\tvalidateProxyHeader(fromRequestProto, \"proto\") &&\n\t\t\tvalidateProxyHeader(fromRequest, \"host\")\n\t\t) {\n\t\t\ttry {\n\t\t\t\treturn withPath(`${fromRequestProto}://${fromRequest}`, path);\n\t\t\t} catch (_error) {}\n\t\t}\n\t}\n\n\tif (request) {\n\t\tconst url = getOrigin(request.url);\n\t\tif (!url) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Could not get origin from request. Please provide a valid base URL.\",\n\t\t\t);\n\t\t}\n\t\treturn withPath(url, path);\n\t}\n\n\tif (typeof window !== \"undefined\" && window.location) {\n\t\treturn withPath(window.location.origin, path);\n\t}\n\treturn undefined;\n}\n\nexport function getOrigin(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\t// For custom URL schemes (like exp://), the origin property returns the string \"null\"\n\t\t// instead of null. We need to handle this case and return null so the fallback logic works.\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getProtocol(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.protocol;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getHost(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.host;\n\t} catch {\n\t\treturn null;\n\t}\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { APIError } from \"better-call\";\nimport { decodeJwt, decodeProtectedHeader, importJWK, jwtVerify } from \"jose\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface CognitoProfile {\n\tsub: string;\n\temail: string;\n\temail_verified: boolean;\n\tname: string;\n\tgiven_name?: string | undefined;\n\tfamily_name?: string | undefined;\n\tpicture?: string | undefined;\n\tusername?: string | undefined;\n\tlocale?: string | undefined;\n\tphone_number?: string | undefined;\n\tphone_number_verified?: boolean | undefined;\n\taud: string;\n\tiss: string;\n\texp: number;\n\tiat: number;\n\t// Custom attributes from Cognito can be added here\n\t[key: string]: any;\n}\n\nexport interface CognitoOptions extends ProviderOptions<CognitoProfile> {\n\tclientId: string;\n\t/**\n\t * The Cognito domain (e.g., \"your-app.auth.us-east-1.amazoncognito.com\")\n\t */\n\tdomain: string;\n\t/**\n\t * AWS region where User Pool is hosted (e.g., \"us-east-1\")\n\t */\n\tregion: string;\n\tuserPoolId: string;\n\trequireClientSecret?: boolean | undefined;\n}\n\nexport const cognito = (options: CognitoOptions) => {\n\tif (!options.domain || !options.region || !options.userPoolId) {\n\t\tlogger.error(\n\t\t\t\"Domain, region and userPoolId are required for Amazon Cognito. Make sure to provide them in the options.\",\n\t\t);\n\t\tthrow new BetterAuthError(\"DOMAIN_AND_REGION_REQUIRED\");\n\t}\n\n\tconst cleanDomain = options.domain.replace(/^https?:\\/\\//, \"\");\n\tconst authorizationEndpoint = `https://${cleanDomain}/oauth2/authorize`;\n\tconst tokenEndpoint = `https://${cleanDomain}/oauth2/token`;\n\tconst userInfoEndpoint = `https://${cleanDomain}/oauth2/userinfo`;\n\n\treturn {\n\t\tid: \"cognito\",\n\t\tname: \"Cognito\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"ClientId is required for Amazon Cognito. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\n\t\t\tif (options.requireClientSecret && !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Secret is required when requireClientSecret is true. Make sure to provide it in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"cognito\",\n\t\t\t\toptions: {\n\t\t\t\t\t...options,\n\t\t\t\t},\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t});\n\t\t\t// AWS Cognito requires scopes to be encoded with %20 instead of +\n\t\t\t// URLSearchParams encodes spaces as + by default, so we need to fix this\n\t\t\tconst scopeValue = url.searchParams.get(\"scope\");\n\t\t\tif (scopeValue) {\n\t\t\t\turl.searchParams.delete(\"scope\");\n\t\t\t\tconst encodedScope = encodeURIComponent(scopeValue);\n\t\t\t\t// Manually append the scope with proper encoding to the URL\n\t\t\t\tconst urlString = url.toString();\n\t\t\t\tconst separator = urlString.includes(\"?\") ? \"&\" : \"?\";\n\t\t\t\treturn new URL(`${urlString}${separator}scope=${encodedScope}`);\n\t\t\t}\n\t\t\treturn url;\n\t\t},\n\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst decodedHeader = decodeProtectedHeader(token);\n\t\t\t\tconst { kid, alg: jwtAlg } = decodedHeader;\n\t\t\t\tif (!kid || !jwtAlg) return false;\n\n\t\t\t\tconst publicKey = await getCognitoPublicKey(\n\t\t\t\t\tkid,\n\t\t\t\t\toptions.region,\n\t\t\t\t\toptions.userPoolId,\n\t\t\t\t);\n\t\t\t\tconst expectedIssuer = `https://cognito-idp.${options.region}.amazonaws.com/${options.userPoolId}`;\n\n\t\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, publicKey, {\n\t\t\t\t\talgorithms: [jwtAlg],\n\t\t\t\t\tissuer: expectedIssuer,\n\t\t\t\t\taudience: options.clientId,\n\t\t\t\t\tmaxTokenAge: \"1h\",\n\t\t\t\t});\n\n\t\t\t\tif (nonce && jwtClaims.nonce !== nonce) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to verify ID token:\", error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tif (token.idToken) {\n\t\t\t\ttry {\n\t\t\t\t\tconst profile = decodeJwt<CognitoProfile>(token.idToken);\n\t\t\t\t\tif (!profile) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tconst name =\n\t\t\t\t\t\tprofile.name ||\n\t\t\t\t\t\tprofile.given_name ||\n\t\t\t\t\t\tprofile.username ||\n\t\t\t\t\t\tprofile.email;\n\t\t\t\t\tconst enrichedProfile = {\n\t\t\t\t\t\t...profile,\n\t\t\t\t\t\tname,\n\t\t\t\t\t};\n\t\t\t\t\tconst userMap = await options.mapProfileToUser?.(enrichedProfile);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\tid: profile.sub,\n\t\t\t\t\t\t\tname: enrichedProfile.name,\n\t\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t\t\t...userMap,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: enrichedProfile,\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error(\"Failed to decode ID token:\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token.accessToken) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { data: userInfo } = await betterFetch<CognitoProfile>(\n\t\t\t\t\t\tuserInfoEndpoint,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\tif (userInfo) {\n\t\t\t\t\t\tconst userMap = await options.mapProfileToUser?.(userInfo);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\tid: userInfo.sub,\n\t\t\t\t\t\t\t\tname: userInfo.name || userInfo.given_name || userInfo.username,\n\t\t\t\t\t\t\t\temail: userInfo.email,\n\t\t\t\t\t\t\t\timage: userInfo.picture,\n\t\t\t\t\t\t\t\temailVerified: userInfo.email_verified,\n\t\t\t\t\t\t\t\t...userMap,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdata: userInfo,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user info from Cognito:\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\toptions,\n\t} satisfies OAuthProvider<CognitoProfile>;\n};\n\nexport const getCognitoPublicKey = async (\n\tkid: string,\n\tregion: string,\n\tuserPoolId: string,\n) => {\n\tconst COGNITO_JWKS_URI = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}/.well-known/jwks.json`;\n\n\ttry {\n\t\tconst { data } = await betterFetch<{\n\t\t\tkeys: Array<{\n\t\t\t\tkid: string;\n\t\t\t\talg: string;\n\t\t\t\tkty: string;\n\t\t\t\tuse: string;\n\t\t\t\tn: string;\n\t\t\t\te: string;\n\t\t\t}>;\n\t\t}>(COGNITO_JWKS_URI);\n\n\t\tif (!data?.keys) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Keys not found\",\n\t\t\t});\n\t\t}\n\n\t\tconst jwk = data.keys.find((key) => key.kid === kid);\n\t\tif (!jwk) {\n\t\t\tthrow new Error(`JWK with kid ${kid} not found`);\n\t\t}\n\n\t\treturn await importJWK(jwk, jwk.alg);\n\t} catch (error) {\n\t\tlogger.error(\"Failed to fetch Cognito public key:\", error);\n\t\tthrow error;\n\t}\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { refreshAccessToken, validateAuthorizationCode } from \"../oauth2\";\n\nexport interface RobloxProfile extends Record<string, any> {\n\t/** the user's id */\n\tsub: string;\n\t/** the user's username */\n\tpreferred_username: string;\n\t/** the user's display name, will return the same value as the preferred_username if not set */\n\tnickname: string;\n\t/** the user's display name, again, will return the same value as the preferred_username if not set */\n\tname: string;\n\t/** the account creation date as a unix timestamp in seconds */\n\tcreated_at: number;\n\t/** the user's profile URL */\n\tprofile: string;\n\t/** the user's avatar URL */\n\tpicture: string;\n}\n\nexport interface RobloxOptions extends ProviderOptions<RobloxProfile> {\n\tclientId: string;\n\tprompt?:\n\t\t| (\n\t\t\t\t| \"none\"\n\t\t\t\t| \"consent\"\n\t\t\t\t| \"login\"\n\t\t\t\t| \"select_account\"\n\t\t\t\t| \"select_account consent\"\n\t\t  )\n\t\t| undefined;\n}\n\nexport const roblox = (options: RobloxOptions) => {\n\treturn {\n\t\tid: \"roblox\",\n\t\tname: \"Roblox\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"openid\", \"profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn new URL(\n\t\t\t\t`https://apis.roblox.com/oauth/v1/authorize?scope=${_scopes.join(\n\t\t\t\t\t\"+\",\n\t\t\t\t)}&response_type=code&client_id=${\n\t\t\t\t\toptions.clientId\n\t\t\t\t}&redirect_uri=${encodeURIComponent(\n\t\t\t\t\toptions.redirectURI || redirectURI,\n\t\t\t\t)}&state=${state}&prompt=${options.prompt || \"select_account consent\"}`,\n\t\t\t);\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://apis.roblox.com/oauth/v1/token\",\n\t\t\t\tauthentication: \"post\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://apis.roblox.com/oauth/v1/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<RobloxProfile>(\n\t\t\t\t\"https://apis.roblox.com/oauth/v1/userinfo\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t// Roblox does not provide email or email_verified claim.\n\t\t\t// We default to false for security consistency.\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.nickname || profile.preferred_username || \"\",\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temail: profile.preferred_username || null, // Roblox does not provide email\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: {\n\t\t\t\t\t...profile,\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<RobloxProfile>;\n};\n","import { BetterAuthError } from \"@better-auth/core/error\";\nimport { hex } from \"@better-auth/utils/hex\";\nimport { scryptAsync } from \"@noble/hashes/scrypt.js\";\nimport { hexToBytes } from \"@noble/hashes/utils.js\";\nimport { constantTimeEqual } from \"./buffer\";\n\nconst config = {\n\tN: 16384,\n\tr: 16,\n\tp: 1,\n\tdkLen: 64,\n};\n\nasync function generateKey(password: string, salt: string) {\n\treturn await scryptAsync(password.normalize(\"NFKC\"), salt, {\n\t\tN: config.N,\n\t\tp: config.p,\n\t\tr: config.r,\n\t\tdkLen: config.dkLen,\n\t\tmaxmem: 128 * config.N * config.r * 2,\n\t});\n}\n\nexport const hashPassword = async (password: string) => {\n\tconst salt = hex.encode(crypto.getRandomValues(new Uint8Array(16)));\n\tconst key = await generateKey(password, salt);\n\treturn `${salt}:${hex.encode(key)}`;\n};\n\nexport const verifyPassword = async ({\n\thash,\n\tpassword,\n}: {\n\thash: string;\n\tpassword: string;\n}) => {\n\tconst [salt, key] = hash.split(\":\");\n\tif (!salt || !key) {\n\t\tthrow new BetterAuthError(\"Invalid password hash\");\n\t}\n\tconst targetKey = await generateKey(password, salt!);\n\treturn constantTimeEqual(targetKey, hexToBytes(key));\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { APIError } from \"better-call\";\nimport { decodeJwt, decodeProtectedHeader, importJWK, jwtVerify } from \"jose\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\nexport interface AppleProfile {\n\t/**\n\t * The subject registered claim identifies the principal thats the subject\n\t * of the identity token. Because this token is for your app, the value is\n\t * the unique identifier for the user.\n\t */\n\tsub: string;\n\t/**\n\t * A String value representing the user's email address.\n\t * The email address is either the user's real email address or the proxy\n\t * address, depending on their status private email relay service.\n\t */\n\temail: string;\n\t/**\n\t * A string or Boolean value that indicates whether the service verifies\n\t * the email. The value can either be a string (\"true\" or \"false\") or a\n\t * Boolean (true or false). The system may not verify email addresses for\n\t * Sign in with Apple at Work & School users, and this claim is \"false\" or\n\t * false for those users.\n\t */\n\temail_verified: true | \"true\";\n\t/**\n\t * A string or Boolean value that indicates whether the email that the user\n\t * shares is the proxy address. The value can either be a string (\"true\" or\n\t * \"false\") or a Boolean (true or false).\n\t */\n\tis_private_email: boolean;\n\t/**\n\t * An Integer value that indicates whether the user appears to be a real\n\t * person. Use the value of this claim to mitigate fraud. The possible\n\t * values are: 0 (or Unsupported), 1 (or Unknown), 2 (or LikelyReal). For\n\t * more information, see ASUserDetectionStatus. This claim is present only\n\t * in iOS 14 and later, macOS 11 and later, watchOS 7 and later, tvOS 14\n\t * and later. The claim isnt present or supported for web-based apps.\n\t */\n\treal_user_status: number;\n\t/**\n\t * The users full name in the format provided during the authorization\n\t * process.\n\t */\n\tname: string;\n\t/**\n\t * The URL to the user's profile picture.\n\t */\n\tpicture: string;\n\tuser?: AppleNonConformUser | undefined;\n}\n\n/**\n * This is the shape of the `user` query parameter that Apple sends the first\n * time the user consents to the app.\n * @see https://developer.apple.com/documentation/signinwithapplerestapi/request-an-authorization-to-the-sign-in-with-apple-server./\n */\nexport interface AppleNonConformUser {\n\tname: {\n\t\tfirstName: string;\n\t\tlastName: string;\n\t};\n\temail: string;\n}\n\nexport interface AppleOptions extends ProviderOptions<AppleProfile> {\n\tclientId: string;\n\tappBundleIdentifier?: string | undefined;\n\taudience?: (string | string[]) | undefined;\n}\n\nexport const apple = (options: AppleOptions) => {\n\tconst tokenEndpoint = \"https://appleid.apple.com/auth/token\";\n\treturn {\n\t\tid: \"apple\",\n\t\tname: \"Apple\",\n\t\tasync createAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scope = options.disableDefaultScope ? [] : [\"email\", \"name\"];\n\t\t\tif (options.scope) _scope.push(...options.scope);\n\t\t\tif (scopes) _scope.push(...scopes);\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"apple\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://appleid.apple.com/auth/authorize\",\n\t\t\t\tscopes: _scope,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tresponseMode: \"form_post\",\n\t\t\t\tresponseType: \"code id_token\",\n\t\t\t});\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\t\t\tconst decodedHeader = decodeProtectedHeader(token);\n\t\t\tconst { kid, alg: jwtAlg } = decodedHeader;\n\t\t\tif (!kid || !jwtAlg) return false;\n\t\t\tconst publicKey = await getApplePublicKey(kid);\n\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, publicKey, {\n\t\t\t\talgorithms: [jwtAlg],\n\t\t\t\tissuer: \"https://appleid.apple.com\",\n\t\t\t\taudience:\n\t\t\t\t\toptions.audience && options.audience.length\n\t\t\t\t\t\t? options.audience\n\t\t\t\t\t\t: options.appBundleIdentifier\n\t\t\t\t\t\t\t? options.appBundleIdentifier\n\t\t\t\t\t\t\t: options.clientId,\n\t\t\t\tmaxTokenAge: \"1h\",\n\t\t\t});\n\t\t\t[\"email_verified\", \"is_private_email\"].forEach((field) => {\n\t\t\t\tif (jwtClaims[field] !== undefined) {\n\t\t\t\t\tjwtClaims[field] = Boolean(jwtClaims[field]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (nonce && jwtClaims.nonce !== nonce) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn !!jwtClaims;\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://appleid.apple.com/auth/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tif (!token.idToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst profile = decodeJwt<AppleProfile>(token.idToken);\n\t\t\tif (!profile) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// TODO: \" \" masking will be removed when the name field is made optional\n\t\t\tlet name: string;\n\t\t\tif (token.user?.name) {\n\t\t\t\tconst firstName = token.user.name.firstName || \"\";\n\t\t\t\tconst lastName = token.user.name.lastName || \"\";\n\t\t\t\tconst fullName = `${firstName} ${lastName}`.trim();\n\t\t\t\tname = fullName || \" \";\n\t\t\t} else {\n\t\t\t\tname = profile.name || \" \";\n\t\t\t}\n\n\t\t\tconst emailVerified =\n\t\t\t\ttypeof profile.email_verified === \"boolean\"\n\t\t\t\t\t? profile.email_verified\n\t\t\t\t\t: profile.email_verified === \"true\";\n\t\t\tconst enrichedProfile = {\n\t\t\t\t...profile,\n\t\t\t\tname,\n\t\t\t};\n\t\t\tconst userMap = await options.mapProfileToUser?.(enrichedProfile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: enrichedProfile.name,\n\t\t\t\t\temailVerified: emailVerified,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: enrichedProfile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<AppleProfile>;\n};\n\nexport const getApplePublicKey = async (kid: string) => {\n\tconst APPLE_BASE_URL = \"https://appleid.apple.com\";\n\tconst JWKS_APPLE_URI = \"/auth/keys\";\n\tconst { data } = await betterFetch<{\n\t\tkeys: Array<{\n\t\t\tkid: string;\n\t\t\talg: string;\n\t\t\tkty: string;\n\t\t\tuse: string;\n\t\t\tn: string;\n\t\t\te: string;\n\t\t}>;\n\t}>(`${APPLE_BASE_URL}${JWKS_APPLE_URI}`);\n\tif (!data?.keys) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Keys not found\",\n\t\t});\n\t}\n\tconst jwk = data.keys.find((key) => key.kid === kid);\n\tif (!jwk) {\n\t\tthrow new Error(`JWK with kid ${kid} not found`);\n\t}\n\treturn await importJWK(jwk, jwk.alg);\n};\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { SocialProviderListEnum } from \"@better-auth/core/social-providers\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport { handleOAuthUserInfo } from \"../../oauth2/link-account\";\nimport type { InferUser } from \"../../types\";\nimport { generateState } from \"../../utils\";\nimport { formCsrfMiddleware } from \"../middlewares/origin-check\";\nimport { createEmailVerificationToken } from \"./email-verification\";\n\nconst socialSignInBodySchema = z.object({\n\t/**\n\t * Callback URL to redirect to after the user\n\t * has signed in.\n\t */\n\tcallbackURL: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"Callback URL to redirect to after the user has signed in\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * callback url to redirect if the user is newly registered.\n\t *\n\t * useful if you have different routes for existing users and new users\n\t */\n\tnewUserCallbackURL: z.string().optional(),\n\t/**\n\t * Callback url to redirect to if an error happens\n\t *\n\t * If it's initiated from the client sdk this defaults to\n\t * the current url.\n\t */\n\terrorCallbackURL: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"Callback URL to redirect to if an error happens\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * OAuth2 provider to use`\n\t */\n\tprovider: SocialProviderListEnum,\n\t/**\n\t * Disable automatic redirection to the provider\n\t *\n\t * This is useful if you want to handle the redirection\n\t * yourself like in a popup or a different tab.\n\t */\n\tdisableRedirect: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Disable automatic redirection to the provider. Useful for handling the redirection yourself\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * ID token from the provider\n\t *\n\t * This is used to sign in the user\n\t * if the user is already signed in with the\n\t * provider in the frontend.\n\t *\n\t * Only applicable if the provider supports\n\t * it. Currently only `apple` and `google` is\n\t * supported out of the box.\n\t */\n\tidToken: z.optional(\n\t\tz.object({\n\t\t\t/**\n\t\t\t * ID token from the provider\n\t\t\t */\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"ID token from the provider\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The nonce used to generate the token\n\t\t\t */\n\t\t\tnonce: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Nonce used to generate the token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Access token from the provider\n\t\t\t */\n\t\t\taccessToken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Access token from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Refresh token from the provider\n\t\t\t */\n\t\t\trefreshToken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Refresh token from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Expiry date of the token\n\t\t\t */\n\t\t\texpiresAt: z\n\t\t\t\t.number()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Expiry date of the token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t),\n\tscopes: z\n\t\t.array(z.string())\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Array of scopes to request from the provider. This will override the default scopes passed.\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Explicitly request sign-up\n\t *\n\t * Should be used to allow sign up when\n\t * disableImplicitSignUp for this provider is\n\t * true\n\t */\n\trequestSignUp: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * The login hint to use for the authorization code request\n\t */\n\tloginHint: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"The login hint to use for the authorization code request\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Additional data to be passed through the OAuth flow\n\t */\n\tadditionalData: z.record(z.string(), z.any()).optional().meta({\n\t\tdescription: \"Additional data to be passed through the OAuth flow\",\n\t}),\n});\n\nexport const signInSocial = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-in/social\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"socialSignIn\",\n\t\t\tbody: socialSignInBodySchema,\n\t\t\tmetadata: {\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as z.infer<typeof socialSignInBodySchema>,\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\tredirect: boolean;\n\t\t\t\t\t\ttoken?: string | undefined;\n\t\t\t\t\t\turl?: string | undefined;\n\t\t\t\t\t\tuser?: InferUser<O> | undefined;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Sign in with a social provider\",\n\t\t\t\t\toperationId: \"socialSignIn\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Success - Returns either session details or redirect URL\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\t// todo: we need support for multiple schema\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tenum: [false],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"redirect\", \"token\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tc,\n\t\t): Promise<\n\t\t\t| { redirect: boolean; url: string }\n\t\t\t| { redirect: boolean; token: string; url: undefined; user: InferUser<O> }\n\t\t> => {\n\t\t\tconst provider = c.context.socialProviders.find(\n\t\t\t\t(p) => p.id === c.body.provider,\n\t\t\t);\n\t\t\tif (!provider) {\n\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\"Provider not found. Make sure to add the provider in your auth config\",\n\t\t\t\t\t{\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.PROVIDER_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (c.body.idToken) {\n\t\t\t\tif (!provider.verifyIdToken) {\n\t\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\t\"Provider does not support id token verification\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst { token, nonce } = c.body.idToken;\n\t\t\t\tconst valid = await provider.verifyIdToken(token, nonce);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tc.context.logger.error(\"Invalid id token\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst userInfo = await provider.getUserInfo({\n\t\t\t\t\tidToken: token,\n\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t\t});\n\t\t\t\tif (!userInfo || !userInfo?.user) {\n\t\t\t\t\tc.context.logger.error(\"Failed to get user info\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!userInfo.user.email) {\n\t\t\t\t\tc.context.logger.error(\"User email not found\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst data = await handleOAuthUserInfo(c, {\n\t\t\t\t\tuserInfo: {\n\t\t\t\t\t\t...userInfo.user,\n\t\t\t\t\t\temail: userInfo.user.email,\n\t\t\t\t\t\tid: String(userInfo.user.id),\n\t\t\t\t\t\tname: userInfo.user.name || \"\",\n\t\t\t\t\t\timage: userInfo.user.image,\n\t\t\t\t\t\temailVerified: userInfo.user.emailVerified || false,\n\t\t\t\t\t},\n\t\t\t\t\taccount: {\n\t\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\t\taccountId: String(userInfo.user.id),\n\t\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\t},\n\t\t\t\t\tcallbackURL: c.body.callbackURL,\n\t\t\t\t\tdisableSignUp:\n\t\t\t\t\t\t(provider.disableImplicitSignUp && !c.body.requestSignUp) ||\n\t\t\t\t\t\tprovider.disableSignUp,\n\t\t\t\t});\n\t\t\t\tif (data.error) {\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: data.error,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(c, data.data!);\n\t\t\t\treturn c.json({\n\t\t\t\t\tredirect: false,\n\t\t\t\t\ttoken: data.data!.session.token,\n\t\t\t\t\turl: undefined,\n\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\tc.context.options,\n\t\t\t\t\t\tdata.data!.user,\n\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { codeVerifier, state } = await generateState(\n\t\t\t\tc,\n\t\t\t\tundefined,\n\t\t\t\tc.body.additionalData,\n\t\t\t);\n\t\t\tconst url = await provider.createAuthorizationURL({\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\t\tscopes: c.body.scopes,\n\t\t\t\tloginHint: c.body.loginHint,\n\t\t\t});\n\n\t\t\tif (!c.body.disableRedirect) {\n\t\t\t\tc.setHeader(\"Location\", url.toString());\n\t\t\t}\n\n\t\t\treturn c.json({\n\t\t\t\turl: url.toString(),\n\t\t\t\tredirect: !c.body.disableRedirect,\n\t\t\t});\n\t\t},\n\t);\n\nexport const signInEmail = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-in/email\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"signInEmail\",\n\t\t\tuse: [formCsrfMiddleware],\n\t\t\tbody: z.object({\n\t\t\t\t/**\n\t\t\t\t * Email of the user\n\t\t\t\t */\n\t\t\t\temail: z.string().meta({\n\t\t\t\t\tdescription: \"Email of the user\",\n\t\t\t\t}),\n\t\t\t\t/**\n\t\t\t\t * Password of the user\n\t\t\t\t */\n\t\t\t\tpassword: z.string().meta({\n\t\t\t\t\tdescription: \"Password of the user\",\n\t\t\t\t}),\n\t\t\t\t/**\n\t\t\t\t * Callback URL to use as a redirect for email\n\t\t\t\t * verification and for possible redirects\n\t\t\t\t */\n\t\t\t\tcallbackURL: z\n\t\t\t\t\t.string()\n\t\t\t\t\t.meta({\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Callback URL to use as a redirect for email verification\",\n\t\t\t\t\t})\n\t\t\t\t\t.optional(),\n\t\t\t\t/**\n\t\t\t\t * If this is false, the session will not be remembered\n\t\t\t\t * @default true\n\t\t\t\t */\n\t\t\t\trememberMe: z\n\t\t\t\t\t.boolean()\n\t\t\t\t\t.meta({\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"If this is false, the session will not be remembered. Default is `true`.\",\n\t\t\t\t\t})\n\t\t\t\t\t.default(true)\n\t\t\t\t\t.optional(),\n\t\t\t}),\n\t\t\tmetadata: {\n\t\t\t\tallowedMediaTypes: [\n\t\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\t\"application/json\",\n\t\t\t\t],\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as {\n\t\t\t\t\t\temail: string;\n\t\t\t\t\t\tpassword: string;\n\t\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t\t},\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\tredirect: boolean;\n\t\t\t\t\t\ttoken: string;\n\t\t\t\t\t\turl?: string | undefined;\n\t\t\t\t\t\tuser: InferUser<O>;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"signInEmail\",\n\t\t\t\t\tdescription: \"Sign in with email and password\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Success - Returns either session details or redirect URL\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\t// todo: we need support for multiple schema\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tenum: [false],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Session token\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"redirect\", \"token\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tctx,\n\t\t): Promise<{\n\t\t\tredirect: boolean;\n\t\t\ttoken: string;\n\t\t\turl?: string | undefined;\n\t\t\tuser: InferUser<O>;\n\t\t}> => {\n\t\t\tif (!ctx.context.options?.emailAndPassword?.enabled) {\n\t\t\t\tctx.context.logger.error(\n\t\t\t\t\t\"Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!\",\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"Email and password is not enabled\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst { email, password } = ctx.body;\n\t\t\tconst isValidEmail = z.email().safeParse(email);\n\t\t\tif (!isValidEmail.success) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, {\n\t\t\t\tincludeAccounts: true,\n\t\t\t});\n\n\t\t\tif (!user) {\n\t\t\t\t// Hash password to prevent timing attacks from revealing valid email addresses\n\t\t\t\t// By hashing passwords for invalid emails, we ensure consistent response times\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"User not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst credentialAccount = user.accounts.find(\n\t\t\t\t(a) => a.providerId === \"credential\",\n\t\t\t);\n\t\t\tif (!credentialAccount) {\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"Credential account not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst currentPassword = credentialAccount?.password;\n\t\t\tif (!currentPassword) {\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"Password not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst validPassword = await ctx.context.password.verify({\n\t\t\t\thash: currentPassword,\n\t\t\t\tpassword,\n\t\t\t});\n\t\t\tif (!validPassword) {\n\t\t\t\tctx.context.logger.error(\"Invalid password\");\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tctx.context.options?.emailAndPassword?.requireEmailVerification &&\n\t\t\t\t!user.user.emailVerified\n\t\t\t) {\n\t\t\t\tif (!ctx.context.options?.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (ctx.context.options?.emailVerification?.sendOnSignIn) {\n\t\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tuser.user.email,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t);\n\t\t\t\t\tconst callbackURL = ctx.body.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.body.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\tuser.user.id,\n\t\t\t\tctx.body.rememberMe === false,\n\t\t\t);\n\n\t\t\tif (!session) {\n\t\t\t\tctx.context.logger.error(\"Failed to create session\");\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait setSessionCookie(\n\t\t\t\tctx,\n\t\t\t\t{\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user.user,\n\t\t\t\t},\n\t\t\t\tctx.body.rememberMe === false,\n\t\t\t);\n\n\t\t\tif (ctx.body.callbackURL) {\n\t\t\t\tctx.setHeader(\"Location\", ctx.body.callbackURL);\n\t\t\t}\n\n\t\t\treturn ctx.json({\n\t\t\t\tredirect: !!ctx.body.callbackURL,\n\t\t\t\ttoken: session.token,\n\t\t\t\turl: ctx.body.callbackURL,\n\t\t\t\tuser: parseUserOutput(ctx.context.options, user.user) as InferUser<O>,\n\t\t\t});\n\t\t},\n\t);\n","import { getHost, getOrigin, getProtocol } from \"../utils/url\";\nimport { wildcardMatch } from \"../utils/wildcard\";\n\n/**\n * Matches the given url against an origin or origin pattern\n * See \"options.trustedOrigins\" for details of supported patterns\n *\n * @param url The url to test\n * @param pattern The origin pattern\n * @param [settings] Specify supported pattern matching settings\n * @returns {boolean} true if the URL matches the origin pattern, false otherwise.\n */\nexport const matchesOriginPattern = (\n\turl: string,\n\tpattern: string,\n\tsettings?: { allowRelativePaths: boolean },\n): boolean => {\n\tif (url.startsWith(\"/\")) {\n\t\tif (settings?.allowRelativePaths) {\n\t\t\treturn (\n\t\t\t\turl.startsWith(\"/\") &&\n\t\t\t\t/^\\/(?!\\/|\\\\|%2f|%5c)[\\w\\-.\\+/@]*(?:\\?[\\w\\-.\\+/=&%@]*)?$/.test(url)\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Check if pattern contains wildcard characters (*, **, or ?)\n\tconst hasWildcard = pattern.includes(\"*\") || pattern.includes(\"?\");\n\tif (hasWildcard) {\n\t\t// For protocol-specific wildcards, match the full origin\n\t\tif (pattern.includes(\"://\")) {\n\t\t\treturn wildcardMatch(pattern)(getOrigin(url) || url);\n\t\t}\n\t\tconst host = getHost(url);\n\t\tif (!host) {\n\t\t\treturn false;\n\t\t}\n\t\t// For host-only wildcards, match just the host\n\t\treturn wildcardMatch(pattern)(host);\n\t}\n\tconst protocol = getProtocol(url);\n\treturn protocol === \"http:\" || protocol === \"https:\" || !protocol\n\t\t? pattern === getOrigin(url)\n\t\t: url.startsWith(pattern);\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { APIError } from \"better-call\";\nimport type {\n\tJSONWebKeySet,\n\tJWTPayload,\n\tJWTVerifyOptions,\n\tProtectedHeaderParameters,\n} from \"jose\";\nimport {\n\tcreateLocalJWKSet,\n\tdecodeProtectedHeader,\n\tjwtVerify,\n\tUnsecuredJWT,\n} from \"jose\";\nimport { logger } from \"../env\";\n\n/** Last fetched jwks used locally in getJwks @internal */\nlet jwks: JSONWebKeySet | undefined;\n\nexport interface VerifyAccessTokenRemote {\n\t/** Full url of the introspect endpoint. Should end with `/oauth2/introspect` */\n\tintrospectUrl: string;\n\t/** Client Secret */\n\tclientId: string;\n\t/** Client Secret */\n\tclientSecret: string;\n\t/**\n\t * Forces remote verification of a token.\n\t * This ensures attached session (if applicable)\n\t * is also still active.\n\t */\n\tforce?: boolean;\n}\n\n/**\n * Performs local verification of an access token for your APIs.\n *\n * Can also be configured for remote verification.\n */\nexport async function verifyJwsAccessToken(\n\ttoken: string,\n\topts: {\n\t\t/** Jwks url or promise of a Jwks */\n\t\tjwksFetch: string | (() => Promise<JSONWebKeySet | undefined>);\n\t\t/** Verify options */\n\t\tverifyOptions: JWTVerifyOptions &\n\t\t\tRequired<Pick<JWTVerifyOptions, \"audience\" | \"issuer\">>;\n\t},\n) {\n\ttry {\n\t\tconst jwks = await getJwks(token, opts);\n\t\tconst jwt = await jwtVerify<JWTPayload>(\n\t\t\ttoken,\n\t\t\tcreateLocalJWKSet(jwks),\n\t\t\topts.verifyOptions,\n\t\t);\n\t\t// Return the JWT payload in introspection format\n\t\t// https://datatracker.ietf.org/doc/html/rfc7662#section-2.2\n\t\tif (jwt.payload.azp) {\n\t\t\tjwt.payload.client_id = jwt.payload.azp;\n\t\t}\n\t\treturn jwt.payload;\n\t} catch (error) {\n\t\tif (error instanceof Error) throw error;\n\t\tthrow new Error(error as unknown as string);\n\t}\n}\n\nexport async function getJwks(\n\ttoken: string,\n\topts: {\n\t\t/** Jwks url or promise of a Jwks */\n\t\tjwksFetch: string | (() => Promise<JSONWebKeySet | undefined>);\n\t},\n) {\n\t// Attempt to decode the token and find a matching kid in jwks\n\tlet jwtHeaders: ProtectedHeaderParameters | undefined;\n\ttry {\n\t\tjwtHeaders = decodeProtectedHeader(token);\n\t} catch (error) {\n\t\tif (error instanceof Error) throw error;\n\t\tthrow new Error(error as unknown as string);\n\t}\n\n\tif (!jwtHeaders.kid) throw new Error(\"Missing jwt kid\");\n\n\t// Fetch jwks if not set or has a different kid than the one stored\n\tif (!jwks || !jwks.keys.find((jwk) => jwk.kid === jwtHeaders.kid)) {\n\t\tjwks =\n\t\t\ttypeof opts.jwksFetch === \"string\"\n\t\t\t\t? await betterFetch<JSONWebKeySet>(opts.jwksFetch, {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}).then(async (res) => {\n\t\t\t\t\t\tif (res.error)\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Jwks failed: ${res.error.message ?? res.error.statusText}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\treturn res.data;\n\t\t\t\t\t})\n\t\t\t\t: await opts.jwksFetch();\n\t\tif (!jwks) throw new Error(\"No jwks found\");\n\t}\n\n\treturn jwks;\n}\n\n/**\n * Performs local verification of an access token for your API.\n *\n * Can also be configured for remote verification.\n */\nexport async function verifyAccessToken(\n\ttoken: string,\n\topts: {\n\t\t/** Verify options */\n\t\tverifyOptions: JWTVerifyOptions &\n\t\t\tRequired<Pick<JWTVerifyOptions, \"audience\" | \"issuer\">>;\n\t\t/** Scopes to additionally verify. Token must include all but not exact. */\n\t\tscopes?: string[];\n\t\t/** Required to verify access token locally */\n\t\tjwksUrl?: string;\n\t\t/** If provided, can verify a token remotely */\n\t\tremoteVerify?: VerifyAccessTokenRemote;\n\t},\n) {\n\tlet payload: JWTPayload | undefined;\n\t// Locally verify\n\tif (opts.jwksUrl && !opts?.remoteVerify?.force) {\n\t\ttry {\n\t\t\tpayload = await verifyJwsAccessToken(token, {\n\t\t\t\tjwksFetch: opts.jwksUrl,\n\t\t\t\tverifyOptions: opts.verifyOptions,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (error instanceof Error) {\n\t\t\t\tif (error.name === \"TypeError\" || error.name === \"JWSInvalid\") {\n\t\t\t\t\t// likely an opaque token (continue)\n\t\t\t\t} else if (error.name === \"JWTExpired\") {\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: \"token expired\",\n\t\t\t\t\t});\n\t\t\t\t} else if (error.name === \"JWTInvalid\") {\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: \"token invalid\",\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error(error as unknown as string);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remote verify\n\tif (opts?.remoteVerify) {\n\t\tconst { data: introspect, error: introspectError } = await betterFetch<\n\t\t\tJWTPayload & {\n\t\t\t\tactive: boolean;\n\t\t\t}\n\t\t>(opts.remoteVerify.introspectUrl, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: {\n\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\",\n\t\t\t},\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: opts.remoteVerify.clientId,\n\t\t\t\tclient_secret: opts.remoteVerify.clientSecret,\n\t\t\t\ttoken,\n\t\t\t\ttoken_type_hint: \"access_token\",\n\t\t\t}).toString(),\n\t\t});\n\t\tif (introspectError)\n\t\t\tlogger.error(\n\t\t\t\t`Introspection failed: ${introspectError.message ?? introspectError.statusText}`,\n\t\t\t);\n\t\tif (!introspect)\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: \"introspection failed\",\n\t\t\t});\n\t\tif (!introspect.active)\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: \"token inactive\",\n\t\t\t});\n\t\t// Verifies payload using verify options (token valid through introspect)\n\t\ttry {\n\t\t\tconst unsecuredJwt = new UnsecuredJWT(introspect).encode();\n\t\t\tconst { audience: _audience, ...verifyOptions } = opts.verifyOptions;\n\t\t\tconst verify = introspect.aud\n\t\t\t\t? UnsecuredJWT.decode(unsecuredJwt, opts.verifyOptions)\n\t\t\t\t: UnsecuredJWT.decode(unsecuredJwt, verifyOptions);\n\t\t\tpayload = verify.payload;\n\t\t} catch (error) {\n\t\t\tthrow new Error(error as unknown as string);\n\t\t}\n\t}\n\n\tif (!payload)\n\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\tmessage: `no token payload`,\n\t\t});\n\n\t// Check scopes if provided\n\tif (opts.scopes) {\n\t\tconst validScopes = new Set(\n\t\t\t(payload.scope as string | undefined)?.split(\" \"),\n\t\t);\n\t\tfor (const sc of opts.scopes) {\n\t\t\tif (!validScopes.has(sc)) {\n\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\tmessage: `invalid scope ${sc}`,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn payload;\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { logger } from \"../env\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\tgetOAuth2Tokens,\n\trefreshAccessToken,\n} from \"../oauth2\";\nimport { createAuthorizationCodeRequest } from \"../oauth2/validate-authorization-code\";\n\nexport interface GithubProfile {\n\tlogin: string;\n\tid: string;\n\tnode_id: string;\n\tavatar_url: string;\n\tgravatar_id: string;\n\turl: string;\n\thtml_url: string;\n\tfollowers_url: string;\n\tfollowing_url: string;\n\tgists_url: string;\n\tstarred_url: string;\n\tsubscriptions_url: string;\n\torganizations_url: string;\n\trepos_url: string;\n\tevents_url: string;\n\treceived_events_url: string;\n\ttype: string;\n\tsite_admin: boolean;\n\tname: string;\n\tcompany: string;\n\tblog: string;\n\tlocation: string;\n\temail: string;\n\thireable: boolean;\n\tbio: string;\n\ttwitter_username: string;\n\tpublic_repos: string;\n\tpublic_gists: string;\n\tfollowers: string;\n\tfollowing: string;\n\tcreated_at: string;\n\tupdated_at: string;\n\tprivate_gists: string;\n\ttotal_private_repos: string;\n\towned_private_repos: string;\n\tdisk_usage: string;\n\tcollaborators: string;\n\ttwo_factor_authentication: boolean;\n\tplan: {\n\t\tname: string;\n\t\tspace: string;\n\t\tprivate_repos: string;\n\t\tcollaborators: string;\n\t};\n}\n\nexport interface GithubOptions extends ProviderOptions<GithubProfile> {\n\tclientId: string;\n}\nexport const github = (options: GithubOptions) => {\n\tconst tokenEndpoint = \"https://github.com/login/oauth/access_token\";\n\treturn {\n\t\tid: \"github\",\n\t\tname: \"GitHub\",\n\t\tcreateAuthorizationURL({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tloginHint,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t}) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"read:user\", \"user:email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"github\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://github.com/login/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tprompt: options.prompt,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\tconst { body, headers: requestHeaders } = createAuthorizationCodeRequest({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t});\n\n\t\t\tconst { data, error } = await betterFetch<\n\t\t\t\t| { access_token: string; token_type: string; scope: string }\n\t\t\t\t| { error: string; error_description?: string; error_uri?: string }\n\t\t\t>(tokenEndpoint, {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tbody: body,\n\t\t\t\theaders: requestHeaders,\n\t\t\t});\n\n\t\t\tif (error) {\n\t\t\t\tlogger.error(\"GitHub OAuth token exchange failed:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (\"error\" in data) {\n\t\t\t\tlogger.error(\"GitHub OAuth token exchange failed:\", data);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn getOAuth2Tokens(data);\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://github.com/login/oauth/access_token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<GithubProfile>(\n\t\t\t\t\"https://api.github.com/user\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"User-Agent\": \"better-auth\",\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst { data: emails } = await betterFetch<\n\t\t\t\t{\n\t\t\t\t\temail: string;\n\t\t\t\t\tprimary: boolean;\n\t\t\t\t\tverified: boolean;\n\t\t\t\t\tvisibility: \"public\" | \"private\";\n\t\t\t\t}[]\n\t\t\t>(\"https://api.github.com/user/emails\", {\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\"User-Agent\": \"better-auth\",\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!profile.email && emails) {\n\t\t\t\tprofile.email = (emails.find((e) => e.primary) ?? emails[0])\n\t\t\t\t\t?.email as string;\n\t\t\t}\n\t\t\tconst emailVerified =\n\t\t\t\temails?.find((e) => e.email === profile.email)?.verified ?? false;\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name || profile.login,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<GithubProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { APIError } from \"better-call\";\nimport { decodeJwt, decodeProtectedHeader, importJWK, jwtVerify } from \"jose\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface GoogleProfile {\n\taud: string;\n\tazp: string;\n\temail: string;\n\temail_verified: boolean;\n\texp: number;\n\t/**\n\t * The family name of the user, or last name in most\n\t * Western languages.\n\t */\n\tfamily_name: string;\n\t/**\n\t * The given name of the user, or first name in most\n\t * Western languages.\n\t */\n\tgiven_name: string;\n\thd?: string | undefined;\n\tiat: number;\n\tiss: string;\n\tjti?: string | undefined;\n\tlocale?: string | undefined;\n\tname: string;\n\tnbf?: number | undefined;\n\tpicture: string;\n\tsub: string;\n}\n\nexport interface GoogleOptions extends ProviderOptions<GoogleProfile> {\n\tclientId: string;\n\t/**\n\t * The access type to use for the authorization code request\n\t */\n\taccessType?: (\"offline\" | \"online\") | undefined;\n\t/**\n\t * The display mode to use for the authorization code request\n\t */\n\tdisplay?: (\"page\" | \"popup\" | \"touch\" | \"wap\") | undefined;\n\t/**\n\t * The hosted domain of the user\n\t */\n\thd?: string | undefined;\n}\n\nexport const google = (options: GoogleOptions) => {\n\treturn {\n\t\tid: \"google\",\n\t\tname: \"Google\",\n\t\tasync createAuthorizationURL({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t\tloginHint,\n\t\t\tdisplay,\n\t\t}) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Id and Client Secret is required for Google. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Google\");\n\t\t\t}\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"email\", \"profile\", \"openid\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"google\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://accounts.google.com/o/oauth2/v2/auth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\taccessType: options.accessType,\n\t\t\t\tdisplay: display || options.display,\n\t\t\t\tloginHint,\n\t\t\t\thd: options.hd,\n\t\t\t\tadditionalParams: {\n\t\t\t\t\tinclude_granted_scopes: \"true\",\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://oauth2.googleapis.com/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://oauth2.googleapis.com/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\n\t\t\t// Verify JWT integrity\n\t\t\t// See https://developers.google.com/identity/sign-in/web/backend-auth#verify-the-integrity-of-the-id-token\n\n\t\t\tconst { kid, alg: jwtAlg } = decodeProtectedHeader(token);\n\t\t\tif (!kid || !jwtAlg) return false;\n\n\t\t\tconst publicKey = await getGooglePublicKey(kid);\n\t\t\tconst { payload: jwtClaims } = await jwtVerify(token, publicKey, {\n\t\t\t\talgorithms: [jwtAlg],\n\t\t\t\tissuer: [\"https://accounts.google.com\", \"accounts.google.com\"],\n\t\t\t\taudience: options.clientId,\n\t\t\t\tmaxTokenAge: \"1h\",\n\t\t\t});\n\n\t\t\tif (nonce && jwtClaims.nonce !== nonce) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tif (!token.idToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst user = decodeJwt(token.idToken) as GoogleProfile;\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified: user.email_verified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: user,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<GoogleProfile>;\n};\n\nexport const getGooglePublicKey = async (kid: string) => {\n\tconst { data } = await betterFetch<{\n\t\tkeys: Array<{\n\t\t\tkid: string;\n\t\t\talg: string;\n\t\t\tkty: string;\n\t\t\tuse: string;\n\t\t\tn: string;\n\t\t\te: string;\n\t\t}>;\n\t}>(\"https://www.googleapis.com/oauth2/v3/certs\");\n\n\tif (!data?.keys) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Keys not found\",\n\t\t});\n\t}\n\n\tconst jwk = data.keys.find((key) => key.kid === kid);\n\tif (!jwk) {\n\t\tthrow new Error(`JWK with kid ${kid} not found`);\n\t}\n\n\treturn await importJWK(jwk, jwk.alg);\n};\n","import type {\n\tBetterAuthCookie,\n\tBetterAuthCookies,\n\tBetterAuthOptions,\n\tGenericEndpointContext,\n} from \"@better-auth/core\";\nimport { env, isProduction } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { filterOutputFields, safeJSONParse } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport type { CookieOptions } from \"better-call\";\nimport {\n\tsignJWT,\n\tsymmetricDecodeJWT,\n\tsymmetricEncodeJWT,\n\tverifyJWT,\n} from \"../crypto/jwt\";\nimport { parseUserOutput } from \"../db/schema\";\nimport type { Session, User } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { sec } from \"../utils/time\";\nimport { SECURE_COOKIE_PREFIX } from \"./cookie-utils\";\nimport {\n\tcreateAccountStore,\n\tcreateSessionStore,\n\tgetAccountCookie,\n\tsetAccountCookie,\n} from \"./session-store\";\n\nexport function createCookieGetter(options: BetterAuthOptions) {\n\tconst secure =\n\t\toptions.advanced?.useSecureCookies !== undefined\n\t\t\t? options.advanced?.useSecureCookies\n\t\t\t: options.baseURL\n\t\t\t\t? options.baseURL.startsWith(\"https://\")\n\t\t\t\t\t? true\n\t\t\t\t\t: false\n\t\t\t\t: isProduction;\n\tconst secureCookiePrefix = secure ? SECURE_COOKIE_PREFIX : \"\";\n\tconst crossSubdomainEnabled =\n\t\t!!options.advanced?.crossSubDomainCookies?.enabled;\n\tconst domain = crossSubdomainEnabled\n\t\t? options.advanced?.crossSubDomainCookies?.domain ||\n\t\t\t(options.baseURL ? new URL(options.baseURL).hostname : undefined)\n\t\t: undefined;\n\tif (crossSubdomainEnabled && !domain) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"baseURL is required when crossSubdomainCookies are enabled\",\n\t\t);\n\t}\n\tfunction createCookie(\n\t\tcookieName: string,\n\t\toverrideAttributes: Partial<CookieOptions> = {},\n\t) {\n\t\tconst prefix = options.advanced?.cookiePrefix || \"better-auth\";\n\t\tconst name =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.name ||\n\t\t\t`${prefix}.${cookieName}`;\n\n\t\tconst attributes =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.attributes;\n\n\t\treturn {\n\t\t\tname: `${secureCookiePrefix}${name}`,\n\t\t\tattributes: {\n\t\t\t\tsecure: !!secureCookiePrefix,\n\t\t\t\tsameSite: \"lax\",\n\t\t\t\tpath: \"/\",\n\t\t\t\thttpOnly: true,\n\t\t\t\t...(crossSubdomainEnabled ? { domain } : {}),\n\t\t\t\t...options.advanced?.defaultCookieAttributes,\n\t\t\t\t...overrideAttributes,\n\t\t\t\t...attributes,\n\t\t\t},\n\t\t} satisfies BetterAuthCookie;\n\t}\n\treturn createCookie;\n}\n\nexport function getCookies(options: BetterAuthOptions) {\n\tconst createCookie = createCookieGetter(options);\n\tconst sessionMaxAge = options.session?.expiresIn || sec(\"7d\");\n\tconst sessionToken = createCookie(\"session_token\", {\n\t\tmaxAge: sessionMaxAge,\n\t});\n\tconst sessionData = createCookie(\"session_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst accountData = createCookie(\"account_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst dontRememberToken = createCookie(\"dont_remember\");\n\treturn {\n\t\tsessionToken: {\n\t\t\tname: sessionToken.name,\n\t\t\tattributes: sessionToken.attributes,\n\t\t},\n\t\t/**\n\t\t * This cookie is used to store the session data in the cookie\n\t\t * This is useful for when you want to cache the session in the cookie\n\t\t */\n\t\tsessionData: {\n\t\t\tname: sessionData.name,\n\t\t\tattributes: sessionData.attributes,\n\t\t},\n\t\tdontRememberToken: {\n\t\t\tname: dontRememberToken.name,\n\t\t\tattributes: dontRememberToken.attributes,\n\t\t},\n\t\taccountData: {\n\t\t\tname: accountData.name,\n\t\t\tattributes: accountData.attributes,\n\t\t},\n\t};\n}\n\nexport async function setCookieCache(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe: boolean,\n) {\n\tif (!ctx.context.options.session?.cookieCache?.enabled) {\n\t\treturn;\n\t}\n\n\tconst filteredSession = filterOutputFields(\n\t\tsession.session,\n\t\tctx.context.options.session?.additionalFields,\n\t);\n\n\tconst filteredUser = parseUserOutput(ctx.context.options, session.user);\n\n\tconst versionConfig = ctx.context.options.session?.cookieCache?.version;\n\tlet version = \"1\";\n\tif (versionConfig) {\n\t\tif (typeof versionConfig === \"string\") {\n\t\t\tversion = versionConfig;\n\t\t} else if (typeof versionConfig === \"function\") {\n\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\tversion = isPromise(result) ? await result : result;\n\t\t}\n\t}\n\n\tconst sessionData = {\n\t\tsession: filteredSession,\n\t\tuser: filteredUser,\n\t\tupdatedAt: Date.now(),\n\t\tversion,\n\t};\n\n\tconst options = {\n\t\t...ctx.context.authCookies.sessionData.attributes,\n\t\tmaxAge: dontRememberMe\n\t\t\t? undefined\n\t\t\t: ctx.context.authCookies.sessionData.attributes.maxAge,\n\t};\n\n\tconst expiresAtDate = getDate(options.maxAge || 60, \"sec\").getTime();\n\tconst strategy =\n\t\tctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\n\tlet data: string;\n\n\tif (strategy === \"jwe\") {\n\t\t// Use JWE strategy (JSON Web Encryption) with A256CBC-HS512 + HKDF\n\t\tdata = await symmetricEncodeJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\t\"better-auth-session\",\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else if (strategy === \"jwt\") {\n\t\t// Use JWT strategy with HMAC-SHA256 signature (HS256), no encryption\n\t\tdata = await signJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else {\n\t\t// Use compact strategy (base64url + HMAC, no JWT spec overhead)\n\t\t// Also handles legacy \"base64-hmac\" for backward compatibility\n\t\tdata = base64Url.encode(\n\t\t\tJSON.stringify({\n\t\t\t\tsession: sessionData,\n\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\tsignature: await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t...sessionData,\n\t\t\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t\t{\n\t\t\t\tpadding: false,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Check if we need to chunk the cookie (only if it exceeds 4093 bytes)\n\tif (data.length > 4093) {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tconst cookies = sessionStore.chunk(data, options);\n\t\tsessionStore.setCookies(cookies);\n\t} else {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tif (sessionStore.hasChunks()) {\n\t\t\tconst cleanCookies = sessionStore.clean();\n\t\t\tsessionStore.setCookies(cleanCookies);\n\t\t}\n\t\tctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);\n\t}\n\n\t// Refresh account cookie to keep it in sync\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tif (accountData) {\n\t\t\tawait setAccountCookie(ctx, accountData);\n\t\t}\n\t}\n}\n\nexport async function setSessionCookie(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe?: boolean | undefined,\n\toverrides?: Partial<CookieOptions> | undefined,\n) {\n\tconst dontRememberMeCookie = await ctx.getSignedCookie(\n\t\tctx.context.authCookies.dontRememberToken.name,\n\t\tctx.context.secret,\n\t);\n\t// if dontRememberMe is not set, use the cookie value\n\tdontRememberMe =\n\t\tdontRememberMe !== undefined ? dontRememberMe : !!dontRememberMeCookie;\n\n\tconst options = ctx.context.authCookies.sessionToken.attributes;\n\tconst maxAge = dontRememberMe\n\t\t? undefined\n\t\t: ctx.context.sessionConfig.expiresIn;\n\tawait ctx.setSignedCookie(\n\t\tctx.context.authCookies.sessionToken.name,\n\t\tsession.session.token,\n\t\tctx.context.secret,\n\t\t{\n\t\t\t...options,\n\t\t\tmaxAge,\n\t\t\t...overrides,\n\t\t},\n\t);\n\n\tif (dontRememberMe) {\n\t\tawait ctx.setSignedCookie(\n\t\t\tctx.context.authCookies.dontRememberToken.name,\n\t\t\t\"true\",\n\t\t\tctx.context.secret,\n\t\t\tctx.context.authCookies.dontRememberToken.attributes,\n\t\t);\n\t}\n\tawait setCookieCache(ctx, session, dontRememberMe);\n\tctx.context.setNewSession(session);\n}\n\n/**\n * Expires a cookie by setting `maxAge: 0` while preserving its attributes\n */\nexport function expireCookie(\n\tctx: GenericEndpointContext,\n\tcookie: BetterAuthCookie,\n) {\n\tctx.setCookie(cookie.name, \"\", {\n\t\t...cookie.attributes,\n\t\tmaxAge: 0,\n\t});\n}\n\nexport function deleteSessionCookie(\n\tctx: GenericEndpointContext,\n\tskipDontRememberMe?: boolean | undefined,\n) {\n\texpireCookie(ctx, ctx.context.authCookies.sessionToken);\n\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\texpireCookie(ctx, ctx.context.authCookies.accountData);\n\n\t\t//clean up the account data chunks\n\t\tconst accountStore = createAccountStore(\n\t\t\tctx.context.authCookies.accountData.name,\n\t\t\tctx.context.authCookies.accountData.attributes,\n\t\t\tctx,\n\t\t);\n\t\tconst cleanCookies = accountStore.clean();\n\t\taccountStore.setCookies(cleanCookies);\n\t}\n\n\tif (ctx.context.oauthConfig.storeStateStrategy === \"cookie\") {\n\t\tconst stateCookie = ctx.context.createAuthCookie(\"oauth_state\");\n\t\texpireCookie(ctx, stateCookie);\n\t}\n\n\t// Use createSessionStore to clean up all session data chunks\n\tconst sessionStore = createSessionStore(\n\t\tctx.context.authCookies.sessionData.name,\n\t\tctx.context.authCookies.sessionData.attributes,\n\t\tctx,\n\t);\n\tconst cleanCookies = sessionStore.clean();\n\tsessionStore.setCookies(cleanCookies);\n\n\tif (!skipDontRememberMe) {\n\t\texpireCookie(ctx, ctx.context.authCookies.dontRememberToken);\n\t}\n}\n\nexport function parseCookies(cookieHeader: string) {\n\tconst cookies = cookieHeader.split(\"; \");\n\tconst cookieMap = new Map<string, string>();\n\n\tcookies.forEach((cookie) => {\n\t\tconst [name, value] = cookie.split(/=(.*)/s);\n\t\tcookieMap.set(name!, value!);\n\t});\n\treturn cookieMap;\n}\n\nexport type EligibleCookies = (string & {}) | (keyof BetterAuthCookies & {});\n\nexport const getSessionCookie = (\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tpath?: string;\n\t\t  }\n\t\t| undefined,\n) => {\n\tif (config?.cookiePrefix) {\n\t\tif (config.cookieName) {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}-`;\n\t\t} else {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}.`;\n\t\t}\n\t}\n\tconst headers = \"headers\" in request ? request.headers : request;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_token\", cookiePrefix = \"better-auth.\" } =\n\t\tconfig || {};\n\tconst name = `${cookiePrefix}${cookieName}`;\n\tconst secureCookieName = `${SECURE_COOKIE_PREFIX}${name}`;\n\tconst parsedCookie = parseCookies(cookies);\n\tconst sessionToken =\n\t\tparsedCookie.get(name) || parsedCookie.get(secureCookieName);\n\tif (sessionToken) {\n\t\treturn sessionToken;\n\t}\n\n\treturn null;\n};\n\nexport const getCookieCache = async <\n\tS extends {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User & Record<string, any>;\n\t\tupdatedAt: number;\n\t\tversion?: string;\n\t},\n>(\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tisSecure?: boolean;\n\t\t\t\tsecret?: string;\n\t\t\t\tstrategy?: \"compact\" | \"jwt\" | \"jwe\"; // base64-hmac for backward compatibility\n\t\t\t\tversion?:\n\t\t\t\t\t| string\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => string)\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => Promise<string>);\n\t\t  }\n\t\t| undefined,\n) => {\n\tconst headers = request instanceof Headers ? request : request.headers;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_data\", cookiePrefix = \"better-auth\" } =\n\t\tconfig || {};\n\tconst name =\n\t\tconfig?.isSecure !== undefined\n\t\t\t? config.isSecure\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`\n\t\t\t: isProduction\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`;\n\tconst parsedCookie = parseCookies(cookies);\n\n\t// Check for chunked cookies\n\tlet sessionData = parsedCookie.get(name);\n\tif (!sessionData) {\n\t\t// Try to reconstruct from chunks\n\t\tconst chunks: Array<{ index: number; value: string }> = [];\n\t\tfor (const [cookieName, value] of parsedCookie.entries()) {\n\t\t\tif (cookieName.startsWith(name + \".\")) {\n\t\t\t\tconst parts = cookieName.split(\".\");\n\t\t\t\tconst indexStr = parts[parts.length - 1];\n\t\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\t\tif (!isNaN(index)) {\n\t\t\t\t\tchunks.push({ index, value });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chunks.length > 0) {\n\t\t\t// Sort by index and join\n\t\t\tchunks.sort((a, b) => a.index - b.index);\n\t\t\tsessionData = chunks.map((c) => c.value).join(\"\");\n\t\t}\n\t}\n\n\tif (sessionData) {\n\t\tconst secret = config?.secret || env.BETTER_AUTH_SECRET;\n\t\tif (!secret) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"getCookieCache requires a secret to be provided. Either pass it as an option or set the BETTER_AUTH_SECRET environment variable\",\n\t\t\t);\n\t\t}\n\n\t\tconst strategy = config?.strategy || \"compact\";\n\n\t\tif (strategy === \"jwe\") {\n\t\t\t// Use JWE strategy (encrypted)\n\t\t\tconst payload = await symmetricDecodeJWT<S>(\n\t\t\t\tsessionData,\n\t\t\t\tsecret,\n\t\t\t\t\"better-auth-session\",\n\t\t\t);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else if (strategy === \"jwt\") {\n\t\t\t// Use JWT strategy with HMAC signature (HS256), no encryption\n\t\t\tconst payload = await verifyJWT<S>(sessionData, secret);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Use compact strategy (or legacy base64-hmac)\n\t\t\tconst sessionDataPayload = safeJSONParse<{\n\t\t\t\tsession: S;\n\t\t\t\texpiresAt: number;\n\t\t\t\tsignature: string;\n\t\t\t}>(binary.decode(base64Url.decode(sessionData)));\n\t\t\tif (!sessionDataPayload) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst isValid = await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(\n\t\t\t\tsecret,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\t...sessionDataPayload.session,\n\t\t\t\t\texpiresAt: sessionDataPayload.expiresAt,\n\t\t\t\t}),\n\t\t\t\tsessionDataPayload.signature,\n\t\t\t);\n\t\t\tif (!isValid) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Validate version if provided\n\t\t\tif (config?.version && sessionDataPayload.session) {\n\t\t\t\tconst cookieVersion = sessionDataPayload.session.version || \"1\";\n\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\tconst result = config.version(\n\t\t\t\t\t\tsessionDataPayload.session.session,\n\t\t\t\t\t\tsessionDataPayload.session.user,\n\t\t\t\t\t);\n\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t}\n\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sessionDataPayload.session;\n\t\t}\n\t}\n\treturn null;\n};\n\nexport * from \"./cookie-utils\";\nexport { createSessionStore, getChunkedCookie } from \"./session-store\";\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport type { Account } from \"@better-auth/core/db\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport type { CookieOptions } from \"better-call\";\nimport * as z from \"zod\";\nimport { symmetricDecodeJWT, symmetricEncodeJWT } from \"../crypto\";\n\n// Cookie size constants based on browser limits\nconst ALLOWED_COOKIE_SIZE = 4096;\n// Estimated size of an empty cookie with all attributes\n// (name, path, domain, secure, httpOnly, sameSite, expires/maxAge)\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 200;\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;\n\ninterface Cookie {\n\tname: string;\n\tvalue: string;\n\tattributes: CookieOptions;\n}\n\ntype Chunks = Record<string, string>;\n\n/**\n * Parse cookies from the request headers\n */\nfunction parseCookiesFromContext(\n\tctx: GenericEndpointContext,\n): Record<string, string> {\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn {};\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\treturn cookies;\n}\n\n/**\n * Extract the chunk index from a cookie name\n */\nfunction getChunkIndex(cookieName: string): number {\n\tconst parts = cookieName.split(\".\");\n\tconst lastPart = parts[parts.length - 1];\n\tconst index = parseInt(lastPart || \"0\", 10);\n\treturn isNaN(index) ? 0 : index;\n}\n\n/**\n * Read all existing chunks from cookies\n */\nfunction readExistingChunks(\n\tcookieName: string,\n\tctx: GenericEndpointContext,\n): Chunks {\n\tconst chunks: Chunks = {};\n\tconst cookies = parseCookiesFromContext(ctx);\n\n\tfor (const [name, value] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName)) {\n\t\t\tchunks[name] = value;\n\t\t}\n\t}\n\n\treturn chunks;\n}\n\n/**\n * Get the full session data by joining all chunks\n */\nfunction joinChunks(chunks: Chunks): string {\n\tconst sortedKeys = Object.keys(chunks).sort((a, b) => {\n\t\tconst aIndex = getChunkIndex(a);\n\t\tconst bIndex = getChunkIndex(b);\n\t\treturn aIndex - bIndex;\n\t});\n\n\treturn sortedKeys.map((key) => chunks[key]).join(\"\");\n}\n\n/**\n * Split a cookie value into chunks if needed\n */\nfunction chunkCookie(\n\tstoreName: string,\n\tcookie: Cookie,\n\tchunks: Chunks,\n\tlogger: InternalLogger,\n): Cookie[] {\n\tconst chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);\n\n\tif (chunkCount === 1) {\n\t\tchunks[cookie.name] = cookie.value;\n\t\treturn [cookie];\n\t}\n\n\tconst cookies: Cookie[] = [];\n\tfor (let i = 0; i < chunkCount; i++) {\n\t\tconst name = `${cookie.name}.${i}`;\n\t\tconst start = i * CHUNK_SIZE;\n\t\tconst value = cookie.value.substring(start, start + CHUNK_SIZE);\n\t\tcookies.push({ ...cookie, name, value });\n\t\tchunks[name] = value;\n\t}\n\n\tlogger.debug(`CHUNKING_${storeName.toUpperCase()}_COOKIE`, {\n\t\tmessage: `${storeName} cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n\t\temptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n\t\tvalueSize: cookie.value.length,\n\t\tchunkCount,\n\t\tchunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n\t});\n\n\treturn cookies;\n}\n\n/**\n * Get all cookies that should be cleaned (removed)\n */\nfunction getCleanCookies(\n\tchunks: Chunks,\n\tcookieOptions: CookieOptions,\n): Record<string, Cookie> {\n\tconst cleanedChunks: Record<string, Cookie> = {};\n\tfor (const name in chunks) {\n\t\tcleanedChunks[name] = {\n\t\t\tname,\n\t\t\tvalue: \"\",\n\t\t\tattributes: { ...cookieOptions, maxAge: 0 },\n\t\t};\n\t}\n\treturn cleanedChunks;\n}\n\n/**\n * Create a session store for handling cookie chunking.\n * When session data exceeds 4KB, it automatically splits it into multiple cookies.\n *\n * Based on next-auth's SessionStore implementation.\n * @see https://github.com/nextauthjs/next-auth/blob/27b2519b84b8eb9cf053775dea29d577d2aa0098/packages/next-auth/src/core/lib/cookie.ts\n */\nconst storeFactory =\n\t(storeName: string) =>\n\t(\n\t\tcookieName: string,\n\t\tcookieOptions: CookieOptions,\n\t\tctx: GenericEndpointContext,\n\t) => {\n\t\tconst chunks = readExistingChunks(cookieName, ctx);\n\t\tconst logger = ctx.context.logger;\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Get the full session data by joining all chunks\n\t\t\t */\n\t\t\tgetValue(): string {\n\t\t\t\treturn joinChunks(chunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Check if there are existing chunks\n\t\t\t */\n\t\t\thasChunks(): boolean {\n\t\t\t\treturn Object.keys(chunks).length > 0;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Chunk a cookie value and return all cookies to set (including cleanup cookies)\n\t\t\t */\n\t\t\tchunk(value: string, options?: Partial<CookieOptions>): Cookie[] {\n\t\t\t\t// Start by cleaning all existing chunks\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\tconst cookies: Record<string, Cookie> = cleanedChunks;\n\n\t\t\t\t// Create new chunks\n\t\t\t\tconst chunked = chunkCookie(\n\t\t\t\t\tstoreName,\n\t\t\t\t\t{\n\t\t\t\t\t\tname: cookieName,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tattributes: { ...cookieOptions, ...options },\n\t\t\t\t\t},\n\t\t\t\t\tchunks,\n\t\t\t\t\tlogger,\n\t\t\t\t);\n\n\t\t\t\t// Update with new chunks\n\t\t\t\tfor (const chunk of chunked) {\n\t\t\t\t\tcookies[chunk.name] = chunk;\n\t\t\t\t}\n\n\t\t\t\treturn Object.values(cookies);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Get cookies to clean up all chunks\n\t\t\t */\n\t\t\tclean(): Cookie[] {\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\treturn Object.values(cleanedChunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Set all cookies in the context\n\t\t\t */\n\t\t\tsetCookies(cookies: Cookie[]): void {\n\t\t\t\tfor (const cookie of cookies) {\n\t\t\t\t\tctx.setCookie(cookie.name, cookie.value, cookie.attributes);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t};\n\nexport const createSessionStore = storeFactory(\"Session\");\nexport const createAccountStore = storeFactory(\"Account\");\n\nexport function getChunkedCookie(\n\tctx: GenericEndpointContext,\n\tcookieName: string,\n): string | null {\n\tconst value = ctx.getCookie(cookieName);\n\tif (value) {\n\t\treturn value;\n\t}\n\n\tconst chunks: Array<{ index: number; value: string }> = [];\n\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn null;\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\tfor (const [name, val] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName + \".\")) {\n\t\t\tconst parts = name.split(\".\");\n\t\t\tconst indexStr = parts.at(-1);\n\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\tif (!isNaN(index)) {\n\t\t\t\tchunks.push({ index, value: val });\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chunks.length > 0) {\n\t\tchunks.sort((a, b) => a.index - b.index);\n\t\treturn chunks.map((c) => c.value).join(\"\");\n\t}\n\n\treturn null;\n}\n\nexport async function setAccountCookie(\n\tc: GenericEndpointContext,\n\taccountData: Record<string, any>,\n) {\n\tconst accountDataCookie = c.context.authCookies.accountData;\n\tconst options = {\n\t\tmaxAge: 60 * 5,\n\t\t...accountDataCookie.attributes,\n\t};\n\tconst data = await symmetricEncodeJWT(\n\t\taccountData,\n\t\tc.context.secret,\n\t\t\"better-auth-account\",\n\t\toptions.maxAge,\n\t);\n\n\tif (data.length > ALLOWED_COOKIE_SIZE) {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\n\t\tconst cookies = accountStore.chunk(data, options);\n\t\taccountStore.setCookies(cookies);\n\t} else {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\t\tif (accountStore.hasChunks()) {\n\t\t\tconst cleanCookies = accountStore.clean();\n\t\t\taccountStore.setCookies(cleanCookies);\n\t\t}\n\t\tc.setCookie(accountDataCookie.name, data, options);\n\t}\n}\n\nexport async function getAccountCookie(c: GenericEndpointContext) {\n\tconst accountCookie = getChunkedCookie(\n\t\tc,\n\t\tc.context.authCookies.accountData.name,\n\t);\n\tif (accountCookie) {\n\t\tconst accountData = safeJSONParse<Account>(\n\t\t\tawait symmetricDecodeJWT(\n\t\t\t\taccountCookie,\n\t\t\t\tc.context.secret,\n\t\t\t\t\"better-auth-account\",\n\t\t\t),\n\t\t);\n\t\tif (accountData) {\n\t\t\treturn accountData;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport const getSessionQuerySchema = z.optional(\n\tz.object({\n\t\t/**\n\t\t * If cookie cache is enabled, it will disable the cache\n\t\t * and fetch the session from the database\n\t\t */\n\t\tdisableCookieCache: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription: \"Disable cookie cache and fetch session from database\",\n\t\t\t})\n\t\t\t.optional(),\n\t\tdisableRefresh: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"Disable session refresh. Useful for checking session status, without updating the session\",\n\t\t\t})\n\t\t\t.optional(),\n\t}),\n);\n","import { getWebcryptoSubtle } from \"@better-auth/utils\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { xchacha20poly1305 } from \"@noble/ciphers/chacha.js\";\nimport {\n\tbytesToHex,\n\thexToBytes,\n\tmanagedNonce,\n\tutf8ToBytes,\n} from \"@noble/ciphers/utils.js\";\n\nconst algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n\nexport type SymmetricEncryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricEncrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricEncryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = utf8ToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn bytesToHex(chacha.encrypt(dataAsBytes));\n};\n\nexport type SymmetricDecryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricDecrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricDecryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = hexToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn new TextDecoder().decode(chacha.decrypt(dataAsBytes));\n};\n\nexport const getCryptoKey = async (secret: string | BufferSource) => {\n\tconst secretBuf =\n\t\ttypeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await getWebcryptoSubtle().importKey(\n\t\t\"raw\",\n\t\tsecretBuf,\n\t\talgorithm,\n\t\tfalse,\n\t\t[\"sign\", \"verify\"],\n\t);\n};\n\nexport const makeSignature = async (\n\tvalue: string,\n\tsecret: string | BufferSource,\n): Promise<string> => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await getWebcryptoSubtle().sign(\n\t\talgorithm.name,\n\t\tkey,\n\t\tnew TextEncoder().encode(value),\n\t);\n\t// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\n\nexport * from \"./buffer\";\nexport * from \"./jwt\";\nexport * from \"./password\";\nexport * from \"./random\";\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { runWithTransaction } from \"@better-auth/core/context\";\nimport { isDevelopment } from \"@better-auth/core/env\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { parseUserInput } from \"../../db\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport type { AdditionalUserFieldsInput, InferUser, User } from \"../../types\";\n\nimport { formCsrfMiddleware } from \"../middlewares/origin-check\";\nimport { createEmailVerificationToken } from \"./email-verification\";\n\nconst signUpEmailBodySchema = z\n\t.object({\n\t\tname: z.string(),\n\t\temail: z.email(),\n\t\tpassword: z.string().nonempty(),\n\t\timage: z.string().optional(),\n\t\tcallbackURL: z.string().optional(),\n\t\trememberMe: z.boolean().optional(),\n\t})\n\t.and(z.record(z.string(), z.any()));\n\nexport const signUpEmail = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-up/email\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"signUpWithEmailAndPassword\",\n\t\t\tuse: [formCsrfMiddleware],\n\t\t\tbody: signUpEmailBodySchema,\n\t\t\tmetadata: {\n\t\t\t\tallowedMediaTypes: [\n\t\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\t\"application/json\",\n\t\t\t\t],\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as {\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\temail: string;\n\t\t\t\t\t\tpassword: string;\n\t\t\t\t\t\timage?: string | undefined;\n\t\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t\t} & AdditionalUserFieldsInput<O>,\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\ttoken: string | null;\n\t\t\t\t\t\tuser: InferUser<O>;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"signUpWithEmailAndPassword\",\n\t\t\t\t\tdescription: \"Sign up a user using email and password\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tpassword: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The password of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"The URL to use for email verification callback\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trememberMe: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"If this is false, the session will not be remembered. Default is `true`.\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"name\", \"email\", \"password\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Successfully created user\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Authentication token for the session\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email address of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was created\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"user\"], // token is optional\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"422\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Unprocessable Entity. User already exists or failed to create user.\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\treturn runWithTransaction(ctx.context.adapter, async () => {\n\t\t\t\tif (\n\t\t\t\t\t!ctx.context.options.emailAndPassword?.enabled ||\n\t\t\t\t\tctx.context.options.emailAndPassword?.disableSignUp\n\t\t\t\t) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: \"Email and password sign up is not enabled\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst body = ctx.body as any as User & {\n\t\t\t\t\tpassword: string;\n\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t} & {\n\t\t\t\t\t[key: string]: any;\n\t\t\t\t};\n\t\t\t\tconst {\n\t\t\t\t\tname,\n\t\t\t\t\temail,\n\t\t\t\t\tpassword,\n\t\t\t\t\timage,\n\t\t\t\t\tcallbackURL: _callbackURL,\n\t\t\t\t\trememberMe,\n\t\t\t\t\t...rest\n\t\t\t\t} = body;\n\t\t\t\tconst isValidEmail = z.email().safeParse(email);\n\n\t\t\t\tif (!isValidEmail.success) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!password || typeof password !== \"string\") {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\t\t\tif (password.length < minPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\t\t\t\tif (password.length > maxPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst dbUser = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\t\tif (dbUser?.user) {\n\t\t\t\t\tctx.context.logger.info(\n\t\t\t\t\t\t`Sign-up attempt for existing email: ${email}`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * Hash the password\n\t\t\t\t *\n\t\t\t\t * This is done prior to creating the user\n\t\t\t\t * to ensure that any plugin that\n\t\t\t\t * may break the hashing should break\n\t\t\t\t * before the user is created.\n\t\t\t\t */\n\t\t\t\tconst hash = await ctx.context.password.hash(password);\n\t\t\t\tlet createdUser: User;\n\t\t\t\ttry {\n\t\t\t\t\tconst data = parseUserInput(ctx.context.options, rest, \"create\");\n\t\t\t\t\tcreatedUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\temail: email.toLowerCase(),\n\t\t\t\t\t\tname,\n\t\t\t\t\t\timage,\n\t\t\t\t\t\t...data,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t});\n\t\t\t\t\tif (!createdUser) {\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (isDevelopment()) {\n\t\t\t\t\t\tctx.context.logger.error(\"Failed to create user\", e);\n\t\t\t\t\t}\n\t\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\tctx.context.logger?.error(\"Failed to create user\", e);\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!createdUser) {\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\t\t\tuserId: createdUser.id,\n\t\t\t\t\tproviderId: \"credential\",\n\t\t\t\t\taccountId: createdUser.id,\n\t\t\t\t\tpassword: hash,\n\t\t\t\t});\n\t\t\t\tconst shouldSendVerificationEmail =\n\t\t\t\t\tctx.context.options.emailVerification?.sendOnSignUp ??\n\t\t\t\t\tctx.context.options.emailAndPassword.requireEmailVerification;\n\t\t\t\tif (shouldSendVerificationEmail) {\n\t\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tcreatedUser.email,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t);\n\t\t\t\t\tconst callbackURL = body.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(body.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: createdUser,\n\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tctx.context.options.emailAndPassword.autoSignIn === false ||\n\t\t\t\t\tctx.context.options.emailAndPassword.requireEmailVerification\n\t\t\t\t) {\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\ttoken: null,\n\t\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\tcreatedUser,\n\t\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\tcreatedUser.id,\n\t\t\t\t\trememberMe === false,\n\t\t\t\t);\n\t\t\t\tif (!session) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(\n\t\t\t\t\tctx,\n\t\t\t\t\t{\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tuser: createdUser,\n\t\t\t\t\t},\n\t\t\t\t\trememberMe === false,\n\t\t\t\t);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tcreatedUser,\n\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\ninterface Partner {\n\t/** Partner-specific ID (consent required: kakaotalk_message) */\n\tuuid?: string | undefined;\n}\n\ninterface Profile {\n\t/** Nickname (consent required: profile/nickname) */\n\tnickname?: string | undefined;\n\t/** Thumbnail image URL (consent required: profile/profile image) */\n\tthumbnail_image_url?: string | undefined;\n\t/** Profile image URL (consent required: profile/profile image) */\n\tprofile_image_url?: string | undefined;\n\t/** Whether the profile image is the default */\n\tis_default_image?: boolean | undefined;\n\t/** Whether the nickname is the default */\n\tis_default_nickname?: boolean | undefined;\n}\n\ninterface KakaoAccount {\n\t/** Consent required: profile info (nickname/profile image) */\n\tprofile_needs_agreement?: boolean | undefined;\n\t/** Consent required: nickname */\n\tprofile_nickname_needs_agreement?: boolean | undefined;\n\t/** Consent required: profile image */\n\tprofile_image_needs_agreement?: boolean | undefined;\n\t/** Profile info */\n\tprofile?: Profile | undefined;\n\t/** Consent required: name */\n\tname_needs_agreement?: boolean | undefined;\n\t/** Name */\n\tname?: string | undefined;\n\t/** Consent required: email */\n\temail_needs_agreement?: boolean | undefined;\n\t/** Email valid */\n\tis_email_valid?: boolean | undefined;\n\t/** Email verified */\n\tis_email_verified?: boolean | undefined;\n\t/** Email */\n\temail?: string | undefined;\n\t/** Consent required: age range */\n\tage_range_needs_agreement?: boolean | undefined;\n\t/** Age range */\n\tage_range?: string | undefined;\n\t/** Consent required: birth year */\n\tbirthyear_needs_agreement?: boolean | undefined;\n\t/** Birth year (YYYY) */\n\tbirthyear?: string | undefined;\n\t/** Consent required: birthday */\n\tbirthday_needs_agreement?: boolean | undefined;\n\t/** Birthday (MMDD) */\n\tbirthday?: string | undefined;\n\t/** Birthday type (SOLAR/LUNAR) */\n\tbirthday_type?: string | undefined;\n\t/** Whether birthday is in a leap month */\n\tis_leap_month?: boolean | undefined;\n\t/** Consent required: gender */\n\tgender_needs_agreement?: boolean | undefined;\n\t/** Gender (male/female) */\n\tgender?: string | undefined;\n\t/** Consent required: phone number */\n\tphone_number_needs_agreement?: boolean | undefined;\n\t/** Phone number */\n\tphone_number?: string | undefined;\n\t/** Consent required: CI */\n\tci_needs_agreement?: boolean | undefined;\n\t/** CI (unique identifier) */\n\tci?: string | undefined;\n\t/** CI authentication time (UTC) */\n\tci_authenticated_at?: string | undefined;\n}\n\nexport interface KakaoProfile {\n\t/** Kakao user ID */\n\tid: number;\n\t/**\n\t * Whether the user has signed up (only present if auto-connection is disabled)\n\t * false: preregistered, true: registered\n\t */\n\thas_signed_up?: boolean | undefined;\n\t/** UTC datetime when the user connected the service */\n\tconnected_at?: string | undefined;\n\t/** UTC datetime when the user signed up via Kakao Sync */\n\tsynched_at?: string | undefined;\n\t/** Custom user properties */\n\tproperties?: Record<string, any> | undefined;\n\t/** Kakao account info */\n\tkakao_account: KakaoAccount;\n\t/** Partner info */\n\tfor_partner?: Partner | undefined;\n}\n\nexport interface KakaoOptions extends ProviderOptions<KakaoProfile> {\n\tclientId: string;\n}\n\nexport const kakao = (options: KakaoOptions) => {\n\treturn {\n\t\tid: \"kakao\",\n\t\tname: \"Kakao\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"account_email\", \"profile_image\", \"profile_nickname\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"kakao\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://kauth.kakao.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://kauth.kakao.com/oauth/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://kauth.kakao.com/oauth/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<KakaoProfile>(\n\t\t\t\t\"https://kapi.kakao.com/v2/user/me\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error || !profile) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tconst account = profile.kakao_account || {};\n\t\t\tconst kakaoProfile = account.profile || {};\n\t\t\tconst user = {\n\t\t\t\tid: String(profile.id),\n\t\t\t\tname: kakaoProfile.nickname || account.name || undefined,\n\t\t\t\temail: account.email,\n\t\t\t\timage:\n\t\t\t\t\tkakaoProfile.profile_image_url || kakaoProfile.thumbnail_image_url,\n\t\t\t\temailVerified: !!account.is_email_valid && !!account.is_email_verified,\n\t\t\t\t...userMap,\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<KakaoProfile>;\n};\n","/**\n * ChaCha stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20) and\n * [website](https://cr.yp.to/chacha.html).\n *\n * @module\n */\nimport { type XorPRG, createCipher, createPRG, rotl } from './_arx.ts';\nimport { poly1305 } from './_poly1305.ts';\nimport {\n  type ARXCipher,\n  type CipherWithOutput,\n  type XorStream,\n  abytes,\n  clean,\n  equalBytes,\n  getOutput,\n  u64Lengths,\n  wrapCipher,\n} from './utils.ts';\n\n/**\n * ChaCha core function. It is implemented twice:\n * 1. Simple loop (chachaCore_small, hchacha_small)\n * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read\n * The specific implementation is selected in `createCipher` below.\n */\n\n/** quarter-round */\n// prettier-ignore\nfunction chachaQR(x: Uint32Array, a: number, b: number, c: number, d: number) {\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 16);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 12);\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 8);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 7);\n}\n\n/** single round */\nfunction chachaRound(x: Uint32Array, rounds = 20) {\n  for (let r = 0; r < rounds; r += 2) {\n    chachaQR(x, 0, 4, 8, 12);\n    chachaQR(x, 1, 5, 9, 13);\n    chachaQR(x, 2, 6, 10, 14);\n    chachaQR(x, 3, 7, 11, 15);\n    chachaQR(x, 0, 5, 10, 15);\n    chachaQR(x, 1, 6, 11, 12);\n    chachaQR(x, 2, 7, 8, 13);\n    chachaQR(x, 3, 4, 9, 14);\n  }\n}\n\nconst ctmp = /* @__PURE__ */ new Uint32Array(16);\n\n/** Small version of chacha without loop unrolling. Unused, provided for auditability. */\n// prettier-ignore\nfunction chacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array,\n  isHChacha: boolean = true, rounds: number = 20\n): void {\n  // Create initial array using common pattern\n  const y = Uint32Array.from([\n    s[0], s[1], s[2], s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    k[0], k[1], k[2], k[3], // Key      Key     Key     Key\n    k[4], k[5], k[6], k[7], // Key      Key     Key     Key\n    i[0], i[1], i[2], i[3], // Counter  Counter Nonce   Nonce\n  ]);\n  const x = ctmp;\n  x.set(y);\n  chachaRound(x, rounds);\n\n  // hchacha extracts 8 specific bytes, chacha adds orig to result\n  if (isHChacha) {\n    const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];\n    for (let i = 0; i < 8; i++) out[i] = x[xindexes[i]];\n  } else {\n    for (let i = 0; i < 16; i++) out[i] = (y[i] + x[i]) | 0;\n  }\n}\n\n/** Identical to `chachaCore`. Unused. */\n// @ts-ignore\nconst chachaCore_small: typeof chachaCore = (s, k, n, out, cnt, rounds) =>\n  chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);\n/** Identical to `hchacha`. Unused. */\n// @ts-ignore\nconst hchacha_small: typeof hchacha = chacha;\n\n/** Identical to `chachaCore_small`. Unused. */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n      y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n      y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n      y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2];  // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha hashes key and nonce into key' and nonce' for xchacha20.\n * Identical to `hchacha_small`.\n * Need to find a way to merge it with `chachaCore` without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array\n): void {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  out[oi++] = x00; out[oi++] = x01;\n  out[oi++] = x02; out[oi++] = x03;\n  out[oi++] = x12; out[oi++] = x13;\n  out[oi++] = x14; out[oi++] = x15;\n}\n\n/** Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter. */\nexport const chacha20orig: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With smaller nonce, it's not safe to make it random (CSPRNG), due to collision chance.\n */\nexport const chacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. With 24-byte nonce, it's safe to make it random (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/** Reduced 8-round chacha, described in original paper. */\nexport const chacha8: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/** Reduced 12-round chacha, described in original paper. */\nexport const chacha12: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const leftover = msg.length % 16;\n  if (leftover) h.update(ZEROS16.subarray(leftover));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  if (AAD !== undefined) abytes(AAD, undefined, 'AAD');\n  const authKey = fn(key, nonce, ZEROS32);\n  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);\n\n  // Methods below can be replaced with\n  // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, ciphertext);\n  h.update(lengths);\n  const res = h.digest();\n  clean(authKey, lengths);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them, but it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    return {\n      encrypt(plaintext: Uint8Array, output?: Uint8Array) {\n        const plength = plaintext.length;\n        output = getOutput(plength + tagLength, output, false);\n        output.set(plaintext);\n        const oPlain = output.subarray(0, -tagLength);\n        // Actual encryption\n        xorStream(key, nonce, oPlain, oPlain, 1);\n        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n        output.set(tag, plength); // append tag\n        clean(tag);\n        return output;\n      },\n      decrypt(ciphertext: Uint8Array, output?: Uint8Array) {\n        output = getOutput(ciphertext.length - tagLength, output, false);\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        output.set(ciphertext.subarray(0, -tagLength));\n        // Actual decryption\n        xorStream(key, nonce, output, output, 1); // start stream with i=1\n        clean(tag);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n\n/**\n * Chacha20 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Compatible with libtomcrypt. It does not have a specification, so unclear how secure it is.\n */\nexport const rngChacha20: XorPRG = /* @__PURE__ */ createPRG(chacha20orig, 64, 32, 8);\n/**\n * Chacha20/8 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Faster than `rngChacha20`.\n */\nexport const rngChacha8: XorPRG = /* @__PURE__ */ createPRG(chacha8, 64, 32, 12);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface GitlabProfile extends Record<string, any> {\n\tid: number;\n\tusername: string;\n\temail: string;\n\tname: string;\n\tstate: string;\n\tavatar_url: string;\n\tweb_url: string;\n\tcreated_at: string;\n\tbio: string;\n\tlocation?: string | undefined;\n\tpublic_email: string;\n\tskype: string;\n\tlinkedin: string;\n\ttwitter: string;\n\twebsite_url: string;\n\torganization: string;\n\tjob_title: string;\n\tpronouns: string;\n\tbot: boolean;\n\twork_information?: string | undefined;\n\tfollowers: number;\n\tfollowing: number;\n\tlocal_time: string;\n\tlast_sign_in_at: string;\n\tconfirmed_at: string;\n\ttheme_id: number;\n\tlast_activity_on: string;\n\tcolor_scheme_id: number;\n\tprojects_limit: number;\n\tcurrent_sign_in_at: string;\n\tidentities: Array<{\n\t\tprovider: string;\n\t\textern_uid: string;\n\t}>;\n\tcan_create_group: boolean;\n\tcan_create_project: boolean;\n\ttwo_factor_enabled: boolean;\n\texternal: boolean;\n\tprivate_profile: boolean;\n\tcommit_email: string;\n\tshared_runners_minutes_limit: number;\n\textra_shared_runners_minutes_limit: number;\n\temail_verified?: boolean | undefined;\n}\n\nexport interface GitlabOptions extends ProviderOptions<GitlabProfile> {\n\tclientId: string;\n\tissuer?: string | undefined;\n}\n\nconst cleanDoubleSlashes = (input: string = \"\") => {\n\treturn input\n\t\t.split(\"://\")\n\t\t.map((str) => str.replace(/\\/{2,}/g, \"/\"))\n\t\t.join(\"://\");\n};\n\nconst issuerToEndpoints = (issuer?: string | undefined) => {\n\tconst baseUrl = issuer || \"https://gitlab.com\";\n\treturn {\n\t\tauthorizationEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/authorize`),\n\t\ttokenEndpoint: cleanDoubleSlashes(`${baseUrl}/oauth/token`),\n\t\tuserinfoEndpoint: cleanDoubleSlashes(`${baseUrl}/api/v4/user`),\n\t};\n};\n\nexport const gitlab = (options: GitlabOptions) => {\n\tconst { authorizationEndpoint, tokenEndpoint, userinfoEndpoint } =\n\t\tissuerToEndpoints(options.issuer);\n\tconst issuerId = \"gitlab\";\n\tconst issuerName = \"Gitlab\";\n\treturn {\n\t\tid: issuerId,\n\t\tname: issuerName,\n\t\tcreateAuthorizationURL: async ({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tcodeVerifier,\n\t\t\tloginHint,\n\t\t\tredirectURI,\n\t\t}) => {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"read_user\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: issuerId,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\tloginHint,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tcodeVerifier,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: tokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<GitlabProfile>(\n\t\t\t\tuserinfoEndpoint,\n\t\t\t\t{ headers: { authorization: `Bearer ${token.accessToken}` } },\n\t\t\t);\n\t\t\tif (error || profile.state !== \"active\" || profile.locked) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t// GitLab may provide email_verified claim, but it's not guaranteed.\n\t\t\t// We check for it first, then default to false for security consistency.\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name ?? profile.username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<GitlabProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface AtlassianProfile {\n\taccount_type?: string | undefined;\n\taccount_id: string;\n\temail?: string | undefined;\n\tname: string;\n\tpicture?: string | undefined;\n\tnickname?: string | undefined;\n\tlocale?: string | undefined;\n\textended_profile?:\n\t\t| {\n\t\t\t\tjob_title?: string;\n\t\t\t\torganization?: string;\n\t\t\t\tdepartment?: string;\n\t\t\t\tlocation?: string;\n\t\t  }\n\t\t| undefined;\n}\nexport interface AtlassianOptions extends ProviderOptions<AtlassianProfile> {\n\tclientId: string;\n}\n\nexport const atlassian = (options: AtlassianOptions) => {\n\treturn {\n\t\tid: \"atlassian\",\n\t\tname: \"Atlassian\",\n\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\"Client Id and Secret are required for Atlassian\");\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Atlassian\");\n\t\t\t}\n\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"read:jira-user\", \"offline_access\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"atlassian\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://auth.atlassian.com/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tadditionalParams: {\n\t\t\t\t\taudience: \"api.atlassian.com\",\n\t\t\t\t},\n\t\t\t\tprompt: options.prompt,\n\t\t\t});\n\t\t},\n\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://auth.atlassian.com/oauth/token\",\n\t\t\t});\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://auth.atlassian.com/oauth/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tif (!token.accessToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { data: profile } = await betterFetch<{\n\t\t\t\t\taccount_id: string;\n\t\t\t\t\tname: string;\n\t\t\t\t\temail?: string | undefined;\n\t\t\t\t\tpicture?: string | undefined;\n\t\t\t\t}>(\"https://api.atlassian.com/me\", {\n\t\t\t\t\theaders: { Authorization: `Bearer ${token.accessToken}` },\n\t\t\t\t});\n\n\t\t\t\tif (!profile) return null;\n\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: profile.account_id,\n\t\t\t\t\t\tname: profile.name,\n\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\timage: profile.picture,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t...userMap,\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile,\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Figma:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\toptions,\n\t} satisfies OAuthProvider<AtlassianProfile>;\n};\n","import { decodeJwt } from \"jose\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface PaybinProfile {\n\tsub: string;\n\temail: string;\n\temail_verified?: boolean | undefined;\n\tname?: string | undefined;\n\tpreferred_username?: string | undefined;\n\tpicture?: string | undefined;\n\tgiven_name?: string | undefined;\n\tfamily_name?: string | undefined;\n}\n\nexport interface PaybinOptions extends ProviderOptions<PaybinProfile> {\n\tclientId: string;\n\t/**\n\t * The issuer URL of your Paybin OAuth server\n\t * @default \"https://idp.paybin.io\"\n\t */\n\tissuer?: string | undefined;\n}\n\nexport const paybin = (options: PaybinOptions) => {\n\tconst issuer = options.issuer || \"https://idp.paybin.io\";\n\tconst authorizationEndpoint = `${issuer}/oauth2/authorize`;\n\tconst tokenEndpoint = `${issuer}/oauth2/token`;\n\n\treturn {\n\t\tid: \"paybin\",\n\t\tname: \"Paybin\",\n\t\tasync createAuthorizationURL({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t\tloginHint,\n\t\t}) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Id and Client Secret is required for Paybin. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Paybin\");\n\t\t\t}\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"email\", \"profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"paybin\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\tloginHint,\n\t\t\t});\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tif (!token.idToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst user = decodeJwt(token.idToken) as PaybinProfile;\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname:\n\t\t\t\t\t\tuser.name ||\n\t\t\t\t\t\tuser.preferred_username ||\n\t\t\t\t\t\t(user.email ? user.email.split(\"@\")[0] : \"User\") ||\n\t\t\t\t\t\t\"User\",\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified: user.email_verified || false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: user,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<PaybinProfile>;\n};\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\nexport interface IHash2 {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key, undefined, 'key');\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, 'nonce');\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) abytes(args[1], undefined, 'AAD');\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output, undefined, 'output');\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('\"ciphertext\" expected length bigger than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error(\n      '\"output\" expected Uint8Array of length ' + expectedLength + ', got: ' + out.length\n    );\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  view.setBigUint64(0, BigInt(aadLength), isLE);\n  view.setBigUint64(8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/**\n * The pseudorandom number generator doesn't wipe current state:\n * instead, it generates new one based on previous state + entropy.\n * Not reseed/rekey, since AES CTR DRBG does rekey on each randomBytes,\n * which is in fact `reseed`, since it changes counter too.\n */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\ntype RemoveNonceInner<T extends any[], Ret> = ((...args: T) => Ret) extends (\n  arg0: any,\n  arg1: any,\n  ...rest: infer R\n) => any\n  ? (key: Uint8Array, ...args: R) => Ret\n  : never;\n\nexport type RemoveNonce<T extends (...args: any) => any> = RemoveNonceInner<\n  Parameters<T>,\n  ReturnType<T>\n>;\nexport type CipherWithNonce = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ...args: any[]\n) => Cipher | AsyncCipher) & {\n  nonceLength: number;\n};\n\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * For `encrypt`, a `nonceBytes`-length buffer is fetched from CSPRNG and\n * prepended to encrypted ciphertext. For `decrypt`, first `nonceBytes` of ciphertext\n * are treated as nonce.\n *\n * NOTE: Under the same key, using random nonces (e.g. `managedNonce`) with AES-GCM and ChaCha\n * should be limited to `2**23` (8M) messages to get a collision chance of `2**-50`. Stretching to  * `2**32` (4B) messages, chance would become `2**-33` - still negligible, but creeping up.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nexport function managedNonce<T extends CipherWithNonce>(\n  fn: T,\n  randomBytes_: typeof randomBytes = randomBytes\n): RemoveNonce<T> {\n  const { nonceLength } = fn;\n  anumber(nonceLength);\n  const addNonce = (nonce: Uint8Array, ciphertext: Uint8Array) => {\n    const out = concatBytes(nonce, ciphertext);\n    ciphertext.fill(0);\n    return out;\n  };\n  // NOTE: we cannot support DST here, it would be mistake:\n  // - we don't know how much dst length cipher requires\n  // - nonce may unalign dst and break everything\n  // - we create new u8a anyway (concatBytes)\n  // - previously we passed all args to cipher, but that was mistake!\n  return ((key: Uint8Array, ...args: any[]): any => ({\n    encrypt(plaintext: Uint8Array) {\n      abytes(plaintext);\n      const nonce = randomBytes_(nonceLength);\n      const encrypted = fn(key, nonce, ...args).encrypt(plaintext);\n      // @ts-ignore\n      if (encrypted instanceof Promise) return encrypted.then((ct) => addNonce(nonce, ct));\n      return addNonce(nonce, encrypted);\n    },\n    decrypt(ciphertext: Uint8Array) {\n      abytes(ciphertext);\n      const nonce = ciphertext.subarray(0, nonceLength);\n      const decrypted = ciphertext.subarray(nonceLength);\n      return fn(key, nonce, ...args).decrypt(decrypted);\n    },\n  })) as RemoveNonce<T>;\n}\n\n// workaround for TS 5.9 language mess:\nexport type Uint8ArrayBuffer = ReturnType<typeof Uint8Array.of>;\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface FigmaProfile {\n\tid: string;\n\temail: string;\n\thandle: string;\n\timg_url: string;\n}\n\nexport interface FigmaOptions extends ProviderOptions<FigmaProfile> {\n\tclientId: string;\n}\n\nexport const figma = (options: FigmaOptions) => {\n\treturn {\n\t\tid: \"figma\",\n\t\tname: \"Figma\",\n\t\tasync createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Id and Client Secret are required for Figma. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Figma\");\n\t\t\t}\n\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"current_user:read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"figma\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.figma.com/oauth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t});\n\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.figma.com/v1/oauth/token\",\n\t\t\t\tauthentication: \"basic\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://api.figma.com/v1/oauth/token\",\n\t\t\t\t\t\tauthentication: \"basic\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { data: profile } = await betterFetch<FigmaProfile>(\n\t\t\t\t\t\"https://api.figma.com/v1/me\",\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!profile) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user from Figma\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: profile.id,\n\t\t\t\t\t\tname: profile.handle,\n\t\t\t\t\t\temail: profile.email,\n\t\t\t\t\t\timage: profile.img_url,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t...userMap,\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile,\n\t\t\t\t};\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from Figma:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<FigmaProfile>;\n};\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { createAuthMiddleware } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { deprecate, normalizePathname } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport { matchesOriginPattern } from \"../../auth/trusted-origins\";\n\n/**\n * Checks if CSRF should be skipped for backward compatibility.\n * Previously, disableOriginCheck also disabled CSRF checks.\n * This maintains that behavior when disableCSRFCheck isn't explicitly set.\n * Only triggers for skipOriginCheck === true, not for path arrays.\n */\nfunction shouldSkipCSRFForBackwardCompat(ctx: GenericEndpointContext): boolean {\n\treturn (\n\t\tctx.context.skipOriginCheck === true &&\n\t\tctx.context.options.advanced?.disableCSRFCheck === undefined\n\t);\n}\n\n/**\n * Logs deprecation warning for users relying on coupled behavior.\n * Only logs if user explicitly set disableOriginCheck (not test environment default).\n */\nconst logBackwardCompatWarning = deprecate(\n\tfunction logBackwardCompatWarning() {},\n\t\"disableOriginCheck: true currently also disables CSRF checks. \" +\n\t\t\"In a future version, disableOriginCheck will ONLY disable URL validation. \" +\n\t\t\"To keep CSRF disabled, add disableCSRFCheck: true to your config.\",\n);\n\n/**\n * A middleware to validate callbackURL and origin against trustedOrigins.\n * Also handles CSRF protection using Fetch Metadata for first-login scenarios.\n */\nexport const originCheckMiddleware = createAuthMiddleware(async (ctx) => {\n\t// Skip origin check for GET, OPTIONS, HEAD requests - we don't mutate state here.\n\tif (\n\t\tctx.request?.method === \"GET\" ||\n\t\tctx.request?.method === \"OPTIONS\" ||\n\t\tctx.request?.method === \"HEAD\" ||\n\t\t!ctx.request\n\t) {\n\t\treturn;\n\t}\n\tawait validateOrigin(ctx);\n\n\tif (ctx.context.skipOriginCheck) {\n\t\treturn;\n\t}\n\n\tconst { body, query } = ctx;\n\tconst callbackURL = body?.callbackURL || query?.callbackURL;\n\tconst redirectURL = body?.redirectTo;\n\tconst errorCallbackURL = body?.errorCallbackURL;\n\tconst newUserCallbackURL = body?.newUserCallbackURL;\n\n\tconst validateURL = (url: string | undefined, label: string) => {\n\t\tif (!url) {\n\t\t\treturn;\n\t\t}\n\t\tconst isTrustedOrigin = ctx.context.isTrustedOrigin(url, {\n\t\t\tallowRelativePaths: label !== \"origin\",\n\t\t});\n\n\t\tif (!isTrustedOrigin) {\n\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\tctx.context.logger.info(\n\t\t\t\t`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`,\n\t\t\t\t`Current list of trustedOrigins: ${ctx.context.trustedOrigins}`,\n\t\t\t);\n\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t}\n\t};\n\n\tcallbackURL && validateURL(callbackURL, \"callbackURL\");\n\tredirectURL && validateURL(redirectURL, \"redirectURL\");\n\terrorCallbackURL && validateURL(errorCallbackURL, \"errorCallbackURL\");\n\tnewUserCallbackURL && validateURL(newUserCallbackURL, \"newUserCallbackURL\");\n});\n\nexport const originCheck = (\n\tgetValue: (ctx: GenericEndpointContext) => string | string[],\n) =>\n\tcreateAuthMiddleware(async (ctx) => {\n\t\tif (!ctx.request) {\n\t\t\treturn;\n\t\t}\n\t\tif (ctx.context.skipOriginCheck) {\n\t\t\treturn;\n\t\t}\n\t\tconst callbackURL = getValue(ctx);\n\t\tconst validateURL = (url: string | undefined, label: string) => {\n\t\t\tif (!url) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isTrustedOrigin = ctx.context.isTrustedOrigin(url, {\n\t\t\t\tallowRelativePaths: label !== \"origin\",\n\t\t\t});\n\n\t\t\tif (!isTrustedOrigin) {\n\t\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\t\tctx.context.logger.info(\n\t\t\t\t\t`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`,\n\t\t\t\t\t`Current list of trustedOrigins: ${ctx.context.trustedOrigins}`,\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t\t}\n\t\t};\n\t\tconst callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];\n\t\tfor (const url of callbacks) {\n\t\t\tvalidateURL(url, \"callbackURL\");\n\t\t}\n\t});\n\n/**\n * Validates origin header against trusted origins.\n * @param ctx - The endpoint context\n * @param forceValidate - If true, always validate origin regardless of cookies/skip flags\n */\nasync function validateOrigin(\n\tctx: GenericEndpointContext,\n\tforceValidate = false,\n): Promise<void> {\n\tconst headers = ctx.request?.headers;\n\tif (!headers || !ctx.request) {\n\t\treturn;\n\t}\n\tconst originHeader = headers.get(\"origin\") || headers.get(\"referer\") || \"\";\n\tconst useCookies = headers.has(\"cookie\");\n\n\tif (ctx.context.skipCSRFCheck) {\n\t\treturn;\n\t}\n\n\tif (shouldSkipCSRFForBackwardCompat(ctx)) {\n\t\tctx.context.options.advanced?.disableOriginCheck === true &&\n\t\t\tlogBackwardCompatWarning();\n\t\treturn;\n\t}\n\n\tconst skipOriginCheck = ctx.context.skipOriginCheck;\n\tif (Array.isArray(skipOriginCheck)) {\n\t\ttry {\n\t\t\tconst basePath = new URL(ctx.context.baseURL).pathname;\n\t\t\tconst currentPath = normalizePathname(ctx.request.url, basePath);\n\t\t\tconst shouldSkipPath = skipOriginCheck.some((skipPath) =>\n\t\t\t\tcurrentPath.startsWith(skipPath),\n\t\t\t);\n\t\t\tif (shouldSkipPath) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// If parsing fails, don't skip - continue with validation\n\t\t}\n\t}\n\n\tconst shouldValidate = forceValidate || useCookies;\n\n\tif (!shouldValidate) {\n\t\treturn;\n\t}\n\n\tif (!originHeader || originHeader === \"null\") {\n\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\tmessage: BASE_ERROR_CODES.MISSING_OR_NULL_ORIGIN,\n\t\t});\n\t}\n\n\tconst trustedOrigins: string[] = Array.isArray(\n\t\tctx.context.options.trustedOrigins,\n\t)\n\t\t? ctx.context.trustedOrigins\n\t\t: [\n\t\t\t\t...ctx.context.trustedOrigins,\n\t\t\t\t...((await ctx.context.options.trustedOrigins?.(ctx.request))?.filter(\n\t\t\t\t\t(v): v is string => Boolean(v),\n\t\t\t\t) || []),\n\t\t\t];\n\n\tconst isTrustedOrigin = trustedOrigins.some((origin) =>\n\t\tmatchesOriginPattern(originHeader, origin),\n\t);\n\tif (!isTrustedOrigin) {\n\t\tctx.context.logger.error(`Invalid origin: ${originHeader}`);\n\t\tctx.context.logger.info(\n\t\t\t`If it's a valid URL, please add ${originHeader} to trustedOrigins in your auth config\\n`,\n\t\t\t`Current list of trustedOrigins: ${trustedOrigins}`,\n\t\t);\n\t\tthrow new APIError(\"FORBIDDEN\", { message: \"Invalid origin\" });\n\t}\n}\n\n/**\n * Middleware for CSRF protection using Fetch Metadata headers.\n * This prevents cross-site navigation login attacks while supporting progressive enhancement.\n */\nexport const formCsrfMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst request = ctx.request;\n\tif (!request) {\n\t\treturn;\n\t}\n\n\tawait validateFormCsrf(ctx);\n});\n\n/**\n * Validates CSRF protection for first-login scenarios using Fetch Metadata headers.\n * This prevents cross-site form submission attacks while supporting progressive enhancement.\n */\nasync function validateFormCsrf(ctx: GenericEndpointContext): Promise<void> {\n\tconst req = ctx.request;\n\tif (!req) {\n\t\treturn;\n\t}\n\n\tif (ctx.context.skipCSRFCheck) {\n\t\treturn;\n\t}\n\n\tif (shouldSkipCSRFForBackwardCompat(ctx)) {\n\t\treturn;\n\t}\n\n\tconst headers = req.headers;\n\tconst hasAnyCookies = headers.has(\"cookie\");\n\n\tif (hasAnyCookies) {\n\t\treturn await validateOrigin(ctx);\n\t}\n\n\tconst site = headers.get(\"Sec-Fetch-Site\");\n\tconst mode = headers.get(\"Sec-Fetch-Mode\");\n\tconst dest = headers.get(\"Sec-Fetch-Dest\");\n\n\tconst hasMetadata = Boolean(\n\t\t(site && site.trim()) || (mode && mode.trim()) || (dest && dest.trim()),\n\t);\n\n\tif (hasMetadata) {\n\t\t// Block cross-site navigation requests (classic CSRF attack pattern)\n\t\tif (site === \"cross-site\" && mode === \"navigate\") {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Blocked cross-site navigation login attempt (CSRF protection)\",\n\t\t\t\t{\n\t\t\t\t\tsecFetchSite: site,\n\t\t\t\t\tsecFetchMode: mode,\n\t\t\t\t\tsecFetchDest: dest,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.CROSS_SITE_NAVIGATION_LOGIN_BLOCKED,\n\t\t\t});\n\t\t}\n\n\t\treturn await validateOrigin(ctx, true);\n\t}\n\n\t// No cookies, no Fetch Metadata  fallback to old behavior (no validation)\n\treturn;\n}\n","import { ZodObject, ZodOptional, ZodType } from \"zod\";\nimport type { Endpoint, EndpointOptions } from \"./endpoint\";\n\nexport type OpenAPISchemaType = \"string\" | \"number\" | \"integer\" | \"boolean\" | \"array\" | \"object\";\n\nexport interface OpenAPIParameter {\n\tin: \"query\" | \"path\" | \"header\" | \"cookie\";\n\tname?: string;\n\tdescription?: string;\n\trequired?: boolean;\n\tschema?: {\n\t\ttype: OpenAPISchemaType;\n\t\tformat?: string;\n\t\titems?: {\n\t\t\ttype: OpenAPISchemaType;\n\t\t};\n\t\tenum?: string[];\n\t\tminLength?: number;\n\t\tdescription?: string;\n\t\tdefault?: string;\n\t\texample?: string;\n\t};\n}\n\nexport interface Path {\n\tget?: {\n\t\ttags?: string[];\n\t\toperationId?: string;\n\t\tdescription?: string;\n\t\tsecurity?: [{ bearerAuth: string[] }];\n\t\tparameters?: OpenAPIParameter[];\n\t\tresponses?: {\n\t\t\t[key in string]: {\n\t\t\t\tdescription?: string;\n\t\t\t\tcontent: {\n\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n\tpost?: {\n\t\ttags?: string[];\n\t\toperationId?: string;\n\t\tdescription?: string;\n\t\tsecurity?: [{ bearerAuth: string[] }];\n\t\tparameters?: OpenAPIParameter[];\n\t\trequestBody?: {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tresponses?: {\n\t\t\t[key in string]: {\n\t\t\t\tdescription?: string;\n\t\t\t\tcontent: {\n\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype?: OpenAPISchemaType;\n\t\t\t\t\t\t\tproperties?: Record<string, any>;\n\t\t\t\t\t\t\trequired?: string[];\n\t\t\t\t\t\t\t$ref?: string;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n}\nconst paths: Record<string, Path> = {};\n\nfunction getTypeFromZodType(zodType: ZodType<any>) {\n\tswitch (zodType.constructor.name) {\n\t\tcase \"ZodString\":\n\t\t\treturn \"string\";\n\t\tcase \"ZodNumber\":\n\t\t\treturn \"number\";\n\t\tcase \"ZodBoolean\":\n\t\t\treturn \"boolean\";\n\t\tcase \"ZodObject\":\n\t\t\treturn \"object\";\n\t\tcase \"ZodArray\":\n\t\t\treturn \"array\";\n\t\tdefault:\n\t\t\treturn \"string\";\n\t}\n}\n\nfunction getParameters(options: EndpointOptions) {\n\tconst parameters: OpenAPIParameter[] = [];\n\tif (options.metadata?.openapi?.parameters) {\n\t\tparameters.push(...options.metadata.openapi.parameters);\n\t\treturn parameters;\n\t}\n\tif (options.query instanceof ZodObject) {\n\t\tObject.entries(options.query.shape).forEach(([key, value]) => {\n\t\t\tif (value instanceof ZodObject) {\n\t\t\t\tparameters.push({\n\t\t\t\t\tname: key,\n\t\t\t\t\tin: \"query\",\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: getTypeFromZodType(value),\n\t\t\t\t\t\t...(\"minLength\" in value && value.minLength\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tminLength: value.minLength as number,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {}),\n\t\t\t\t\t\tdescription: value.description,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\treturn parameters;\n}\n\nfunction getRequestBody(options: EndpointOptions): any {\n\tif (options.metadata?.openapi?.requestBody) {\n\t\treturn options.metadata.openapi.requestBody;\n\t}\n\tif (!options.body) return undefined;\n\tif (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n\t\t// @ts-ignore\n\t\tconst shape = options.body.shape;\n\t\tif (!shape) return undefined;\n\t\tconst properties: Record<string, any> = {};\n\t\tconst required: string[] = [];\n\t\tObject.entries(shape).forEach(([key, value]) => {\n\t\t\tif (value instanceof ZodObject) {\n\t\t\t\tproperties[key] = {\n\t\t\t\t\ttype: getTypeFromZodType(value),\n\t\t\t\t\tdescription: value.description,\n\t\t\t\t};\n\t\t\t\tif (!(value instanceof ZodOptional)) {\n\t\t\t\t\trequired.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\trequired: options.body instanceof ZodOptional ? false : options.body ? true : false,\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties,\n\t\t\t\t\t\trequired,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\treturn undefined;\n}\n\nfunction getResponse(responses?: Record<string, any>) {\n\treturn {\n\t\t\"400\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\"message\"],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription: \"Bad Request. Usually due to missing parameters, or invalid parameters.\",\n\t\t},\n\t\t\"401\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequired: [\"message\"],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription: \"Unauthorized. Due to missing or invalid authentication.\",\n\t\t},\n\t\t\"403\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t\"Forbidden. You do not have permission to access this resource or to perform this action.\",\n\t\t},\n\t\t\"404\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription: \"Not Found. The requested resource was not found.\",\n\t\t},\n\t\t\"429\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription: \"Too Many Requests. You have exceeded the rate limit. Try again later.\",\n\t\t},\n\t\t\"500\": {\n\t\t\tcontent: {\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tschema: {\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t\"Internal Server Error. This is a problem with the server that you cannot fix.\",\n\t\t},\n\t\t...responses,\n\t} as any;\n}\n\nexport async function generator(\n\tendpoints: Record<string, Endpoint>,\n\tconfig?: {\n\t\turl: string;\n\t},\n) {\n\tconst components = {\n\t\tschemas: {},\n\t};\n\n\tObject.entries(endpoints).forEach(([_, value]) => {\n\t\tconst options = value.options as EndpointOptions;\n\t\tif (!value.path || options.metadata?.SERVER_ONLY) return;\n\t\tif (options.method === \"GET\") {\n\t\t\tpaths[value.path] = {\n\t\t\t\tget: {\n\t\t\t\t\ttags: [\"Default\", ...(options.metadata?.openapi?.tags || [])],\n\t\t\t\t\tdescription: options.metadata?.openapi?.description,\n\t\t\t\t\toperationId: options.metadata?.openapi?.operationId,\n\t\t\t\t\tsecurity: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbearerAuth: [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tparameters: getParameters(options),\n\t\t\t\t\tresponses: getResponse(options.metadata?.openapi?.responses),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (options.method === \"POST\") {\n\t\t\tconst body = getRequestBody(options);\n\t\t\tpaths[value.path] = {\n\t\t\t\tpost: {\n\t\t\t\t\ttags: [\"Default\", ...(options.metadata?.openapi?.tags || [])],\n\t\t\t\t\tdescription: options.metadata?.openapi?.description,\n\t\t\t\t\toperationId: options.metadata?.openapi?.operationId,\n\t\t\t\t\tsecurity: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbearerAuth: [],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tparameters: getParameters(options),\n\t\t\t\t\t...(body\n\t\t\t\t\t\t? { requestBody: body }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\trequestBody: {\n\t\t\t\t\t\t\t\t\t//set body none\n\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\tresponses: getResponse(options.metadata?.openapi?.responses),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\tconst res = {\n\t\topenapi: \"3.1.1\",\n\t\tinfo: {\n\t\t\ttitle: \"Better Auth\",\n\t\t\tdescription: \"API Reference for your Better Auth Instance\",\n\t\t\tversion: \"1.1.0\",\n\t\t},\n\t\tcomponents,\n\t\tsecurity: [\n\t\t\t{\n\t\t\t\tapiKeyCookie: [],\n\t\t\t},\n\t\t],\n\t\tservers: [\n\t\t\t{\n\t\t\t\turl: config?.url,\n\t\t\t},\n\t\t],\n\t\ttags: [\n\t\t\t{\n\t\t\t\tname: \"Default\",\n\t\t\t\tdescription:\n\t\t\t\t\t\"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\",\n\t\t\t},\n\t\t],\n\t\tpaths,\n\t};\n\treturn res;\n}\n\nexport const getHTML = (\n\tapiReference: Record<string, any>,\n\tconfig?: {\n\t\tlogo?: string;\n\t\ttheme?: string;\n\t\ttitle?: string;\n\t\tdescription?: string;\n\t},\n) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    </script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config.logo)}` : undefined} ,\n\t   \ttheme: ${config?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n","/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput, bytesToHex,\n  clean, concatBytes, copyBytes, hexToNumber, numberToBytesBE,\n  type IHash2\n} from './utils.ts';\n\nfunction u8to16(a: Uint8Array, i: number) {\n  return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n}\n\nfunction bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\n/** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */\nfunction poly1305_small(msg: Uint8Array, key: Uint8Array): Uint8Array {\n  abytes(msg);\n  abytes(key, 32, 'key');\n  const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5\n  const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1\n  const CLAMP_R = BigInt('0x0ffffffc0ffffffc0ffffffc0fffffff');\n  const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;\n  const s = bytesToNumberLE(key.subarray(16));\n  // Process by 16 byte chunks\n  let acc = BigInt(0);\n  for (let i = 0; i < msg.length; i += 16) {\n    const m = msg.subarray(i, i + 16);\n    const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));\n    acc = ((acc + n) * r) % POW_2_130_5;\n  }\n  const res = (acc + s) & POW_2_128_1;\n  return numberToBytesBE(res, 16).reverse(); // LE\n}\n\n// Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.\n// @ts-expect-error\nfunction poly1305_computeTag_small(\n  authKey: Uint8Array,\n  lengths: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const res = [];\n  const updatePadded2 = (msg: Uint8Array) => {\n    res.push(msg);\n    const leftover = msg.length % 16;\n    if (leftover) res.push(new Uint8Array(16).slice(leftover));\n  };\n  if (AAD) updatePadded2(AAD);\n  updatePadded2(ciphertext);\n  res.push(lengths);\n  return poly1305_small(concatBytes(...res), authKey);\n}\n\n/** Poly1305 class. Prefer poly1305() function instead. */\nexport class Poly1305 implements IHash2 {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10); // Allocating 1 array with .subarray() here is slower than 3\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  // Can be speed-up using BigUint64Array, at the cost of complexity\n  constructor(key: Uint8Array) {\n    key = copyBytes(abytes(key, 32, 'key'));\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n    clean(g);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    data = copyBytes(data);\n    const { buffer, blockLen } = this;\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy(): void {\n    clean(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends IHash2>(\n  hashCons: (key: Uint8Array) => H\n): {\n  (msg: Uint8Array, key: Uint8Array): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Uint8Array): H;\n} {\n  const hashC = (msg: Uint8Array, key: Uint8Array): Uint8Array =>\n    hashCons(key).update(msg).digest();\n  const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Uint8Array) => hashCons(key);\n  return hashC;\n}\n\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305: CHash = /** @__PURE__ */ (() =>\n  wrapConstructorWithKey((key) => new Poly1305(key)))();\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { decodeJwt } from \"jose\";\nimport { logger } from \"../env\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { createAuthorizationURL } from \"../oauth2\";\n\nexport interface PayPalProfile {\n\tuser_id: string;\n\tname: string;\n\tgiven_name: string;\n\tfamily_name: string;\n\tmiddle_name?: string | undefined;\n\tpicture?: string | undefined;\n\temail: string;\n\temail_verified: boolean;\n\tgender?: string | undefined;\n\tbirthdate?: string | undefined;\n\tzoneinfo?: string | undefined;\n\tlocale?: string | undefined;\n\tphone_number?: string | undefined;\n\taddress?:\n\t\t| {\n\t\t\t\tstreet_address?: string;\n\t\t\t\tlocality?: string;\n\t\t\t\tregion?: string;\n\t\t\t\tpostal_code?: string;\n\t\t\t\tcountry?: string;\n\t\t  }\n\t\t| undefined;\n\tverified_account?: boolean | undefined;\n\taccount_type?: string | undefined;\n\tage_range?: string | undefined;\n\tpayer_id?: string | undefined;\n}\n\nexport interface PayPalTokenResponse {\n\tscope?: string | undefined;\n\taccess_token: string;\n\trefresh_token?: string | undefined;\n\ttoken_type: \"Bearer\";\n\tid_token?: string | undefined;\n\texpires_in: number;\n\tnonce?: string | undefined;\n}\n\nexport interface PayPalOptions extends ProviderOptions<PayPalProfile> {\n\tclientId: string;\n\t/**\n\t * PayPal environment - 'sandbox' for testing, 'live' for production\n\t * @default 'sandbox'\n\t */\n\tenvironment?: (\"sandbox\" | \"live\") | undefined;\n\t/**\n\t * Whether to request shipping address information\n\t * @default false\n\t */\n\trequestShippingAddress?: boolean | undefined;\n}\n\nexport const paypal = (options: PayPalOptions) => {\n\tconst environment = options.environment || \"sandbox\";\n\tconst isSandbox = environment === \"sandbox\";\n\n\tconst authorizationEndpoint = isSandbox\n\t\t? \"https://www.sandbox.paypal.com/signin/authorize\"\n\t\t: \"https://www.paypal.com/signin/authorize\";\n\n\tconst tokenEndpoint = isSandbox\n\t\t? \"https://api-m.sandbox.paypal.com/v1/oauth2/token\"\n\t\t: \"https://api-m.paypal.com/v1/oauth2/token\";\n\n\tconst userInfoEndpoint = isSandbox\n\t\t? \"https://api-m.sandbox.paypal.com/v1/identity/oauth2/userinfo\"\n\t\t: \"https://api-m.paypal.com/v1/identity/oauth2/userinfo\";\n\n\treturn {\n\t\tid: \"paypal\",\n\t\tname: \"PayPal\",\n\t\tasync createAuthorizationURL({ state, codeVerifier, redirectURI }) {\n\t\t\tif (!options.clientId || !options.clientSecret) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Client Id and Client Secret is required for PayPal. Make sure to provide them in the options.\",\n\t\t\t\t);\n\t\t\t\tthrow new BetterAuthError(\"CLIENT_ID_AND_SECRET_REQUIRED\");\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Log in with PayPal doesn't use traditional OAuth2 scopes\n\t\t\t * Instead, permissions are configured in the PayPal Developer Dashboard\n\t\t\t * We don't pass any scopes to avoid \"invalid scope\" errors\n\t\t\t **/\n\n\t\t\tconst _scopes: string[] = [];\n\n\t\t\tconst url = await createAuthorizationURL({\n\t\t\t\tid: \"paypal\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t});\n\t\t\treturn url;\n\t\t},\n\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\t/**\n\t\t\t * PayPal requires Basic Auth for token exchange\n\t\t\t **/\n\n\t\t\tconst credentials = base64.encode(\n\t\t\t\t`${options.clientId}:${options.clientSecret}`,\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\tconst response = await betterFetch(tokenEndpoint, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Basic ${credentials}`,\n\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t\"Accept-Language\": \"en_US\",\n\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\",\n\t\t\t\t\t},\n\t\t\t\t\tbody: new URLSearchParams({\n\t\t\t\t\t\tgrant_type: \"authorization_code\",\n\t\t\t\t\t\tcode: code,\n\t\t\t\t\t\tredirect_uri: redirectURI,\n\t\t\t\t\t}).toString(),\n\t\t\t\t});\n\n\t\t\t\tif (!response.data) {\n\t\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_GET_ACCESS_TOKEN\");\n\t\t\t\t}\n\n\t\t\t\tconst data = response.data as PayPalTokenResponse;\n\n\t\t\t\tconst result = {\n\t\t\t\t\taccessToken: data.access_token,\n\t\t\t\t\trefreshToken: data.refresh_token,\n\t\t\t\t\taccessTokenExpiresAt: data.expires_in\n\t\t\t\t\t\t? new Date(Date.now() + data.expires_in * 1000)\n\t\t\t\t\t\t: undefined,\n\t\t\t\t\tidToken: data.id_token,\n\t\t\t\t};\n\n\t\t\t\treturn result;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"PayPal token exchange failed:\", error);\n\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_GET_ACCESS_TOKEN\");\n\t\t\t}\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\tconst credentials = base64.encode(\n\t\t\t\t\t\t`${options.clientId}:${options.clientSecret}`,\n\t\t\t\t\t);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst response = await betterFetch(tokenEndpoint, {\n\t\t\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\tAuthorization: `Basic ${credentials}`,\n\t\t\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t\t\t\"Accept-Language\": \"en_US\",\n\t\t\t\t\t\t\t\t\"Content-Type\": \"application/x-www-form-urlencoded\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: new URLSearchParams({\n\t\t\t\t\t\t\t\tgrant_type: \"refresh_token\",\n\t\t\t\t\t\t\t\trefresh_token: refreshToken,\n\t\t\t\t\t\t\t}).toString(),\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!response.data) {\n\t\t\t\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_REFRESH_ACCESS_TOKEN\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst data = response.data as any;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\taccessToken: data.access_token,\n\t\t\t\t\t\t\trefreshToken: data.refresh_token,\n\t\t\t\t\t\t\taccessTokenExpiresAt: data.expires_in\n\t\t\t\t\t\t\t\t? new Date(Date.now() + data.expires_in * 1000)\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger.error(\"PayPal token refresh failed:\", error);\n\t\t\t\t\t\tthrow new BetterAuthError(\"FAILED_TO_REFRESH_ACCESS_TOKEN\");\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst payload = decodeJwt(token);\n\t\t\t\treturn !!payload.sub;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to verify PayPal ID token:\", error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tif (!token.accessToken) {\n\t\t\t\tlogger.error(\"Access token is required to fetch PayPal user info\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst response = await betterFetch<PayPalProfile>(\n\t\t\t\t\t`${userInfoEndpoint}?schema=paypalv1.1`,\n\t\t\t\t\t{\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t\tAccept: \"application/json\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!response.data) {\n\t\t\t\t\tlogger.error(\"Failed to fetch user info from PayPal\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst userInfo = response.data;\n\t\t\t\tconst userMap = await options.mapProfileToUser?.(userInfo);\n\n\t\t\t\tconst result = {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tid: userInfo.user_id,\n\t\t\t\t\t\tname: userInfo.name,\n\t\t\t\t\t\temail: userInfo.email,\n\t\t\t\t\t\timage: userInfo.picture,\n\t\t\t\t\t\temailVerified: userInfo.email_verified,\n\t\t\t\t\t\t...userMap,\n\t\t\t\t\t},\n\t\t\t\t\tdata: userInfo,\n\t\t\t\t};\n\n\t\t\t\treturn result;\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\"Failed to fetch user info from PayPal:\", error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\t\toptions,\n\t} satisfies OAuthProvider<PayPalProfile>;\n};\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView, type Hash } from './utils.ts';\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> implements Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen must be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to as unknown as any;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, type CHash, type Hash } from './utils.ts';\n\n/** Internal class for HMAC. */\nexport class _HMAC<T extends Hash<T>> implements Hash<_HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, key: Uint8Array) {\n    ahash(hash);\n    abytes(key, undefined, 'key');\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Uint8Array): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen, 'output');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: _HMAC<T>): _HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): _HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array;\n  create(hash: CHash, key: Uint8Array): _HMAC<any>;\n} = (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array =>\n  new _HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Uint8Array) => new _HMAC<any>(hash, key);\n","/**\n * HKDF (RFC 5869): extract + expand in one step.\n * See https://soatok.blog/2021/11/17/understanding-hkdf/.\n * @module\n */\nimport { hmac } from './hmac.ts';\nimport { abytes, ahash, anumber, type CHash, clean } from './utils.ts';\n\n/**\n * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n */\nexport function extract(hash: CHash, ikm: Uint8Array, salt?: Uint8Array): Uint8Array {\n  ahash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen);\n  return hmac(hash, salt, ikm);\n}\n\nconst HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);\nconst EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\n\n/**\n * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`\n * @param hash - hash function that would be used (e.g. sha256)\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n */\nexport function expand(\n  hash: CHash,\n  prk: Uint8Array,\n  info?: Uint8Array,\n  length: number = 32\n): Uint8Array {\n  ahash(hash);\n  anumber(length, 'length');\n  const olen = hash.outputLen;\n  if (length > 255 * olen) throw new Error('Length must be <= 255*HashLen');\n  const blocks = Math.ceil(length / olen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  else abytes(info, undefined, 'info');\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * olen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, olen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  clean(T, HKDF_COUNTER);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * import { hkdf } from '@noble/hashes/hkdf';\n * import { sha256 } from '@noble/hashes/sha2';\n * import { randomBytes } from '@noble/hashes/utils';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1 = hkdf(sha256, inputKey, salt, info, 32);\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Uint8Array,\n  salt: Uint8Array | undefined,\n  info: Uint8Array | undefined,\n  length: number\n): Uint8Array => expand(hash, extract(hash, ikm, salt), info, length);\n","import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport type { Account } from \"@better-auth/core/db\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport type { OAuth2Tokens } from \"@better-auth/core/oauth2\";\nimport { SocialProviderListEnum } from \"@better-auth/core/social-providers\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport {\n\tgetAccountCookie,\n\tsetAccountCookie,\n} from \"../../cookies/session-store\";\nimport { parseAccountOutput } from \"../../db/schema\";\nimport { generateState } from \"../../oauth2/state\";\nimport { decryptOAuthToken, setTokenUtil } from \"../../oauth2/utils\";\nimport {\n\tfreshSessionMiddleware,\n\tgetSessionFromCtx,\n\tsessionMiddleware,\n} from \"./session\";\n\nexport const listUserAccounts = createAuthEndpoint(\n\t\"/list-accounts\",\n\t{\n\t\tmethod: \"GET\",\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"listUserAccounts\",\n\t\t\t\tdescription: \"List all accounts linked to the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tproviderId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\taccountId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tscopes: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"providerId\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"accountId\",\n\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\"scopes\",\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst session = c.context.session;\n\t\tconst accounts = await c.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\treturn c.json(\n\t\t\taccounts.map((a) => {\n\t\t\t\tconst { scope, ...parsed } = parseAccountOutput(c.context.options, a);\n\t\t\t\treturn {\n\t\t\t\t\t...parsed,\n\t\t\t\t\tscopes: scope?.split(\",\") || [],\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\t},\n);\n\nexport const linkSocialAccount = createAuthEndpoint(\n\t\"/link-social\",\n\t{\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * Callback URL to redirect to after the user has signed in.\n\t\t\t */\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after the user has signed in\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * OAuth2 provider to use\n\t\t\t */\n\t\t\tprovider: SocialProviderListEnum,\n\t\t\t/**\n\t\t\t * ID Token for direct authentication without redirect\n\t\t\t */\n\t\t\tidToken: z\n\t\t\t\t.object({\n\t\t\t\t\ttoken: z.string(),\n\t\t\t\t\tnonce: z.string().optional(),\n\t\t\t\t\taccessToken: z.string().optional(),\n\t\t\t\t\trefreshToken: z.string().optional(),\n\t\t\t\t\tscopes: z.array(z.string()).optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Whether to allow sign up for new users\n\t\t\t */\n\t\t\trequestSignUp: z.boolean().optional(),\n\t\t\t/**\n\t\t\t * Additional scopes to request when linking the account.\n\t\t\t * This is useful for requesting additional permissions when\n\t\t\t * linking a social account compared to the initial authentication.\n\t\t\t */\n\t\t\tscopes: z\n\t\t\t\t.array(z.string())\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Additional scopes to request from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The URL to redirect to if there is an error during the link process.\n\t\t\t */\n\t\t\terrorCallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The URL to redirect to if there is an error during the link process\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Disable automatic redirection to the provider\n\t\t\t *\n\t\t\t * This is useful if you want to handle the redirection\n\t\t\t * yourself like in a popup or a different tab.\n\t\t\t */\n\t\t\tdisableRedirect: z\n\t\t\t\t.boolean()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"Disable automatic redirection to the provider. Useful for handling the redirection yourself\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Any additional data to pass through the oauth flow.\n\t\t\t */\n\t\t\tadditionalData: z.record(z.string(), z.any()).optional(),\n\t\t}),\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Link a social account to the user\",\n\t\t\t\toperationId: \"linkSocialAccount\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"The authorization URL to redirect the user to\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the user should be redirected to the authorization URL\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"redirect\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst session = c.context.session;\n\n\t\tconst provider = c.context.socialProviders.find(\n\t\t\t(p) => p.id === c.body.provider,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Provider not found. Make sure to add the provider in your auth config\",\n\t\t\t\t{\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PROVIDER_NOT_FOUND,\n\t\t\t});\n\t\t}\n\n\t\t// Handle ID Token flow if provided\n\t\tif (c.body.idToken) {\n\t\t\tif (!provider.verifyIdToken) {\n\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\"Provider does not support id token verification\",\n\t\t\t\t\t{\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { token, nonce } = c.body.idToken;\n\t\t\tconst valid = await provider.verifyIdToken(token, nonce);\n\t\t\tif (!valid) {\n\t\t\t\tc.context.logger.error(\"Invalid id token\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst linkingUserInfo = await provider.getUserInfo({\n\t\t\t\tidToken: token,\n\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t});\n\n\t\t\tif (!linkingUserInfo || !linkingUserInfo?.user) {\n\t\t\t\tc.context.logger.error(\"Failed to get user info\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst linkingUserId = String(linkingUserInfo.user.id);\n\n\t\t\tif (!linkingUserInfo.user.email) {\n\t\t\t\tc.context.logger.error(\"User email not found\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst existingAccounts = await c.context.internalAdapter.findAccounts(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\n\t\t\tconst hasBeenLinked = existingAccounts.find(\n\t\t\t\t(a) => a.providerId === provider.id && a.accountId === linkingUserId,\n\t\t\t);\n\n\t\t\tif (hasBeenLinked) {\n\t\t\t\treturn c.json({\n\t\t\t\t\turl: \"\", // this is for type inference\n\t\t\t\t\tstatus: true,\n\t\t\t\t\tredirect: false,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\n\t\t\tconst isTrustedProvider = trustedProviders?.includes(provider.id);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !linkingUserInfo.user.emailVerified) ||\n\t\t\t\tc.context.options.account?.accountLinking?.enabled === false\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Account not linked - linking not allowed\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tlinkingUserInfo.user.email !== session.user.email &&\n\t\t\t\tc.context.options.account?.accountLinking?.allowDifferentEmails !== true\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Account not linked - different emails not allowed\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.createAccount({\n\t\t\t\t\tuserId: session.user.id,\n\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\taccountId: linkingUserId,\n\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\tidToken: token,\n\t\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t\t\tscope: c.body.idToken.scopes?.join(\",\"),\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\tthrow new APIError(\"EXPECTATION_FAILED\", {\n\t\t\t\t\tmessage: \"Account not linked - unable to create account\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tc.context.options.account?.accountLinking?.updateUserInfoOnLink === true\n\t\t\t) {\n\t\t\t\ttry {\n\t\t\t\t\tawait c.context.internalAdapter.updateUser(session.user.id, {\n\t\t\t\t\t\tname: linkingUserInfo.user?.name,\n\t\t\t\t\t\timage: linkingUserInfo.user?.image,\n\t\t\t\t\t});\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tconsole.warn(\"Could not update user - \" + e.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn c.json({\n\t\t\t\turl: \"\", // this is for type inference\n\t\t\t\tstatus: true,\n\t\t\t\tredirect: false,\n\t\t\t});\n\t\t}\n\n\t\t// Handle OAuth flow\n\t\tconst state = await generateState(\n\t\t\tc,\n\t\t\t{\n\t\t\t\tuserId: session.user.id,\n\t\t\t\temail: session.user.email,\n\t\t\t},\n\t\t\tc.body.additionalData,\n\t\t);\n\n\t\tconst url = await provider.createAuthorizationURL({\n\t\t\tstate: state.state,\n\t\t\tcodeVerifier: state.codeVerifier,\n\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\tscopes: c.body.scopes,\n\t\t});\n\n\t\tif (!c.body.disableRedirect) {\n\t\t\tc.setHeader(\"Location\", url.toString());\n\t\t}\n\n\t\treturn c.json({\n\t\t\turl: url.toString(),\n\t\t\tredirect: !c.body.disableRedirect,\n\t\t});\n\t},\n);\nexport const unlinkAccount = createAuthEndpoint(\n\t\"/unlink-account\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string(),\n\t\t\taccountId: z.string().optional(),\n\t\t}),\n\t\tuse: [freshSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Unlink an account\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId } = ctx.body;\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tctx.context.session.user.id,\n\t\t);\n\t\tif (\n\t\t\taccounts.length === 1 &&\n\t\t\t!ctx.context.options.account?.accountLinking?.allowUnlinkingAll\n\t\t) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT,\n\t\t\t});\n\t\t}\n\t\tconst accountExist = accounts.find((account) =>\n\t\t\taccountId\n\t\t\t\t? account.accountId === accountId && account.providerId === providerId\n\t\t\t\t: account.providerId === providerId,\n\t\t);\n\t\tif (!accountExist) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND,\n\t\t\t});\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteAccount(accountExist.id);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const getAccessToken = createAuthEndpoint(\n\t\"/get-access-token\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string().meta({\n\t\t\t\tdescription: \"The provider ID for the OAuth provider\",\n\t\t\t}),\n\t\t\taccountId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The account ID associated with the refresh token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\tuserId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The user ID associated with the account\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Get a valid access token, doing a refresh if needed\",\n\t\t\t\tresponses: {\n\t\t\t\t\t200: {\n\t\t\t\t\t\tdescription: \"A Valid access token\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttokenType: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tidToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t400: {\n\t\t\t\t\t\tdescription: \"Invalid refresh token or provider configuration\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId, userId } = ctx.body || {};\n\t\tconst req = ctx.request;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (req && !session) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst resolvedUserId = session?.user?.id || userId;\n\t\tif (!resolvedUserId) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tif (!ctx.context.socialProviders.find((p) => p.id === providerId)) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} is not supported.`,\n\t\t\t});\n\t\t}\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tlet account: Account | undefined = undefined;\n\t\tif (\n\t\t\taccountData &&\n\t\t\tproviderId === accountData.providerId &&\n\t\t\t(!accountId || accountData.id === accountId)\n\t\t) {\n\t\t\taccount = accountData;\n\t\t} else {\n\t\t\tconst accounts =\n\t\t\t\tawait ctx.context.internalAdapter.findAccounts(resolvedUserId);\n\t\t\taccount = accounts.find((acc) =>\n\t\t\t\taccountId\n\t\t\t\t\t? acc.id === accountId && acc.providerId === providerId\n\t\t\t\t\t: acc.providerId === providerId,\n\t\t\t);\n\t\t}\n\n\t\tif (!account) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === providerId,\n\t\t);\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} not found.`,\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tlet newTokens: OAuth2Tokens | null = null;\n\t\t\tconst accessTokenExpired =\n\t\t\t\taccount.accessTokenExpiresAt &&\n\t\t\t\tnew Date(account.accessTokenExpiresAt).getTime() - Date.now() < 5_000;\n\t\t\tif (\n\t\t\t\taccount.refreshToken &&\n\t\t\t\taccessTokenExpired &&\n\t\t\t\tprovider.refreshAccessToken\n\t\t\t) {\n\t\t\t\tconst refreshToken = await decryptOAuthToken(\n\t\t\t\t\taccount.refreshToken,\n\t\t\t\t\tctx.context,\n\t\t\t\t);\n\t\t\t\tnewTokens = await provider.refreshAccessToken(refreshToken);\n\t\t\t\tconst updatedData = {\n\t\t\t\t\taccessToken: await setTokenUtil(newTokens.accessToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: newTokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshToken: await setTokenUtil(newTokens.refreshToken, ctx.context),\n\t\t\t\t\trefreshTokenExpiresAt: newTokens.refreshTokenExpiresAt,\n\t\t\t\t};\n\t\t\t\tlet updatedAccount: Record<string, any> | null = null;\n\t\t\t\tif (account.id) {\n\t\t\t\t\tupdatedAccount = await ctx.context.internalAdapter.updateAccount(\n\t\t\t\t\t\taccount.id,\n\t\t\t\t\t\tupdatedData,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\t\t\t\tawait setAccountCookie(ctx, {\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\t...(updatedAccount ?? updatedData),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst accessTokenExpiresAt = (() => {\n\t\t\t\tif (newTokens?.accessTokenExpiresAt) {\n\t\t\t\t\tif (typeof newTokens.accessTokenExpiresAt === \"string\") {\n\t\t\t\t\t\treturn new Date(newTokens.accessTokenExpiresAt);\n\t\t\t\t\t}\n\t\t\t\t\treturn newTokens.accessTokenExpiresAt;\n\t\t\t\t}\n\t\t\t\tif (account.accessTokenExpiresAt) {\n\t\t\t\t\tif (typeof account.accessTokenExpiresAt === \"string\") {\n\t\t\t\t\t\treturn new Date(account.accessTokenExpiresAt);\n\t\t\t\t\t}\n\t\t\t\t\treturn account.accessTokenExpiresAt;\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})();\n\n\t\t\tconst tokens = {\n\t\t\t\taccessToken:\n\t\t\t\t\tnewTokens?.accessToken ??\n\t\t\t\t\t(await decryptOAuthToken(account.accessToken ?? \"\", ctx.context)),\n\t\t\t\taccessTokenExpiresAt,\n\t\t\t\tscopes: account.scope?.split(\",\") ?? [],\n\t\t\t\tidToken: newTokens?.idToken ?? account.idToken ?? undefined,\n\t\t\t};\n\t\t\treturn ctx.json(tokens);\n\t\t} catch (error) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Failed to get a valid access token\",\n\t\t\t\tcause: error,\n\t\t\t});\n\t\t}\n\t},\n);\n\nexport const refreshToken = createAuthEndpoint(\n\t\"/refresh-token\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string().meta({\n\t\t\t\tdescription: \"The provider ID for the OAuth provider\",\n\t\t\t}),\n\t\t\taccountId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The account ID associated with the refresh token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\tuserId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The user ID associated with the account\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Refresh the access token using a refresh token\",\n\t\t\t\tresponses: {\n\t\t\t\t\t200: {\n\t\t\t\t\t\tdescription: \"Access token refreshed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttokenType: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tidToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trefreshToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trefreshTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t400: {\n\t\t\t\t\t\tdescription: \"Invalid refresh token or provider configuration\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId, userId } = ctx.body;\n\t\tconst req = ctx.request;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (req && !session) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst resolvedUserId = session?.user?.id || userId;\n\t\tif (!resolvedUserId) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Either userId or session is required`,\n\t\t\t});\n\t\t}\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === providerId,\n\t\t);\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} not found.`,\n\t\t\t});\n\t\t}\n\t\tif (!provider.refreshAccessToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} does not support token refreshing.`,\n\t\t\t});\n\t\t}\n\n\t\t// Try to read refresh token from cookie first\n\t\tlet account: Account | undefined = undefined;\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tif (\n\t\t\taccountData &&\n\t\t\t(!providerId || providerId === accountData?.providerId)\n\t\t) {\n\t\t\taccount = accountData;\n\t\t} else {\n\t\t\tconst accounts =\n\t\t\t\tawait ctx.context.internalAdapter.findAccounts(resolvedUserId);\n\t\t\taccount = accounts.find((acc) =>\n\t\t\t\taccountId\n\t\t\t\t\t? acc.id === accountId && acc.providerId === providerId\n\t\t\t\t\t: acc.providerId === providerId,\n\t\t\t);\n\t\t}\n\n\t\tif (!account) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\n\t\tlet refreshToken: string | null | undefined = undefined;\n\t\tif (accountData && providerId === accountData.providerId) {\n\t\t\trefreshToken = accountData.refreshToken ?? undefined;\n\t\t} else {\n\t\t\trefreshToken = account.refreshToken ?? undefined;\n\t\t}\n\n\t\tif (!refreshToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Refresh token not found\",\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tconst decryptedRefreshToken = await decryptOAuthToken(\n\t\t\t\trefreshToken,\n\t\t\t\tctx.context,\n\t\t\t);\n\t\t\tconst tokens: OAuth2Tokens = await provider.refreshAccessToken(\n\t\t\t\tdecryptedRefreshToken,\n\t\t\t);\n\n\t\t\tif (account.id) {\n\t\t\t\tconst updateData = {\n\t\t\t\t\t...(account || {}),\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\t\t\tidToken: tokens.idToken || account.idToken,\n\t\t\t\t};\n\t\t\t\tawait ctx.context.internalAdapter.updateAccount(account.id, updateData);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\taccountData &&\n\t\t\t\tproviderId === accountData.providerId &&\n\t\t\t\tctx.context.options.account?.storeAccountCookie\n\t\t\t) {\n\t\t\t\tconst updateData = {\n\t\t\t\t\t...accountData,\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\tscope: tokens.scopes?.join(\",\") || accountData.scope,\n\t\t\t\t\tidToken: tokens.idToken || accountData.idToken,\n\t\t\t\t};\n\t\t\t\tawait setAccountCookie(ctx, updateData);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\taccessToken: tokens.accessToken,\n\t\t\t\trefreshToken: tokens.refreshToken,\n\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\t\tidToken: tokens.idToken || account.idToken,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: account.accountId,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Failed to refresh access token\",\n\t\t\t\tcause: error,\n\t\t\t});\n\t\t}\n\t},\n);\n\nconst accountInfoQuerySchema = z.optional(\n\tz.object({\n\t\taccountId: z\n\t\t\t.string()\n\t\t\t.meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The provider given account id for which to get the account info\",\n\t\t\t})\n\t\t\t.optional(),\n\t}),\n);\n\nexport const accountInfo = createAuthEndpoint(\n\t\"/account-info\",\n\t{\n\t\tmethod: \"GET\",\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Get the account info provided by the provider\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequired: [\"id\", \"emailVerified\"],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\", \"data\"],\n\t\t\t\t\t\t\t\t\tadditionalProperties: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tquery: accountInfoQuerySchema,\n\t},\n\tasync (ctx) => {\n\t\tconst providedAccountId = ctx.query?.accountId;\n\t\tlet account: Account | undefined = undefined;\n\t\tif (!providedAccountId) {\n\t\t\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\t\t\tconst accountData = await getAccountCookie(ctx);\n\t\t\t\tif (accountData) {\n\t\t\t\t\taccount = accountData;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst accountData =\n\t\t\t\tawait ctx.context.internalAdapter.findAccount(providedAccountId);\n\t\t\tif (accountData) {\n\t\t\t\taccount = accountData;\n\t\t\t}\n\t\t}\n\n\t\tif (!account || account.userId !== ctx.context.session.user.id) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === account.providerId,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: `Provider account provider is ${account.providerId} but it is not configured`,\n\t\t\t});\n\t\t}\n\t\tconst tokens = await getAccessToken({\n\t\t\t...ctx,\n\t\t\tmethod: \"POST\",\n\t\t\tbody: {\n\t\t\t\taccountId: account.id,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t},\n\t\t\treturnHeaders: false,\n\t\t\treturnStatus: false,\n\t\t});\n\t\tif (!tokens.accessToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Access token not found\",\n\t\t\t});\n\t\t}\n\t\tconst info = await provider.getUserInfo({\n\t\t\t...tokens,\n\t\t\taccessToken: tokens.accessToken as string,\n\t\t});\n\t\treturn ctx.json(info);\n\t},\n);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { decodeJwt } from \"jose\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface LineIdTokenPayload {\n\tiss: string;\n\tsub: string;\n\taud: string;\n\texp: number;\n\tiat: number;\n\tname?: string | undefined;\n\tpicture?: string | undefined;\n\temail?: string | undefined;\n\tamr?: string[] | undefined;\n\tnonce?: string | undefined;\n}\n\nexport interface LineUserInfo {\n\tsub: string;\n\tname?: string | undefined;\n\tpicture?: string | undefined;\n\temail?: string | undefined;\n}\n\nexport interface LineOptions\n\textends ProviderOptions<LineUserInfo | LineIdTokenPayload> {\n\tclientId: string;\n}\n\n/**\n * LINE Login v2.1\n * - Authorization endpoint: https://access.line.me/oauth2/v2.1/authorize\n * - Token endpoint: https://api.line.me/oauth2/v2.1/token\n * - UserInfo endpoint: https://api.line.me/oauth2/v2.1/userinfo\n * - Verify ID token: https://api.line.me/oauth2/v2.1/verify\n *\n * Docs: https://developers.line.biz/en/reference/line-login/#issue-access-token\n */\nexport const line = (options: LineOptions) => {\n\tconst authorizationEndpoint = \"https://access.line.me/oauth2/v2.1/authorize\";\n\tconst tokenEndpoint = \"https://api.line.me/oauth2/v2.1/token\";\n\tconst userInfoEndpoint = \"https://api.line.me/oauth2/v2.1/userinfo\";\n\tconst verifyIdTokenEndpoint = \"https://api.line.me/oauth2/v2.1/verify\";\n\n\treturn {\n\t\tid: \"line\",\n\t\tname: \"LINE\",\n\t\tasync createAuthorizationURL({\n\t\t\tstate,\n\t\t\tscopes,\n\t\t\tcodeVerifier,\n\t\t\tredirectURI,\n\t\t\tloginHint,\n\t\t}) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"line\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\t\t\tconst body = new URLSearchParams();\n\t\t\tbody.set(\"id_token\", token);\n\t\t\tbody.set(\"client_id\", options.clientId);\n\t\t\tif (nonce) body.set(\"nonce\", nonce);\n\t\t\tconst { data, error } = await betterFetch<LineIdTokenPayload>(\n\t\t\t\tverifyIdTokenEndpoint,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\t\t\t\t},\n\t\t\t\t\tbody,\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error || !data) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// aud must match clientId; nonce (if provided) must also match nonce\n\t\t\tif (data.aud !== options.clientId) return false;\n\t\t\tif (data.nonce && data.nonce !== nonce) return false;\n\t\t\treturn true;\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tlet profile: LineUserInfo | LineIdTokenPayload | null = null;\n\t\t\t// Prefer ID token if available\n\t\t\tif (token.idToken) {\n\t\t\t\ttry {\n\t\t\t\t\tprofile = decodeJwt(token.idToken) as LineIdTokenPayload;\n\t\t\t\t} catch {}\n\t\t\t}\n\t\t\t// Fallback to UserInfo endpoint\n\t\t\tif (!profile) {\n\t\t\t\tconst { data } = await betterFetch<LineUserInfo>(userInfoEndpoint, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tprofile = data || null;\n\t\t\t}\n\t\t\tif (!profile) return null;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile as any);\n\t\t\t// ID preference order\n\t\t\tconst id = (profile as any).sub || (profile as any).userId;\n\t\t\tconst name = (profile as any).name || (profile as any).displayName;\n\t\t\tconst image =\n\t\t\t\t(profile as any).picture || (profile as any).pictureUrl || undefined;\n\t\t\tconst email = (profile as any).email;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid,\n\t\t\t\t\tname,\n\t\t\t\t\temail,\n\t\t\t\t\timage,\n\t\t\t\t\t// LINE does not expose email verification status in ID token/userinfo\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile as any,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<LineUserInfo | LineIdTokenPayload, LineOptions>;\n};\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport type { JWTPayload, JWTVerifyResult } from \"jose\";\nimport { jwtVerify } from \"jose\";\nimport { JWTExpired } from \"jose/errors\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { signJWT } from \"../../crypto/jwt\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport type { User } from \"../../types\";\nimport { originCheck } from \"../middlewares\";\nimport { getSessionFromCtx } from \"./session\";\n\nexport async function createEmailVerificationToken(\n\tsecret: string,\n\temail: string,\n\t/**\n\t * The email to update from\n\t */\n\tupdateTo?: string | undefined,\n\t/**\n\t * The time in seconds for the token to expire\n\t */\n\texpiresIn: number = 3600,\n\t/**\n\t * Extra payload to include in the token\n\t */\n\textraPayload?: Record<string, any>,\n) {\n\tconst token = await signJWT(\n\t\t{\n\t\t\temail: email.toLowerCase(),\n\t\t\tupdateTo,\n\t\t\t...extraPayload,\n\t\t},\n\t\tsecret,\n\t\texpiresIn,\n\t);\n\treturn token;\n}\n\n/**\n * A function to send a verification email to the user\n */\nexport async function sendVerificationEmailFn(\n\tctx: GenericEndpointContext,\n\tuser: User,\n) {\n\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t});\n\t}\n\tconst token = await createEmailVerificationToken(\n\t\tctx.context.secret,\n\t\tuser.email,\n\t\tundefined,\n\t\tctx.context.options.emailVerification?.expiresIn,\n\t);\n\tconst callbackURL = ctx.body.callbackURL\n\t\t? encodeURIComponent(ctx.body.callbackURL)\n\t\t: encodeURIComponent(\"/\");\n\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\tawait ctx.context.runInBackgroundOrAwait(\n\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t{\n\t\t\t\tuser: user,\n\t\t\t\turl,\n\t\t\t\ttoken,\n\t\t\t},\n\t\t\tctx.request,\n\t\t),\n\t);\n}\nexport const sendVerificationEmail = createAuthEndpoint(\n\t\"/send-verification-email\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"sendVerificationEmail\",\n\t\tbody: z.object({\n\t\t\temail: z.email().meta({\n\t\t\t\tdescription: \"The email to send the verification email to\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to use for email verification callback\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"sendVerificationEmail\",\n\t\t\t\tdescription: \"Send a verification email to the user\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The email to send the verification email to\",\n\t\t\t\t\t\t\t\t\t\texample: \"user@example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The URL to use for email verification callback\",\n\t\t\t\t\t\t\t\t\t\texample: \"https://example.com/callback\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"email\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the email was sent successfully\",\n\t\t\t\t\t\t\t\t\t\t\texample: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"400\": {\n\t\t\t\t\t\tdescription: \"Bad Request\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Error message\",\n\t\t\t\t\t\t\t\t\t\t\texample: \"Verification email isn't enabled\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t\t});\n\t\t}\n\t\tconst { email } = ctx.body;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session) {\n\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\tif (!user) {\n\t\t\t\tawait createEmailVerificationToken(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\temail,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\t//we're returning true to avoid leaking information about the user\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t});\n\t\t\t}\n\t\t\tawait sendVerificationEmailFn(ctx, user.user);\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\t\tif (session?.user.email !== email) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_MISMATCH,\n\t\t\t});\n\t\t}\n\t\tif (session?.user.emailVerified) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_ALREADY_VERIFIED,\n\t\t\t});\n\t\t}\n\t\tawait sendVerificationEmailFn(ctx, session.user);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const verifyEmail = createAuthEndpoint(\n\t\"/verify-email\",\n\t{\n\t\tmethod: \"GET\",\n\t\toperationId: \"verifyEmail\",\n\t\tquery: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to verify the email\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Verify the email of the user\",\n\t\t\t\tparameters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"token\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\tdescription: \"The token to verify the email\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"callbackURL\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the email was verified successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\", \"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tfunction redirectOnError(error: string) {\n\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\tif (ctx.query.callbackURL.includes(\"?\")) {\n\t\t\t\t\tthrow ctx.redirect(`${ctx.query.callbackURL}&error=${error}`);\n\t\t\t\t}\n\t\t\t\tthrow ctx.redirect(`${ctx.query.callbackURL}?error=${error}`);\n\t\t\t}\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: error,\n\t\t\t});\n\t\t}\n\t\tconst { token } = ctx.query;\n\t\tlet jwt: JWTVerifyResult<JWTPayload>;\n\t\ttry {\n\t\t\tjwt = await jwtVerify(\n\t\t\t\ttoken,\n\t\t\t\tnew TextEncoder().encode(ctx.context.secret),\n\t\t\t\t{\n\t\t\t\t\talgorithms: [\"HS256\"],\n\t\t\t\t},\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tif (e instanceof JWTExpired) {\n\t\t\t\treturn redirectOnError(\"token_expired\");\n\t\t\t}\n\t\t\treturn redirectOnError(\"invalid_token\");\n\t\t}\n\t\tconst schema = z.object({\n\t\t\temail: z.email(),\n\t\t\tupdateTo: z.string().optional(),\n\t\t\trequestType: z.string().optional(),\n\t\t});\n\t\tconst parsed = schema.parse(jwt.payload);\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(\n\t\t\tparsed.email,\n\t\t);\n\t\tif (!user) {\n\t\t\treturn redirectOnError(\"user_not_found\");\n\t\t}\n\t\tif (parsed.updateTo) {\n\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\tif (session && session.user.email !== parsed.email) {\n\t\t\t\treturn redirectOnError(\"unauthorized\");\n\t\t\t}\n\t\t\tswitch (parsed.requestType) {\n\t\t\t\t/**\n\t\t\t\t * User clicks confirmation -> sends verification to new email\n\t\t\t\t */\n\t\t\t\tcase \"change-email-confirmation\": {\n\t\t\t\t\tconst newToken = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tparsed.email,\n\t\t\t\t\t\tparsed.updateTo,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t\t{ requestType: \"change-email-verification\" },\n\t\t\t\t\t);\n\t\t\t\t\tconst updateCallbackURL = ctx.query.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.query.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`;\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: { ...user.user, email: parsed.updateTo },\n\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\ttoken: newToken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({ status: true });\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * User clicks verification -> updates email\n\t\t\t\t */\n\t\t\t\tcase \"change-email-verification\": {\n\t\t\t\t\tlet activeSession = session;\n\t\t\t\t\tif (!activeSession) {\n\t\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\t\t\tuser.user.id,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!newSession) {\n\t\t\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tactiveSession = {\n\t\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.context.options.emailVerification?.onEmailVerification) {\n\t\t\t\t\t\tawait ctx.context.options.emailVerification.onEmailVerification(\n\t\t\t\t\t\t\tuser.user,\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst updatedUser =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\t});\n\t\t\t\t\tif (ctx.context.options.emailVerification?.afterEmailVerification) {\n\t\t\t\t\t\tawait ctx.context.options.emailVerification.afterEmailVerification(\n\t\t\t\t\t\t\tupdatedUser,\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: activeSession.session,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t...activeSession.user,\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tuser: parseUserOutput(ctx.context.options, updatedUser),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * Legacy flow\n\t\t\t\t *\n\t\t\t\t * - skips two-step verification\n\t\t\t\t * - updates email immediately\n\t\t\t\t */\n\t\t\t\tdefault: {\n\t\t\t\t\tlet activeSession = session;\n\t\t\t\t\tif (!activeSession) {\n\t\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\t\t\tuser.user.id,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!newSession) {\n\t\t\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tactiveSession = {\n\t\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tconst updatedUser =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t});\n\t\t\t\t\tconst newToken = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tparsed.updateTo,\n\t\t\t\t\t);\n\t\t\t\t\tconst updateCallbackURL = ctx.query.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.query.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: updatedUser,\n\t\t\t\t\t\t\t\t\turl: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`,\n\t\t\t\t\t\t\t\t\ttoken: newToken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: activeSession.session,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t...activeSession.user,\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tuser: parseUserOutput(ctx.context.options, updatedUser),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (user.user.emailVerified) {\n\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t\tuser: null,\n\t\t\t});\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.beforeEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.beforeEmailVerification(\n\t\t\t\tuser.user,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.onEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.onEmailVerification(\n\t\t\t\tuser.user,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tconst updatedUser = await ctx.context.internalAdapter.updateUserByEmail(\n\t\t\tparsed.email,\n\t\t\t{\n\t\t\t\temailVerified: true,\n\t\t\t},\n\t\t);\n\t\tif (ctx.context.options.emailVerification?.afterEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.afterEmailVerification(\n\t\t\t\tupdatedUser,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.autoSignInAfterVerification) {\n\t\t\tconst currentSession = await getSessionFromCtx(ctx);\n\t\t\tif (!currentSession || currentSession.user.email !== parsed.email) {\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\tuser.user.id,\n\t\t\t\t);\n\t\t\t\tif (!session) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Failed to create session\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...user.user,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession: currentSession.session,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...currentSession.user,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.query.callbackURL) {\n\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tuser: null,\n\t\t});\n\t},\n);\n","import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport * as z from \"zod\";\nimport { expireCookie } from \"./cookies\";\nimport {\n\tgenerateRandomString,\n\tsymmetricDecrypt,\n\tsymmetricEncrypt,\n} from \"./crypto\";\n\nconst stateDataSchema = z.looseObject({\n\tcallbackURL: z.string(),\n\tcodeVerifier: z.string(),\n\terrorURL: z.string().optional(),\n\tnewUserURL: z.string().optional(),\n\texpiresAt: z.number(),\n\tlink: z\n\t\t.object({\n\t\t\temail: z.string(),\n\t\t\tuserId: z.coerce.string(),\n\t\t})\n\t\t.optional(),\n\trequestSignUp: z.boolean().optional(),\n});\n\nexport type StateData = z.infer<typeof stateDataSchema>;\n\nexport type StateErrorCode =\n\t| \"state_generation_error\"\n\t| \"state_invalid\"\n\t| \"state_mismatch\"\n\t| \"state_security_mismatch\";\n\nexport class StateError extends BetterAuthError {\n\tcode: string;\n\tdetails?: Record<string, any>;\n\n\tconstructor(\n\t\tmessage: string,\n\t\toptions: ErrorOptions & {\n\t\t\tcode: StateErrorCode;\n\t\t\tdetails?: Record<string, any>;\n\t\t},\n\t) {\n\t\tsuper(message, options);\n\t\tthis.code = options.code;\n\t\tthis.details = options.details;\n\t}\n}\n\nexport async function generateGenericState(\n\tc: GenericEndpointContext,\n\tstateData: StateData,\n\tsettings?: { cookieName: string },\n) {\n\tconst state = generateRandomString(32);\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Store state data in an encrypted cookie\n\n\t\tconst encryptedData = await symmetricEncrypt({\n\t\t\tkey: c.context.secret,\n\t\t\tdata: JSON.stringify(stateData),\n\t\t});\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t\t{\n\t\t\t\tmaxAge: 10 * 60, // 10 minutes\n\t\t\t},\n\t\t);\n\n\t\tc.setCookie(stateCookie.name, encryptedData, stateCookie.attributes);\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tcodeVerifier: stateData.codeVerifier,\n\t\t};\n\t}\n\n\t// Default: database strategy\n\n\tconst stateCookie = c.context.createAuthCookie(\n\t\tsettings?.cookieName ?? \"state\",\n\t\t{\n\t\t\tmaxAge: 5 * 60, // 5 minutes\n\t\t},\n\t);\n\n\tawait c.setSignedCookie(\n\t\tstateCookie.name,\n\t\tstate,\n\t\tc.context.secret,\n\t\tstateCookie.attributes,\n\t);\n\n\tconst expiresAt = new Date();\n\texpiresAt.setMinutes(expiresAt.getMinutes() + 10);\n\n\tconst verification = await c.context.internalAdapter.createVerificationValue({\n\t\tvalue: JSON.stringify(stateData),\n\t\tidentifier: state,\n\t\texpiresAt,\n\t});\n\n\tif (!verification) {\n\t\tthrow new StateError(\n\t\t\t\"Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database\",\n\t\t\t{\n\t\t\t\tcode: \"state_generation_error\",\n\t\t\t},\n\t\t);\n\t}\n\n\treturn {\n\t\tstate: verification.identifier,\n\t\tcodeVerifier: stateData.codeVerifier,\n\t};\n}\n\nexport async function parseGenericState(\n\tc: GenericEndpointContext,\n\tstate: string,\n\tsettings?: { cookieName: string },\n) {\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\tlet parsedData: StateData;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Retrieve state data from encrypted cookie\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t);\n\t\tconst encryptedData = c.getCookie(stateCookie.name);\n\n\t\tif (!encryptedData) {\n\t\t\tthrow new StateError(\"State mismatch: auth state cookie not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tconst decryptedData = await symmetricDecrypt({\n\t\t\t\tkey: c.context.secret,\n\t\t\t\tdata: encryptedData,\n\t\t\t});\n\n\t\t\tparsedData = stateDataSchema.parse(JSON.parse(decryptedData));\n\t\t} catch (error) {\n\t\t\tthrow new StateError(\n\t\t\t\t\"State invalid: Failed to decrypt or parse auth state\",\n\t\t\t\t{\n\t\t\t\t\tcode: \"state_invalid\",\n\t\t\t\t\tdetails: { state },\n\t\t\t\t\tcause: error,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\t// Clear the cookie after successful parsing\n\t\texpireCookie(c, stateCookie);\n\t} else {\n\t\t// Default: database strategy\n\t\tconst data = await c.context.internalAdapter.findVerificationValue(state);\n\t\tif (!data) {\n\t\t\tthrow new StateError(\"State mismatch: verification not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\tparsedData = stateDataSchema.parse(JSON.parse(data.value));\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"state\",\n\t\t);\n\n\t\tconst stateCookieValue = await c.getSignedCookie(\n\t\t\tstateCookie.name,\n\t\t\tc.context.secret,\n\t\t);\n\n\t\t/**\n\t\t * This is generally cause security issue and should only be used in\n\t\t * dev or staging environments. It's currently used by the oauth-proxy\n\t\t * plugin\n\t\t */\n\t\tconst skipStateCookieCheck = c.context.oauthConfig.skipStateCookieCheck;\n\t\tif (\n\t\t\t!skipStateCookieCheck &&\n\t\t\t(!stateCookieValue || stateCookieValue !== state)\n\t\t) {\n\t\t\tthrow new StateError(\"State mismatch: State not persisted correctly\", {\n\t\t\t\tcode: \"state_security_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\texpireCookie(c, stateCookie);\n\n\t\t// Delete verification value after retrieval\n\t\tawait c.context.internalAdapter.deleteVerificationValue(data.id);\n\t}\n\n\t// Check expiration\n\tif (parsedData.expiresAt < Date.now()) {\n\t\tthrow new StateError(\"Invalid state: request expired\", {\n\t\t\tcode: \"state_mismatch\",\n\t\t\tdetails: {\n\t\t\t\texpiresAt: parsedData.expiresAt,\n\t\t\t},\n\t\t});\n\t}\n\n\treturn parsedData;\n}\n","import type {\n\tAuthContext,\n\tAwaitable,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { logger } from \"@better-auth/core/env\";\nimport { normalizePathname } from \"@better-auth/core/utils\";\nimport type { Endpoint, Middleware } from \"better-call\";\nimport { APIError, createRouter } from \"better-call\";\nimport type { UnionToIntersection } from \"../types/helper\";\nimport { originCheckMiddleware } from \"./middlewares\";\nimport { onRequestRateLimit } from \"./rate-limiter\";\nimport {\n\taccountInfo,\n\tcallbackOAuth,\n\tchangeEmail,\n\tchangePassword,\n\tdeleteUser,\n\tdeleteUserCallback,\n\terror,\n\tgetAccessToken,\n\tgetSession,\n\tlinkSocialAccount,\n\tlistSessions,\n\tlistUserAccounts,\n\tok,\n\trefreshToken,\n\trequestPasswordReset,\n\trequestPasswordResetCallback,\n\tresetPassword,\n\trevokeOtherSessions,\n\trevokeSession,\n\trevokeSessions,\n\tsendVerificationEmail,\n\tsetPassword,\n\tsignInEmail,\n\tsignInSocial,\n\tsignOut,\n\tsignUpEmail,\n\tunlinkAccount,\n\tupdateUser,\n\tverifyEmail,\n\tverifyPassword,\n} from \"./routes\";\nimport { toAuthEndpoints } from \"./to-auth-endpoints\";\n\nexport function checkEndpointConflicts(\n\toptions: BetterAuthOptions,\n\tlogger: InternalLogger,\n) {\n\tconst endpointRegistry = new Map<\n\t\tstring,\n\t\t{ pluginId: string; endpointKey: string; methods: string[] }[]\n\t>();\n\n\toptions.plugins?.forEach((plugin) => {\n\t\tif (plugin.endpoints) {\n\t\t\tfor (const [key, endpoint] of Object.entries(plugin.endpoints)) {\n\t\t\t\tif (\n\t\t\t\t\tendpoint &&\n\t\t\t\t\t\"path\" in endpoint &&\n\t\t\t\t\ttypeof endpoint.path === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconst path = endpoint.path;\n\t\t\t\t\tlet methods: string[] = [];\n\t\t\t\t\tif (endpoint.options && \"method\" in endpoint.options) {\n\t\t\t\t\t\tif (Array.isArray(endpoint.options.method)) {\n\t\t\t\t\t\t\tmethods = endpoint.options.method;\n\t\t\t\t\t\t} else if (typeof endpoint.options.method === \"string\") {\n\t\t\t\t\t\t\tmethods = [endpoint.options.method];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (methods.length === 0) {\n\t\t\t\t\t\tmethods = [\"*\"];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!endpointRegistry.has(path)) {\n\t\t\t\t\t\tendpointRegistry.set(path, []);\n\t\t\t\t\t}\n\t\t\t\t\tendpointRegistry.get(path)!.push({\n\t\t\t\t\t\tpluginId: plugin.id,\n\t\t\t\t\t\tendpointKey: key,\n\t\t\t\t\t\tmethods,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tconst conflicts: {\n\t\tpath: string;\n\t\tplugins: string[];\n\t\tconflictingMethods: string[];\n\t}[] = [];\n\tfor (const [path, entries] of endpointRegistry.entries()) {\n\t\tif (entries.length > 1) {\n\t\t\tconst methodMap = new Map<string, string[]>();\n\t\t\tlet hasConflict = false;\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tfor (const method of entry.methods) {\n\t\t\t\t\tif (!methodMap.has(method)) {\n\t\t\t\t\t\tmethodMap.set(method, []);\n\t\t\t\t\t}\n\t\t\t\t\tmethodMap.get(method)!.push(entry.pluginId);\n\n\t\t\t\t\tif (methodMap.get(method)!.length > 1) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"*\" && entries.length > 1) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t} else if (method !== \"*\" && methodMap.has(\"*\")) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasConflict) {\n\t\t\t\tconst uniquePlugins = [...new Set(entries.map((e) => e.pluginId))];\n\t\t\t\tconst conflictingMethods: string[] = [];\n\n\t\t\t\tfor (const [method, plugins] of methodMap.entries()) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tplugins.length > 1 ||\n\t\t\t\t\t\t(method === \"*\" && entries.length > 1) ||\n\t\t\t\t\t\t(method !== \"*\" && methodMap.has(\"*\"))\n\t\t\t\t\t) {\n\t\t\t\t\t\tconflictingMethods.push(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconflicts.push({\n\t\t\t\t\tpath,\n\t\t\t\t\tplugins: uniquePlugins,\n\t\t\t\t\tconflictingMethods,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tif (conflicts.length > 0) {\n\t\tconst conflictMessages = conflicts\n\t\t\t.map(\n\t\t\t\t(conflict) =>\n\t\t\t\t\t`  - \"${conflict.path}\" [${conflict.conflictingMethods.join(\", \")}] used by plugins: ${conflict.plugins.join(\", \")}`,\n\t\t\t)\n\t\t\t.join(\"\\n\");\n\t\tlogger.error(\n\t\t\t`Endpoint path conflicts detected! Multiple plugins are trying to use the same endpoint paths with conflicting HTTP methods:\n${conflictMessages}\n\nTo resolve this, you can:\n\t1. Use only one of the conflicting plugins\n\t2. Configure the plugins to use different paths (if supported)\n\t3. Ensure plugins use different HTTP methods for the same path\n`,\n\t\t);\n\t}\n}\n\nexport function getEndpoints<Option extends BetterAuthOptions>(\n\tctx: Awaitable<AuthContext>,\n\toptions: Option,\n) {\n\tconst pluginEndpoints =\n\t\toptions.plugins?.reduce<Record<string, Endpoint>>((acc, plugin) => {\n\t\t\treturn {\n\t\t\t\t...acc,\n\t\t\t\t...plugin.endpoints,\n\t\t\t};\n\t\t}, {}) ?? {};\n\n\ttype PluginEndpoint = UnionToIntersection<\n\t\tOption[\"plugins\"] extends Array<infer T>\n\t\t\t? T extends BetterAuthPlugin\n\t\t\t\t? T extends {\n\t\t\t\t\t\tendpoints: infer E;\n\t\t\t\t\t}\n\t\t\t\t\t? E\n\t\t\t\t\t: {}\n\t\t\t\t: {}\n\t\t\t: {}\n\t>;\n\n\tconst middlewares =\n\t\toptions.plugins\n\t\t\t?.map((plugin) =>\n\t\t\t\tplugin.middlewares?.map((m) => {\n\t\t\t\t\tconst middleware = (async (context: any) => {\n\t\t\t\t\t\tconst authContext = await ctx;\n\t\t\t\t\t\treturn m.middleware({\n\t\t\t\t\t\t\t...context,\n\t\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\t\t...authContext,\n\t\t\t\t\t\t\t\t...context.context,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}) as Middleware;\n\t\t\t\t\tmiddleware.options = m.middleware.options;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpath: m.path,\n\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.filter((plugin) => plugin !== undefined)\n\t\t\t.flat() || [];\n\n\tconst baseEndpoints = {\n\t\tsignInSocial: signInSocial<Option>(),\n\t\tcallbackOAuth,\n\t\tgetSession: getSession<Option>(),\n\t\tsignOut,\n\t\tsignUpEmail: signUpEmail<Option>(),\n\t\tsignInEmail: signInEmail<Option>(),\n\t\tresetPassword,\n\t\tverifyPassword,\n\t\tverifyEmail,\n\t\tsendVerificationEmail,\n\t\tchangeEmail,\n\t\tchangePassword,\n\t\tsetPassword,\n\t\tupdateUser: updateUser<Option>(),\n\t\tdeleteUser,\n\t\trequestPasswordReset,\n\t\trequestPasswordResetCallback,\n\t\tlistSessions: listSessions<Option>(),\n\t\trevokeSession,\n\t\trevokeSessions,\n\t\trevokeOtherSessions,\n\t\tlinkSocialAccount,\n\t\tlistUserAccounts,\n\t\tdeleteUserCallback,\n\t\tunlinkAccount,\n\t\trefreshToken,\n\t\tgetAccessToken,\n\t\taccountInfo,\n\t};\n\tconst endpoints = {\n\t\t...baseEndpoints,\n\t\t...pluginEndpoints,\n\t\tok,\n\t\terror,\n\t} as const;\n\tconst api = toAuthEndpoints(endpoints, ctx);\n\treturn {\n\t\tapi: api as typeof endpoints & PluginEndpoint,\n\t\tmiddlewares,\n\t};\n}\nexport const router = <Option extends BetterAuthOptions>(\n\tctx: AuthContext,\n\toptions: Option,\n) => {\n\tconst { api, middlewares } = getEndpoints(ctx, options);\n\tconst basePath = new URL(ctx.baseURL).pathname;\n\n\treturn createRouter(api, {\n\t\trouterContext: ctx,\n\t\topenapi: {\n\t\t\tdisabled: true,\n\t\t},\n\t\tbasePath,\n\t\trouterMiddleware: [\n\t\t\t{\n\t\t\t\tpath: \"/**\",\n\t\t\t\tmiddleware: originCheckMiddleware,\n\t\t\t},\n\t\t\t...middlewares,\n\t\t],\n\t\tallowedMediaTypes: [\"application/json\"],\n\t\tskipTrailingSlashes: options.advanced?.skipTrailingSlashes ?? false,\n\t\tasync onRequest(req) {\n\t\t\t//handle disabled paths\n\t\t\tconst disabledPaths = ctx.options.disabledPaths || [];\n\t\t\tconst normalizedPath = normalizePathname(req.url, basePath);\n\t\t\tif (disabledPaths.includes(normalizedPath)) {\n\t\t\t\treturn new Response(\"Not Found\", { status: 404 });\n\t\t\t}\n\n\t\t\tlet currentRequest = req;\n\t\t\tfor (const plugin of ctx.options.plugins || []) {\n\t\t\t\tif (plugin.onRequest) {\n\t\t\t\t\tconst response = await plugin.onRequest(currentRequest, ctx);\n\t\t\t\t\tif (response && \"response\" in response) {\n\t\t\t\t\t\treturn response.response;\n\t\t\t\t\t}\n\t\t\t\t\tif (response && \"request\" in response) {\n\t\t\t\t\t\tcurrentRequest = response.request;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst rateLimitResponse = await onRequestRateLimit(currentRequest, ctx);\n\t\t\tif (rateLimitResponse) {\n\t\t\t\treturn rateLimitResponse;\n\t\t\t}\n\n\t\t\treturn currentRequest;\n\t\t},\n\t\tasync onResponse(res) {\n\t\t\tfor (const plugin of ctx.options.plugins || []) {\n\t\t\t\tif (plugin.onResponse) {\n\t\t\t\t\tconst response = await plugin.onResponse(res, ctx);\n\t\t\t\t\tif (response) {\n\t\t\t\t\t\treturn response.response;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\tonError(e) {\n\t\t\tif (e instanceof APIError && e.status === \"FOUND\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (options.onAPIError?.throw) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (options.onAPIError?.onError) {\n\t\t\t\toptions.onAPIError.onError(e, ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst optLogLevel = options.logger?.level;\n\t\t\tconst log =\n\t\t\t\toptLogLevel === \"error\" ||\n\t\t\t\toptLogLevel === \"warn\" ||\n\t\t\t\toptLogLevel === \"debug\"\n\t\t\t\t\t? logger\n\t\t\t\t\t: undefined;\n\t\t\tif (options.logger?.disabled !== true) {\n\t\t\t\tif (\n\t\t\t\t\te &&\n\t\t\t\t\ttypeof e === \"object\" &&\n\t\t\t\t\t\"message\" in e &&\n\t\t\t\t\ttypeof e.message === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\te.message.includes(\"no column\") ||\n\t\t\t\t\t\te.message.includes(\"column\") ||\n\t\t\t\t\t\te.message.includes(\"relation\") ||\n\t\t\t\t\t\te.message.includes(\"table\") ||\n\t\t\t\t\t\te.message.includes(\"does not exist\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tctx.logger?.error(e.message);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\tif (e.status === \"INTERNAL_SERVER_ERROR\") {\n\t\t\t\t\t\tctx.logger.error(e.status, e);\n\t\t\t\t\t}\n\t\t\t\t\tlog?.error(e.message);\n\t\t\t\t} else {\n\t\t\t\t\tctx.logger?.error(\n\t\t\t\t\t\te && typeof e === \"object\" && \"name\" in e ? (e.name as string) : \"\",\n\t\t\t\t\t\te,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n};\n\nexport {\n\ttype AuthEndpoint,\n\ttype AuthMiddleware,\n\tcreateAuthEndpoint,\n\tcreateAuthMiddleware,\n\toptionsMiddleware,\n} from \"@better-auth/core/api\";\nexport { APIError } from \"better-call\";\nexport { getIp } from \"../utils/get-request-ip\";\nexport * from \"./middlewares\";\nexport * from \"./routes\";\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface HuggingFaceProfile {\n\tsub: string;\n\tname: string;\n\tpreferred_username: string;\n\tprofile: string;\n\tpicture: string;\n\twebsite?: string | undefined;\n\temail?: string | undefined;\n\temail_verified?: boolean | undefined;\n\tisPro: boolean;\n\tcanPay?: boolean | undefined;\n\torgs?:\n\t\t| {\n\t\t\t\tsub: string;\n\t\t\t\tname: string;\n\t\t\t\tpicture: string;\n\t\t\t\tpreferred_username: string;\n\t\t\t\tisEnterprise: boolean | \"plus\";\n\t\t\t\tcanPay?: boolean;\n\t\t\t\troleInOrg?: \"admin\" | \"write\" | \"contributor\" | \"read\";\n\t\t\t\tpendingSSO?: boolean;\n\t\t\t\tmissingMFA?: boolean;\n\t\t\t\tresourceGroups?: {\n\t\t\t\t\tsub: string;\n\t\t\t\t\tname: string;\n\t\t\t\t\trole: \"admin\" | \"write\" | \"contributor\" | \"read\";\n\t\t\t\t}[];\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface HuggingFaceOptions\n\textends ProviderOptions<HuggingFaceProfile> {\n\tclientId: string;\n}\n\nexport const huggingface = (options: HuggingFaceOptions) => {\n\treturn {\n\t\tid: \"huggingface\",\n\t\tname: \"Hugging Face\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"huggingface\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://huggingface.co/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://huggingface.co/oauth/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://huggingface.co/oauth/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<HuggingFaceProfile>(\n\t\t\t\t\"https://huggingface.co/oauth/userinfo\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name || profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<HuggingFaceProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { BetterAuthError } from \"../error\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport { createAuthorizationURL, validateAuthorizationCode } from \"../oauth2\";\n\nexport interface VercelProfile {\n\tsub: string;\n\tname?: string;\n\tpreferred_username?: string;\n\temail?: string;\n\temail_verified?: boolean;\n\tpicture?: string;\n}\n\nexport interface VercelOptions extends ProviderOptions<VercelProfile> {\n\tclientId: string;\n}\n\nexport const vercel = (options: VercelOptions) => {\n\treturn {\n\t\tid: \"vercel\",\n\t\tname: \"Vercel\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tif (!codeVerifier) {\n\t\t\t\tthrow new BetterAuthError(\"codeVerifier is required for Vercel\");\n\t\t\t}\n\n\t\t\tlet _scopes: string[] | undefined = undefined;\n\t\t\tif (options.scope !== undefined || scopes !== undefined) {\n\t\t\t\t_scopes = [];\n\t\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\t}\n\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"vercel\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://vercel.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.vercel.com/login/oauth/token\",\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tconst { data: profile, error } = await betterFetch<VercelProfile>(\n\t\t\t\t\"https://api.vercel.com/login/oauth/userinfo\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error || !profile) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name ?? profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<VercelProfile>;\n};\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\tgetOAuth2Tokens,\n\trefreshAccessToken,\n} from \"../oauth2\";\n\nexport interface RedditProfile {\n\tid: string;\n\tname: string;\n\ticon_img: string | null;\n\thas_verified_email: boolean;\n\toauth_client_id: string;\n\tverified: boolean;\n}\n\nexport interface RedditOptions extends ProviderOptions<RedditProfile> {\n\tclientId: string;\n\tduration?: string | undefined;\n}\n\nexport const reddit = (options: RedditOptions) => {\n\treturn {\n\t\tid: \"reddit\",\n\t\tname: \"Reddit\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"identity\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"reddit\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.reddit.com/api/v1/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tduration: options.duration,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\tconst body = new URLSearchParams({\n\t\t\t\tgrant_type: \"authorization_code\",\n\t\t\t\tcode,\n\t\t\t\tredirect_uri: options.redirectURI || redirectURI,\n\t\t\t});\n\t\t\tconst headers = {\n\t\t\t\t\"content-type\": \"application/x-www-form-urlencoded\",\n\t\t\t\taccept: \"text/plain\",\n\t\t\t\t\"user-agent\": \"better-auth\",\n\t\t\t\tAuthorization: `Basic ${base64.encode(\n\t\t\t\t\t`${options.clientId}:${options.clientSecret}`,\n\t\t\t\t)}`,\n\t\t\t};\n\n\t\t\tconst { data, error } = await betterFetch<object>(\n\t\t\t\t\"https://www.reddit.com/api/v1/access_token\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders,\n\t\t\t\t\tbody: body.toString(),\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn getOAuth2Tokens(data);\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tauthentication: \"basic\",\n\t\t\t\t\t\ttokenEndpoint: \"https://www.reddit.com/api/v1/access_token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tconst { data: profile, error } = await betterFetch<RedditProfile>(\n\t\t\t\t\"https://oauth.reddit.com/api/v1/me\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t\"User-Agent\": \"better-auth\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.oauth_client_id,\n\t\t\t\t\temailVerified: profile.has_verified_email,\n\t\t\t\t\timage: profile.icon_img?.split(\"?\")[0]!,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<RedditProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface NaverProfile {\n\t/** API response result code */\n\tresultcode: string;\n\t/** API response message */\n\tmessage: string;\n\tresponse: {\n\t\t/** Unique Naver user identifier */\n\t\tid: string;\n\t\t/** User nickname */\n\t\tnickname: string;\n\t\t/** User real name */\n\t\tname: string;\n\t\t/** User email address */\n\t\temail: string;\n\t\t/** Gender (F: female, M: male, U: unknown) */\n\t\tgender: string;\n\t\t/** Age range */\n\t\tage: string;\n\t\t/** Birthday (MM-DD format) */\n\t\tbirthday: string;\n\t\t/** Birth year */\n\t\tbirthyear: string;\n\t\t/** Profile image URL */\n\t\tprofile_image: string;\n\t\t/** Mobile phone number */\n\t\tmobile: string;\n\t};\n}\n\nexport interface NaverOptions extends ProviderOptions<NaverProfile> {\n\tclientId: string;\n}\n\nexport const naver = (options: NaverOptions) => {\n\treturn {\n\t\tid: \"naver\",\n\t\tname: \"Naver\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"naver\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://nid.naver.com/oauth2.0/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://nid.naver.com/oauth2.0/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://nid.naver.com/oauth2.0/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<NaverProfile>(\n\t\t\t\t\"https://openapi.naver.com/v1/nid/me\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error || !profile || profile.resultcode !== \"00\") {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\tconst res = profile.response || {};\n\t\t\tconst user = {\n\t\t\t\tid: res.id,\n\t\t\t\tname: res.name || res.nickname,\n\t\t\t\temail: res.email,\n\t\t\t\timage: res.profile_image,\n\t\t\t\temailVerified: false,\n\t\t\t\t...userMap,\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<NaverProfile>;\n};\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute, DBFieldType } from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport {\n\tinitGetFieldName,\n\tinitGetModelName,\n} from \"@better-auth/core/db/adapter\";\nimport { createLogger } from \"@better-auth/core/env\";\nimport type {\n\tAlterTableBuilder,\n\tAlterTableColumnAlteringBuilder,\n\tColumnDataType,\n\tCreateIndexBuilder,\n\tCreateTableBuilder,\n\tKysely,\n\tRawBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport { createKyselyAdapter } from \"../adapters/kysely-adapter/dialect\";\nimport type { KyselyDatabaseType } from \"../adapters/kysely-adapter/types\";\nimport { getSchema } from \"./get-schema\";\n\nconst postgresMap = {\n\tstring: [\"character varying\", \"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"int4\",\n\t\t\"integer\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"numeric\",\n\t\t\"real\",\n\t\t\"double precision\",\n\t],\n\tboolean: [\"bool\", \"boolean\"],\n\tdate: [\"timestamptz\", \"timestamp\", \"date\"],\n\tjson: [\"json\", \"jsonb\"],\n};\nconst mysqlMap = {\n\tstring: [\"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"integer\",\n\t\t\"int\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"decimal\",\n\t\t\"float\",\n\t\t\"double\",\n\t],\n\tboolean: [\"boolean\", \"tinyint\"],\n\tdate: [\"timestamp\", \"datetime\", \"date\"],\n\tjson: [\"json\"],\n};\n\nconst sqliteMap = {\n\tstring: [\"TEXT\"],\n\tnumber: [\"INTEGER\", \"REAL\"],\n\tboolean: [\"INTEGER\", \"BOOLEAN\"], // 0 or 1\n\tdate: [\"DATE\", \"INTEGER\"],\n\tjson: [\"TEXT\"],\n};\n\nconst mssqlMap = {\n\tstring: [\"varchar\", \"nvarchar\", \"uniqueidentifier\"],\n\tnumber: [\"int\", \"bigint\", \"smallint\", \"decimal\", \"float\", \"double\"],\n\tboolean: [\"bit\", \"smallint\"],\n\tdate: [\"datetime2\", \"date\", \"datetime\"],\n\tjson: [\"varchar\", \"nvarchar\"],\n};\n\nconst map = {\n\tpostgres: postgresMap,\n\tmysql: mysqlMap,\n\tsqlite: sqliteMap,\n\tmssql: mssqlMap,\n};\n\nexport function matchType(\n\tcolumnDataType: string,\n\tfieldType: DBFieldType,\n\tdbType: KyselyDatabaseType,\n) {\n\tfunction normalize(type: string) {\n\t\treturn type.toLowerCase().split(\"(\")[0]!.trim();\n\t}\n\tif (fieldType === \"string[]\" || fieldType === \"number[]\") {\n\t\treturn columnDataType.toLowerCase().includes(\"json\");\n\t}\n\tconst types = map[dbType]!;\n\tconst expected = Array.isArray(fieldType)\n\t\t? types[\"string\"].map((t) => t.toLowerCase())\n\t\t: types[fieldType]!.map((t) => t.toLowerCase());\n\treturn expected.includes(normalize(columnDataType));\n}\n\n/**\n * Get the current PostgreSQL schema (search_path) for the database connection\n * Returns the first schema in the search_path, defaulting to 'public' if not found\n */\nasync function getPostgresSchema(db: Kysely<unknown>): Promise<string> {\n\ttry {\n\t\tconst result = await sql<{ search_path: string }>`SHOW search_path`.execute(\n\t\t\tdb,\n\t\t);\n\t\tif (result.rows[0]?.search_path) {\n\t\t\t// search_path can be a comma-separated list like \"$user, public\" or '\"$user\", public'\n\t\t\t// We want the first non-variable schema\n\t\t\tconst schemas = result.rows[0].search_path\n\t\t\t\t.split(\",\")\n\t\t\t\t.map((s) => s.trim())\n\t\t\t\t// Remove quotes and filter out variables like $user\n\t\t\t\t.map((s) => s.replace(/^[\"']|[\"']$/g, \"\"))\n\t\t\t\t.filter((s) => !s.startsWith(\"$\"));\n\t\t\treturn schemas[0] || \"public\";\n\t\t}\n\t} catch {\n\t\t// If query fails, fall back to public schema\n\t}\n\treturn \"public\";\n}\n\nexport async function getMigrations(config: BetterAuthOptions) {\n\tconst betterAuthSchema = getSchema(config);\n\tconst logger = createLogger(config.logger);\n\n\tlet { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);\n\n\tif (!dbType) {\n\t\tlogger.warn(\n\t\t\t\"Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.\",\n\t\t);\n\t\tdbType = \"sqlite\";\n\t}\n\n\tif (!db) {\n\t\tlogger.error(\n\t\t\t\"Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n\n\t// For PostgreSQL, detect and log the current schema being used\n\tlet currentSchema = \"public\";\n\tif (dbType === \"postgres\") {\n\t\tcurrentSchema = await getPostgresSchema(db);\n\t\tlogger.debug(\n\t\t\t`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`,\n\t\t);\n\n\t\t// Verify the schema exists\n\t\ttry {\n\t\t\tconst schemaCheck = await sql<{ schema_name: string }>`\n\t\t\t\tSELECT schema_name \n\t\t\t\tFROM information_schema.schemata \n\t\t\t\tWHERE schema_name = ${currentSchema}\n\t\t\t`.execute(db);\n\n\t\t\tif (!schemaCheck.rows[0]) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.debug(\n\t\t\t\t`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst allTableMetadata = await db.introspection.getTables();\n\n\t// For PostgreSQL, filter tables to only those in the target schema\n\tlet tableMetadata = allTableMetadata;\n\tif (dbType === \"postgres\") {\n\t\t// Get tables with their schema information\n\t\ttry {\n\t\t\tconst tablesInSchema = await sql<{\n\t\t\t\ttable_name: string;\n\t\t\t}>`\n\t\t\t\tSELECT table_name \n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = ${currentSchema}\n\t\t\t\tAND table_type = 'BASE TABLE'\n\t\t\t`.execute(db);\n\n\t\t\tconst tableNamesInSchema = new Set(\n\t\t\t\ttablesInSchema.rows.map((row) => row.table_name),\n\t\t\t);\n\n\t\t\t// Filter to only tables that exist in the target schema\n\t\t\ttableMetadata = allTableMetadata.filter(\n\t\t\t\t(table) =>\n\t\t\t\t\ttable.schema === currentSchema && tableNamesInSchema.has(table.name),\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(\", \") || \"(none)\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.warn(\n\t\t\t\t`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t\t// Fall back to using all tables if schema filtering fails\n\t\t}\n\t}\n\tconst toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\tconst toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\n\tfor (const [key, value] of Object.entries(betterAuthSchema)) {\n\t\tconst table = tableMetadata.find((t) => t.name === key);\n\t\tif (!table) {\n\t\t\tconst tIndex = toBeCreated.findIndex((t) => t.table === key);\n\t\t\tconst tableData = {\n\t\t\t\ttable: key,\n\t\t\t\tfields: value.fields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t};\n\n\t\t\tconst insertIndex = toBeCreated.findIndex(\n\t\t\t\t(t) => (t.order || Infinity) > tableData.order,\n\t\t\t);\n\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tif (tIndex === -1) {\n\t\t\t\t\ttoBeCreated.push(tableData);\n\t\t\t\t} else {\n\t\t\t\t\ttoBeCreated[tIndex]!.fields = {\n\t\t\t\t\t\t...toBeCreated[tIndex]!.fields,\n\t\t\t\t\t\t...value.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoBeCreated.splice(insertIndex, 0, tableData);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tconst toBeAddedFields: Record<string, DBFieldAttribute> = {};\n\t\tfor (const [fieldName, field] of Object.entries(value.fields)) {\n\t\t\tconst column = table.columns.find((c) => c.name === fieldName);\n\t\t\tif (!column) {\n\t\t\t\ttoBeAddedFields[fieldName] = field;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (matchType(column.dataType, field.type, dbType)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(toBeAddedFields).length > 0) {\n\t\t\ttoBeAdded.push({\n\t\t\t\ttable: key,\n\t\t\t\tfields: toBeAddedFields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t});\n\t\t}\n\t}\n\n\tconst migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[] = [];\n\n\tconst useUUIDs = config.advanced?.database?.generateId === \"uuid\";\n\tconst useNumberId =\n\t\tconfig.advanced?.database?.useNumberId ||\n\t\tconfig.advanced?.database?.generateId === \"serial\";\n\n\tfunction getType(field: DBFieldAttribute, fieldName: string) {\n\t\tconst type = field.type;\n\t\tconst provider = dbType || \"sqlite\";\n\t\ttype StringOnlyUnion<T> = T extends string ? T : never;\n\t\tconst typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t> = {\n\t\t\tstring: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"text\",\n\t\t\t\tmysql: field.unique\n\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t: field.references\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: field.sortable\n\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t: field.index\n\t\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t\t: \"text\",\n\t\t\t\tmssql:\n\t\t\t\t\tfield.unique || field.sortable\n\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t: field.references\n\t\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t\t: // mssql deprecated `text`, and the alternative is `varchar(max)`.\n\t\t\t\t\t\t\t\t// Kysely type interface doesn't support `text`, so we set this to `varchar(8000)` as\n\t\t\t\t\t\t\t\t// that's the max length for `varchar`\n\t\t\t\t\t\t\t\t\"varchar(8000)\",\n\t\t\t},\n\t\t\tboolean: {\n\t\t\t\tsqlite: \"integer\",\n\t\t\t\tpostgres: \"boolean\",\n\t\t\t\tmysql: \"boolean\",\n\t\t\t\tmssql: \"smallint\",\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tsqlite: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tpostgres: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmysql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmssql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t},\n\t\t\tdate: {\n\t\t\t\tsqlite: \"date\",\n\t\t\t\tpostgres: \"timestamptz\",\n\t\t\t\tmysql: \"timestamp(3)\",\n\t\t\t\tmssql: sql`datetime2(3)`,\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\tid: {\n\t\t\t\tpostgres: useNumberId\n\t\t\t\t\t? sql`integer GENERATED BY DEFAULT AS IDENTITY`\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"uuid\"\n\t\t\t\t\t\t: \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\tforeignKeyId: {\n\t\t\t\tpostgres: useNumberId ? \"integer\" : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\" /* Should be using `UNIQUEIDENTIFIER` but Kysely doesn't support it */\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\t\"string[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\t\"number[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t} as const;\n\t\tif (fieldName === \"id\" || field.references?.field === \"id\") {\n\t\t\tif (fieldName === \"id\") {\n\t\t\t\treturn typeMap.id[provider];\n\t\t\t}\n\t\t\treturn typeMap.foreignKeyId[provider];\n\t\t}\n\t\tif (Array.isArray(type)) {\n\t\t\treturn \"text\";\n\t\t}\n\t\tif (!(type in typeMap)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported field type '${String(type)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: \"string\") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`,\n\t\t\t);\n\t\t}\n\t\treturn typeMap[type][provider];\n\t}\n\tconst getModelName = initGetModelName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\tconst getFieldName = initGetFieldName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\n\t// Helper function to safely resolve model and field names, falling back to\n\t// user-supplied strings for external tables not in the BetterAuth schema\n\tfunction getReferencePath(model: string, field: string): string {\n\t\ttry {\n\t\t\tconst modelName = getModelName(model);\n\t\t\tconst fieldName = getFieldName({ model, field });\n\t\t\treturn `${modelName}.${fieldName}`;\n\t\t} catch {\n\t\t\t// If resolution fails (external table), fall back to user-supplied references\n\t\t\treturn `${model}.${field}`;\n\t\t}\n\t}\n\n\tif (toBeAdded.length) {\n\t\tfor (const table of toBeAdded) {\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tconst builder = db.schema.alterTable(table.table);\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst index = db.schema\n\t\t\t\t\t\t.alterTable(table.table)\n\t\t\t\t\t\t.addIndex(`${table.table}_${fieldName}_idx`);\n\t\t\t\t\tmigrations.push(index);\n\t\t\t\t}\n\n\t\t\t\tconst built = builder.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\t\t\t\tmigrations.push(built);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst toBeIndexed: CreateIndexBuilder[] = [];\n\n\tif (config.advanced?.database?.useNumberId) {\n\t\tlogger.warn(\n\t\t\t\"`useNumberId` is deprecated. Please use `generateId` with `serial` instead.\",\n\t\t);\n\t}\n\n\tif (toBeCreated.length) {\n\t\tfor (const table of toBeCreated) {\n\t\t\tconst idType = getType({ type: useNumberId ? \"number\" : \"string\" }, \"id\");\n\t\t\tlet dbT = db.schema\n\t\t\t\t.createTable(table.table)\n\t\t\t\t.addColumn(\"id\", idType, (col) => {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\t// Identity column is already specified in the type via sql template tag\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"sqlite\") {\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"mssql\") {\n\t\t\t\t\t\t\treturn col.identity().primaryKey().notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.autoIncrement().primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\tif (useUUIDs) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\treturn col\n\t\t\t\t\t\t\t\t.primaryKey()\n\t\t\t\t\t\t\t\t.defaultTo(sql`pg_catalog.gen_random_uuid()`)\n\t\t\t\t\t\t\t\t.notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t});\n\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tdbT = dbT.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst builder = db.schema\n\t\t\t\t\t\t.createIndex(\n\t\t\t\t\t\t\t`${table.table}_${fieldName}_${field.unique ? \"uidx\" : \"idx\"}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.on(table.table)\n\t\t\t\t\t\t.columns([fieldName]);\n\t\t\t\t\ttoBeIndexed.push(field.unique ? builder.unique() : builder);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmigrations.push(dbT);\n\t\t}\n\t}\n\n\t// instead of adding the index straight to `migrations`,\n\t// we do this at the end so that indexes are created after the table is created\n\tif (toBeIndexed.length) {\n\t\tfor (const index of toBeIndexed) {\n\t\t\tmigrations.push(index);\n\t\t}\n\t}\n\n\tasync function runMigrations() {\n\t\tfor (const migration of migrations) {\n\t\t\tawait migration.execute();\n\t\t}\n\t}\n\tasync function compileMigrations() {\n\t\tconst compiled = migrations.map((m) => m.compile().sql);\n\t\treturn compiled.join(\";\\n\\n\") + \";\";\n\t}\n\treturn { toBeCreated, toBeAdded, runMigrations, compileMigrations };\n}\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface SpotifyProfile {\n\tid: string;\n\tdisplay_name: string;\n\temail: string;\n\timages: {\n\t\turl: string;\n\t}[];\n}\n\nexport interface SpotifyOptions extends ProviderOptions<SpotifyProfile> {\n\tclientId: string;\n}\n\nexport const spotify = (options: SpotifyOptions) => {\n\treturn {\n\t\tid: \"spotify\",\n\t\tname: \"Spotify\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user-read-email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"spotify\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://accounts.spotify.com/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://accounts.spotify.com/api/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://accounts.spotify.com/api/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<SpotifyProfile>(\n\t\t\t\t\"https://api.spotify.com/v1/me\",\n\t\t\t\t{\n\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.display_name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.images[0]?.url,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<SpotifyProfile>;\n};\n","import type { AsyncLocalStorage } from \"node:async_hooks\";\nimport { getAsyncLocalStorage } from \"@better-auth/core/async_hooks\";\nimport type { DBAdapter, DBTransactionAdapter } from \"../db/adapter\";\nimport { __getBetterAuthGlobal } from \"./global\";\n\nconst ensureAsyncStorage = async () => {\n\tconst betterAuthGlobal = __getBetterAuthGlobal();\n\tif (!betterAuthGlobal.context.adapterAsyncStorage) {\n\t\tconst AsyncLocalStorage = await getAsyncLocalStorage();\n\t\tbetterAuthGlobal.context.adapterAsyncStorage = new AsyncLocalStorage();\n\t}\n\treturn betterAuthGlobal.context\n\t\t.adapterAsyncStorage as AsyncLocalStorage<DBTransactionAdapter>;\n};\n\n/**\n * This is for internal use only. Most users should use `getCurrentAdapter` instead.\n *\n * It is exposed for advanced use cases where you need direct access to the AsyncLocalStorage instance.\n */\nexport const getCurrentDBAdapterAsyncLocalStorage = async () => {\n\treturn ensureAsyncStorage();\n};\n\nexport const getCurrentAdapter = async (\n\tfallback: DBTransactionAdapter,\n): Promise<DBTransactionAdapter> => {\n\treturn ensureAsyncStorage()\n\t\t.then((als) => {\n\t\t\treturn als.getStore() || fallback;\n\t\t})\n\t\t.catch(() => {\n\t\t\treturn fallback;\n\t\t});\n};\n\nexport const runWithAdapter = async <R>(\n\tadapter: DBAdapter,\n\tfn: () => R,\n): Promise<R> => {\n\tlet called = true;\n\treturn ensureAsyncStorage()\n\t\t.then((als) => {\n\t\t\tcalled = true;\n\t\t\treturn als.run(adapter, fn);\n\t\t})\n\t\t.catch((err) => {\n\t\t\tif (!called) {\n\t\t\t\treturn fn();\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n};\n\nexport const runWithTransaction = async <R>(\n\tadapter: DBAdapter,\n\tfn: () => R,\n): Promise<R> => {\n\tlet called = true;\n\treturn ensureAsyncStorage()\n\t\t.then((als) => {\n\t\t\tcalled = true;\n\t\t\treturn adapter.transaction(async (trx) => {\n\t\t\t\treturn als.run(trx, fn);\n\t\t\t});\n\t\t})\n\t\t.catch((err) => {\n\t\t\tif (!called) {\n\t\t\t\treturn fn();\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport { createRemoteJWKSet, decodeJwt, jwtVerify } from \"jose\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\nexport interface FacebookProfile {\n\tid: string;\n\tname: string;\n\temail: string;\n\temail_verified: boolean;\n\tpicture: {\n\t\tdata: {\n\t\t\theight: number;\n\t\t\tis_silhouette: boolean;\n\t\t\turl: string;\n\t\t\twidth: number;\n\t\t};\n\t};\n}\n\nexport interface FacebookOptions extends ProviderOptions<FacebookProfile> {\n\tclientId: string;\n\t/**\n\t * Extend list of fields to retrieve from the Facebook user profile.\n\t *\n\t * @default [\"id\", \"name\", \"email\", \"picture\"]\n\t */\n\tfields?: string[] | undefined;\n\n\t/**\n\t * The config id to use when undergoing oauth\n\t */\n\tconfigId?: string | undefined;\n}\n\nexport const facebook = (options: FacebookOptions) => {\n\treturn {\n\t\tid: \"facebook\",\n\t\tname: \"Facebook\",\n\t\tasync createAuthorizationURL({ state, scopes, redirectURI, loginHint }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"email\", \"public_profile\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn await createAuthorizationURL({\n\t\t\t\tid: \"facebook\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://www.facebook.com/v24.0/dialog/oauth\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tredirectURI,\n\t\t\t\tloginHint,\n\t\t\t\tadditionalParams: options.configId\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tconfig_id: options.configId,\n\t\t\t\t\t\t}\n\t\t\t\t\t: {},\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://graph.facebook.com/v24.0/oauth/access_token\",\n\t\t\t});\n\t\t},\n\t\tasync verifyIdToken(token, nonce) {\n\t\t\tif (options.disableIdTokenSignIn) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (options.verifyIdToken) {\n\t\t\t\treturn options.verifyIdToken(token, nonce);\n\t\t\t}\n\n\t\t\t/* limited login */\n\t\t\t// check is limited token\n\t\t\tif (token.split(\".\").length === 3) {\n\t\t\t\ttry {\n\t\t\t\t\tconst { payload: jwtClaims } = await jwtVerify(\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t\tcreateRemoteJWKSet(\n\t\t\t\t\t\t\t// https://developers.facebook.com/docs/facebook-login/limited-login/token/#jwks\n\t\t\t\t\t\t\tnew URL(\n\t\t\t\t\t\t\t\t\"https://limited.facebook.com/.well-known/oauth/openid/jwks/\",\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\talgorithms: [\"RS256\"],\n\t\t\t\t\t\t\taudience: options.clientId,\n\t\t\t\t\t\t\tissuer: \"https://www.facebook.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\tif (nonce && jwtClaims.nonce !== nonce) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn !!jwtClaims;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* access_token */\n\t\t\treturn true;\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint:\n\t\t\t\t\t\t\t\"https://graph.facebook.com/v24.0/oauth/access_token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tif (token.idToken && token.idToken.split(\".\").length === 3) {\n\t\t\t\tconst profile = decodeJwt(token.idToken) as {\n\t\t\t\t\tsub: string;\n\t\t\t\t\temail: string;\n\t\t\t\t\tname: string;\n\t\t\t\t\tpicture: string;\n\t\t\t\t};\n\n\t\t\t\tconst user = {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\tpicture: {\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\turl: profile.picture,\n\t\t\t\t\t\t\theight: 100,\n\t\t\t\t\t\t\twidth: 100,\n\t\t\t\t\t\t\tis_silhouette: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\t// https://developers.facebook.com/docs/facebook-login/limited-login/permissions\n\t\t\t\t// Facebook ID token does not include email_verified claim.\n\t\t\t\t// We default to false for security consistency.\n\t\t\t\tconst userMap = await options.mapProfileToUser?.({\n\t\t\t\t\t...user,\n\t\t\t\t\temail_verified: false,\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...user,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t...userMap,\n\t\t\t\t\t},\n\t\t\t\t\tdata: profile,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst fields = [\n\t\t\t\t\"id\",\n\t\t\t\t\"name\",\n\t\t\t\t\"email\",\n\t\t\t\t\"picture\",\n\t\t\t\t...(options?.fields || []),\n\t\t\t];\n\t\t\tconst { data: profile, error } = await betterFetch<FacebookProfile>(\n\t\t\t\t\"https://graph.facebook.com/me?fields=\" + fields.join(\",\"),\n\t\t\t\t{\n\t\t\t\t\tauth: {\n\t\t\t\t\t\ttype: \"Bearer\",\n\t\t\t\t\t\ttoken: token.accessToken,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture.data.url,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<FacebookProfile>;\n};\n","/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | cnt(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\nimport {\n  type PRG,\n  type XorStream,\n  abool,\n  abytes,\n  anumber,\n  checkOpts,\n  clean,\n  copyBytes,\n  randomBytes,\n  u32,\n} from './utils.ts';\n\n// Replaces `TextEncoder`, which is not available in all environments\nconst encodeStr = (str: string) => Uint8Array.from(str.split(''), (c) => c.charCodeAt(0));\nconst sigma16 = encodeStr('expand 16-byte k');\nconst sigma32 = encodeStr('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\n/** Rotate left. */\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\n/** Ciphers must use u32 for efficiency. */\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\n/** Method which extends key + short nonce into larger nonce / diff key. */\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\n/** ARX cipher options.\n * * `allowShortKeys` for 16-byte keys\n * * `counterLength` in bytes\n * * `counterRight`: right: `nonce|counter`; left: `counter|nonce`\n * */\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean;\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = Uint32Array.of();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key, undefined, 'key');\n    abytes(nonce, undefined, 'nonce');\n    abytes(data, undefined, 'data');\n    const len = data.length;\n    if (output === undefined) output = new Uint8Array(len);\n    abytes(output, undefined, 'output');\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length;\n    let k: Uint8Array;\n    let sigma: Uint32Array;\n    if (l === 32) {\n      toClean.push((k = copyBytes(key)));\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      abytes(key, 32, 'arx key');\n      throw new Error('invalid key size');\n      // throw new Error(`\"arx key\" expected Uint8Array of length 32, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) toClean.push((nonce = copyBytes(nonce)));\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    clean(...toClean);\n    return output;\n  };\n}\n\n/** Internal class which wraps chacha20 or chacha8 to create CSPRNG. */\nexport class _XorStreamPRG implements PRG {\n  readonly blockLen: number;\n  readonly keyLen: number;\n  readonly nonceLen: number;\n  private state: Uint8Array;\n  private buf: Uint8Array;\n  private key: Uint8Array;\n  private nonce: Uint8Array;\n  private pos: number;\n  private ctr: number;\n  private cipher: XorStream;\n  constructor(\n    cipher: XorStream,\n    blockLen: number,\n    keyLen: number,\n    nonceLen: number,\n    seed: Uint8Array\n  ) {\n    this.cipher = cipher;\n    this.blockLen = blockLen;\n    this.keyLen = keyLen;\n    this.nonceLen = nonceLen;\n    this.state = new Uint8Array(this.keyLen + this.nonceLen);\n    this.reseed(seed);\n    this.ctr = 0;\n    this.pos = this.blockLen;\n    this.buf = new Uint8Array(this.blockLen);\n    this.key = this.state.subarray(0, this.keyLen);\n    this.nonce = this.state.subarray(this.keyLen);\n  }\n  private reseed(seed: Uint8Array) {\n    abytes(seed);\n    if (!seed || seed.length === 0) throw new Error('entropy required');\n    for (let i = 0; i < seed.length; i++) this.state[i % this.state.length] ^= seed[i];\n    this.ctr = 0;\n    this.pos = this.blockLen;\n  }\n  addEntropy(seed: Uint8Array): void {\n    this.state.set(this.randomBytes(this.state.length));\n    this.reseed(seed);\n  }\n  randomBytes(len: number): Uint8Array {\n    anumber(len);\n    if (len === 0) return new Uint8Array(0);\n    const out = new Uint8Array(len);\n    let outPos = 0;\n    // Leftovers\n    if (this.pos < this.blockLen) {\n      const take = Math.min(len, this.blockLen - this.pos);\n      out.set(this.buf.subarray(this.pos, this.pos + take), 0);\n      this.pos += take;\n      outPos += take;\n      if (outPos === len) return out; // fast path\n    }\n    // Full blocks directly to out\n    const blocks = Math.floor((len - outPos) / this.blockLen);\n    if (blocks > 0) {\n      const blockBytes = blocks * this.blockLen;\n      const b = out.subarray(outPos, outPos + blockBytes);\n      this.cipher(this.key, this.nonce, b, b, this.ctr);\n      this.ctr += blocks;\n      outPos += blockBytes;\n    }\n    // Save leftovers\n    const left = len - outPos;\n    if (left > 0) {\n      this.buf.fill(0);\n      // NOTE: cipher will handle overflow\n      this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);\n      out.set(this.buf.subarray(0, left), outPos);\n      this.pos = left;\n    }\n    return out;\n  }\n  clone(): _XorStreamPRG {\n    return new _XorStreamPRG(\n      this.cipher,\n      this.blockLen,\n      this.keyLen,\n      this.nonceLen,\n      this.randomBytes(this.state.length)\n    );\n  }\n  clean(): void {\n    this.pos = 0;\n    this.ctr = 0;\n    this.buf.fill(0);\n    this.state.fill(0);\n  }\n}\n\nexport type XorPRG = (seed?: Uint8Array) => _XorStreamPRG;\n\nexport const createPRG = (\n  cipher: XorStream,\n  blockLen: number,\n  keyLen: number,\n  nonceLen: number\n): XorPRG => {\n  return (seed: Uint8Array = randomBytes(32)): _XorStreamPRG =>\n    new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface PolarProfile {\n\tid: string;\n\temail: string;\n\tusername: string;\n\tavatar_url: string;\n\tgithub_username?: string | undefined;\n\taccount_id?: string | undefined;\n\tpublic_name?: string | undefined;\n\temail_verified?: boolean | undefined;\n\tprofile_settings?:\n\t\t| {\n\t\t\t\tprofile_settings_enabled?: boolean;\n\t\t\t\tprofile_settings_public_name?: string;\n\t\t\t\tprofile_settings_public_avatar?: string;\n\t\t\t\tprofile_settings_public_bio?: string;\n\t\t\t\tprofile_settings_public_location?: string;\n\t\t\t\tprofile_settings_public_website?: string;\n\t\t\t\tprofile_settings_public_twitter?: string;\n\t\t\t\tprofile_settings_public_github?: string;\n\t\t\t\tprofile_settings_public_email?: string;\n\t\t  }\n\t\t| undefined;\n}\n\nexport interface PolarOptions extends ProviderOptions<PolarProfile> {}\n\nexport const polar = (options: PolarOptions) => {\n\treturn {\n\t\tid: \"polar\",\n\t\tname: \"Polar\",\n\t\tcreateAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"polar\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://polar.sh/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.polar.sh/v1/oauth2/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://api.polar.sh/v1/oauth2/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<PolarProfile>(\n\t\t\t\t\"https://api.polar.sh/v1/oauth2/userinfo\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t// Polar may provide email_verified claim, but it's not guaranteed.\n\t\t\t// We check for it first, then default to false for security consistency.\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.public_name || profile.username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.avatar_url,\n\t\t\t\t\temailVerified: profile.email_verified ?? false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<PolarProfile>;\n};\n","import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { getBetterAuthVersion } from \"@better-auth/core/context\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { createLogger, env, isProduction, isTest } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport type { OAuthProvider } from \"@better-auth/core/oauth2\";\nimport type { SocialProviders } from \"@better-auth/core/social-providers\";\nimport { socialProviders } from \"@better-auth/core/social-providers\";\nimport { deprecate } from \"@better-auth/core/utils\";\nimport { createTelemetry } from \"@better-auth/telemetry\";\nimport defu from \"defu\";\nimport type { Entries } from \"type-fest\";\nimport { checkEndpointConflicts } from \"../api\";\nimport { matchesOriginPattern } from \"../auth/trusted-origins\";\nimport { createCookieGetter, getCookies } from \"../cookies\";\nimport { hashPassword, verifyPassword } from \"../crypto/password\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { generateId } from \"../utils\";\nimport { DEFAULT_SECRET } from \"../utils/constants\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { checkPassword } from \"../utils/password\";\nimport { getBaseURL } from \"../utils/url\";\nimport {\n\tgetInternalPlugins,\n\tgetTrustedOrigins,\n\trunPluginInit,\n} from \"./helpers\";\n\n/**\n * Estimates the entropy of a string in bits.\n * This is a simple approximation that helps detect low-entropy secrets.\n */\nfunction estimateEntropy(str: string): number {\n\tconst unique = new Set(str).size;\n\tif (unique === 0) return 0;\n\treturn Math.log2(Math.pow(unique, str.length));\n}\n\n/**\n * Validates that the secret meets minimum security requirements.\n * Throws BetterAuthError if the secret is invalid.\n * Skips validation for DEFAULT_SECRET in test environments only.\n * Only throws for DEFAULT_SECRET in production environment.\n */\nfunction validateSecret(\n\tsecret: string,\n\tlogger: ReturnType<typeof createLogger>,\n): void {\n\tconst isDefaultSecret = secret === DEFAULT_SECRET;\n\n\tif (isTest()) {\n\t\treturn;\n\t}\n\n\tif (isDefaultSecret && isProduction) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.\",\n\t\t);\n\t}\n\n\tif (!secret) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"BETTER_AUTH_SECRET is missing. Set it in your environment or pass `secret` to betterAuth({ secret }).\",\n\t\t);\n\t}\n\n\tif (secret.length < 32) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Warning: your BETTER_AUTH_SECRET should be at least 32 characters long for adequate security. Generate one with \\`npx @better-auth/cli secret\\` or \\`openssl rand -base64 32\\`.`,\n\t\t);\n\t}\n\n\t// Optional high-entropy check: warn if entropy appears low\n\tconst entropy = estimateEntropy(secret);\n\tif (entropy < 120) {\n\t\tlogger.warn(\n\t\t\t\"[better-auth] Warning: your BETTER_AUTH_SECRET appears low-entropy. Use a randomly generated secret for production.\",\n\t\t);\n\t}\n}\n\nexport async function createAuthContext(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\toptions: BetterAuthOptions,\n\tgetDatabaseType: (database: BetterAuthOptions[\"database\"]) => string,\n): Promise<AuthContext> {\n\t//set default options for stateless mode\n\tif (!options.database) {\n\t\toptions = defu(options, {\n\t\t\tsession: {\n\t\t\t\tcookieCache: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tstrategy: \"jwe\" as const,\n\t\t\t\t\trefreshCache: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tstoreStateStrategy: \"cookie\" as const,\n\t\t\t\tstoreAccountCookie: true,\n\t\t\t},\n\t\t});\n\t}\n\tconst plugins = options.plugins || [];\n\tconst internalPlugins = getInternalPlugins(options);\n\tconst logger = createLogger(options.logger);\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath);\n\n\tif (!baseURL) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Base URL could not be determined. Please set a valid base URL using the baseURL config option or the BETTER_AUTH_BASE_URL environment variable. Without this, callbacks and redirects may not work correctly.`,\n\t\t);\n\t}\n\n\tif (\n\t\tadapter.id === \"memory\" &&\n\t\toptions.advanced?.database?.generateId === false\n\t) {\n\t\tlogger.error(\n\t\t\t`[better-auth] Misconfiguration detected.\nYou are using the memory DB with generateId: false.\nThis will cause no id to be generated for any model.\nMost of the features of Better Auth will not work correctly.`,\n\t\t);\n\t}\n\n\tconst secret =\n\t\toptions.secret ||\n\t\tenv.BETTER_AUTH_SECRET ||\n\t\tenv.AUTH_SECRET ||\n\t\tDEFAULT_SECRET;\n\n\tvalidateSecret(secret, logger);\n\n\toptions = {\n\t\t...options,\n\t\tsecret,\n\t\tbaseURL: baseURL ? new URL(baseURL).origin : \"\",\n\t\tbasePath: options.basePath || \"/api/auth\",\n\t\tplugins: plugins.concat(internalPlugins),\n\t};\n\n\tcheckEndpointConflicts(options, logger);\n\tconst cookies = getCookies(options);\n\tconst tables = getAuthTables(options);\n\tconst providers: OAuthProvider[] = (\n\t\tObject.entries(\n\t\t\toptions.socialProviders || {},\n\t\t) as unknown as Entries<SocialProviders>\n\t)\n\t\t.map(([key, config]) => {\n\t\t\tif (config == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (config.enabled === false) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!config.clientId) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Social provider ${key} is missing clientId or clientSecret`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst provider = socialProviders[key](config as never);\n\t\t\t(provider as OAuthProvider).disableImplicitSignUp =\n\t\t\t\tconfig.disableImplicitSignUp;\n\t\t\treturn provider;\n\t\t})\n\t\t.filter((x) => x !== null);\n\n\tconst generateIdFunc: AuthContext[\"generateId\"] = ({ model, size }) => {\n\t\tif (typeof (options.advanced as any)?.generateId === \"function\") {\n\t\t\treturn (options.advanced as any).generateId({ model, size });\n\t\t}\n\t\tconst dbGenerateId = options?.advanced?.database?.generateId;\n\t\tif (typeof dbGenerateId === \"function\") {\n\t\t\treturn dbGenerateId({ model, size });\n\t\t}\n\t\tif (dbGenerateId === \"uuid\") {\n\t\t\treturn crypto.randomUUID();\n\t\t}\n\t\tif (dbGenerateId === \"serial\" || dbGenerateId === false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn generateId(size);\n\t};\n\n\tconst { publish } = await createTelemetry(options, {\n\t\tadapter: adapter.id,\n\t\tdatabase:\n\t\t\ttypeof options.database === \"function\"\n\t\t\t\t? \"adapter\"\n\t\t\t\t: getDatabaseType(options.database),\n\t});\n\n\tconst trustedOrigins = await getTrustedOrigins(options);\n\n\tconst ctx: AuthContext = {\n\t\tappName: options.appName || \"Better Auth\",\n\t\tbaseURL: baseURL || \"\",\n\t\tversion: getBetterAuthVersion(),\n\t\tsocialProviders: providers,\n\t\toptions,\n\t\toauthConfig: {\n\t\t\tstoreStateStrategy:\n\t\t\t\toptions.account?.storeStateStrategy ||\n\t\t\t\t(options.database ? \"database\" : \"cookie\"),\n\t\t\tskipStateCookieCheck: !!options.account?.skipStateCookieCheck,\n\t\t},\n\t\ttables,\n\t\ttrustedOrigins,\n\t\tisTrustedOrigin(\n\t\t\turl: string,\n\t\t\tsettings?: {\n\t\t\t\tallowRelativePaths: boolean;\n\t\t\t},\n\t\t) {\n\t\t\treturn this.trustedOrigins.some((origin) =>\n\t\t\t\tmatchesOriginPattern(url, origin, settings),\n\t\t\t);\n\t\t},\n\t\tsessionConfig: {\n\t\t\tupdateAge:\n\t\t\t\toptions.session?.updateAge !== undefined\n\t\t\t\t\t? options.session.updateAge\n\t\t\t\t\t: 24 * 60 * 60,\n\t\t\texpiresIn: options.session?.expiresIn || 60 * 60 * 24 * 7,\n\t\t\tfreshAge:\n\t\t\t\toptions.session?.freshAge === undefined\n\t\t\t\t\t? 60 * 60 * 24\n\t\t\t\t\t: options.session.freshAge,\n\t\t\tcookieRefreshCache: (() => {\n\t\t\t\tconst refreshCache = options.session?.cookieCache?.refreshCache;\n\t\t\t\tconst maxAge = options.session?.cookieCache?.maxAge || 60 * 5;\n\n\t\t\t\t// `refreshCache` is intended for fully stateless / DB-less setups.\n\t\t\t\t// If a server-side store is configured, prefer fetching/refreshing from that source\n\t\t\t\t// and disable stateless refresh behavior to avoid confusing/unsafe configurations.\n\t\t\t\tconst isStateful = !!options.database || !!options.secondaryStorage;\n\t\t\t\tif (isStateful && refreshCache) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[better-auth] `session.cookieCache.refreshCache` is enabled while `database` or `secondaryStorage` is configured. `refreshCache` is meant for stateless (DB-less) setups. Disabling `refreshCache`  remove it from your config to silence this warning.\",\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === false || refreshCache === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === true) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tupdateAge: Math.floor(maxAge * 0.2),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tupdateAge:\n\t\t\t\t\t\trefreshCache.updateAge !== undefined\n\t\t\t\t\t\t\t? refreshCache.updateAge\n\t\t\t\t\t\t\t: Math.floor(maxAge * 0.2),\n\t\t\t\t};\n\t\t\t})(),\n\t\t},\n\t\tsecret,\n\t\trateLimit: {\n\t\t\t...options.rateLimit,\n\t\t\tenabled: options.rateLimit?.enabled ?? isProduction,\n\t\t\twindow: options.rateLimit?.window || 10,\n\t\t\tmax: options.rateLimit?.max || 100,\n\t\t\tstorage:\n\t\t\t\toptions.rateLimit?.storage ||\n\t\t\t\t(options.secondaryStorage ? \"secondary-storage\" : \"memory\"),\n\t\t},\n\t\tauthCookies: cookies,\n\t\tlogger,\n\t\tgenerateId: generateIdFunc,\n\t\tsession: null,\n\t\tsecondaryStorage: options.secondaryStorage,\n\t\tpassword: {\n\t\t\thash: options.emailAndPassword?.password?.hash || hashPassword,\n\t\t\tverify: options.emailAndPassword?.password?.verify || verifyPassword,\n\t\t\tconfig: {\n\t\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength || 8,\n\t\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128,\n\t\t\t},\n\t\t\tcheckPassword,\n\t\t},\n\t\tsetNewSession(session) {\n\t\t\tthis.newSession = session;\n\t\t},\n\t\tnewSession: null,\n\t\tadapter: adapter,\n\t\tinternalAdapter: createInternalAdapter(adapter, {\n\t\t\toptions,\n\t\t\tlogger,\n\t\t\thooks: options.databaseHooks ? [options.databaseHooks] : [],\n\t\t\tgenerateId: generateIdFunc,\n\t\t}),\n\t\tcreateAuthCookie: createCookieGetter(options),\n\t\tasync runMigrations() {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"runMigrations will be set by the specific init implementation\",\n\t\t\t);\n\t\t},\n\t\tpublishTelemetry: publish,\n\t\tskipCSRFCheck: !!options.advanced?.disableCSRFCheck,\n\t\tskipOriginCheck:\n\t\t\toptions.advanced?.disableOriginCheck !== undefined\n\t\t\t\t? options.advanced.disableOriginCheck\n\t\t\t\t: isTest()\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\trunInBackground:\n\t\t\toptions.advanced?.backgroundTasks?.handler ??\n\t\t\t((p) => {\n\t\t\t\tp.catch(() => {});\n\t\t\t}),\n\t\tasync runInBackgroundOrAwait(\n\t\t\tpromise: Promise<unknown> | Promise<void> | void | unknown,\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (options.advanced?.backgroundTasks?.handler) {\n\t\t\t\t\tif (promise instanceof Promise) {\n\t\t\t\t\t\toptions.advanced.backgroundTasks.handler(\n\t\t\t\t\t\t\tpromise.catch((e) => {\n\t\t\t\t\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait promise;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t}\n\t\t},\n\t\tgetPlugin: <Plugin extends BetterAuthPlugin>(id: Plugin[\"id\"]) =>\n\t\t\t(options.plugins!.find((p): p is Plugin => p.id === id) as\n\t\t\t\t| Plugin\n\t\t\t\t| undefined) ?? null,\n\t};\n\n\tconst initOrPromise = runPluginInit(ctx);\n\tlet context: AuthContext;\n\tif (isPromise(initOrPromise)) {\n\t\t({ context } = await initOrPromise);\n\t} else {\n\t\t({ context } = initOrPromise);\n\t}\n\n\tif (\n\t\ttypeof context.options.emailVerification?.onEmailVerification === \"function\"\n\t) {\n\t\tcontext.options.emailVerification.onEmailVerification = deprecate(\n\t\t\tcontext.options.emailVerification.onEmailVerification,\n\t\t\t\"Use `afterEmailVerification` instead. This will be removed in 1.5\",\n\t\t\tcontext.logger,\n\t\t);\n\t}\n\n\treturn context;\n}\n","import type {\n\tBetterAuthOptions,\n\tGenericEndpointContext,\n} from \"@better-auth/core\";\nimport {\n\tcreateAuthEndpoint,\n\tcreateAuthMiddleware,\n} from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport {\n\tdeleteSessionCookie,\n\texpireCookie,\n\tgetChunkedCookie,\n\tsetCookieCache,\n\tsetSessionCookie,\n} from \"../../cookies\";\nimport { getSessionQuerySchema } from \"../../cookies/session-store\";\nimport { symmetricDecodeJWT, verifyJWT } from \"../../crypto\";\nimport { parseSessionOutput, parseUserOutput } from \"../../db\";\nimport type { InferSession, InferUser, Session, User } from \"../../types\";\nimport type { Prettify } from \"../../types/helper\";\nimport { getDate } from \"../../utils/date\";\n\nexport const getSession = <Option extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/get-session\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\toperationId: \"getSession\",\n\t\t\tquery: getSessionQuerySchema,\n\t\t\trequireHeaders: true,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"getSession\",\n\t\t\t\t\tdescription: \"Get the current session\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/Session\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"session\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tctx,\n\t\t): Promise<{\n\t\t\tsession: InferSession<Option>;\n\t\t\tuser: InferUser<Option>;\n\t\t} | null> => {\n\t\t\ttry {\n\t\t\t\tconst sessionCookieToken = await ctx.getSignedCookie(\n\t\t\t\t\tctx.context.authCookies.sessionToken.name,\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t);\n\n\t\t\t\tif (!sessionCookieToken) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst sessionDataCookie = getChunkedCookie(\n\t\t\t\t\tctx,\n\t\t\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\t\t);\n\n\t\t\t\tlet sessionDataPayload: {\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t};\n\t\t\t\t\texpiresAt: number;\n\t\t\t\t} | null = null;\n\n\t\t\t\tif (sessionDataCookie) {\n\t\t\t\t\tconst strategy =\n\t\t\t\t\t\tctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\n\t\t\t\t\tif (strategy === \"jwe\") {\n\t\t\t\t\t\t// Decode JWE (encrypted)\n\t\t\t\t\t\tconst payload = await symmetricDecodeJWT<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\texp?: number;\n\t\t\t\t\t\t}>(sessionDataCookie, ctx.context.secret, \"better-auth-session\");\n\n\t\t\t\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t\t\t\tsessionDataPayload = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\t\t\t\tversion: payload.version,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1000 : Date.now(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (strategy === \"jwt\") {\n\t\t\t\t\t\t// Decode JWT (signed with HMAC, not encrypted)\n\t\t\t\t\t\tconst payload = await verifyJWT<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\texp?: number;\n\t\t\t\t\t\t}>(sessionDataCookie, ctx.context.secret);\n\n\t\t\t\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t\t\t\tsessionDataPayload = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\t\t\t\tversion: payload.version,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1000 : Date.now(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Decode compact format (or legacy base64-hmac)\n\t\t\t\t\t\tconst parsed = safeJSONParse<{\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsignature: string;\n\t\t\t\t\t\t\texpiresAt: number;\n\t\t\t\t\t\t}>(binary.decode(base64Url.decode(sessionDataCookie)));\n\n\t\t\t\t\t\tif (parsed) {\n\t\t\t\t\t\t\tconst isValid = await createHMAC(\n\t\t\t\t\t\t\t\t\"SHA-256\",\n\t\t\t\t\t\t\t\t\"base64urlnopad\",\n\t\t\t\t\t\t\t).verify(\n\t\t\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\t\t\texpiresAt: parsed.expiresAt,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tparsed.signature,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\t\tsessionDataPayload = parsed;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dontRememberMe = await ctx.getSignedCookie(\n\t\t\t\t\tctx.context.authCookies.dontRememberToken.name,\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * If session data is present in the cookie, check if it should be used or refreshed\n\t\t\t\t */\n\t\t\t\tif (\n\t\t\t\t\tsessionDataPayload?.session &&\n\t\t\t\t\tctx.context.options.session?.cookieCache?.enabled &&\n\t\t\t\t\t!ctx.query?.disableCookieCache\n\t\t\t\t) {\n\t\t\t\t\tconst session = sessionDataPayload.session;\n\n\t\t\t\t\tconst versionConfig =\n\t\t\t\t\t\tctx.context.options.session?.cookieCache?.version;\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (versionConfig) {\n\t\t\t\t\t\tif (typeof versionConfig === \"string\") {\n\t\t\t\t\t\t\texpectedVersion = versionConfig;\n\t\t\t\t\t\t} else if (typeof versionConfig === \"function\") {\n\t\t\t\t\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\t\t\t\t\texpectedVersion =\n\t\t\t\t\t\t\t\tresult instanceof Promise ? await result : result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cookieVersion = session.version || \"1\";\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\t// Version mismatch - invalidate the cookie cache\n\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst cachedSessionExpiresAt = new Date(\n\t\t\t\t\t\t\tsession.session.expiresAt as unknown as string | number | Date,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hasExpired =\n\t\t\t\t\t\t\tsessionDataPayload.expiresAt < Date.now() ||\n\t\t\t\t\t\t\tcachedSessionExpiresAt < new Date();\n\n\t\t\t\t\t\tif (hasExpired) {\n\t\t\t\t\t\t\t// When the session data cookie has expired, delete it;\n\t\t\t\t\t\t\t//  then we try to fetch from DB\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Check if the cookie cache needs to be refreshed based on refreshCache\n\t\t\t\t\t\t\tconst cookieRefreshCache =\n\t\t\t\t\t\t\t\tctx.context.sessionConfig.cookieRefreshCache;\n\n\t\t\t\t\t\t\tif (cookieRefreshCache === false) {\n\t\t\t\t\t\t\t\t// If refreshCache is disabled, return the session from cookie as-is\n\t\t\t\t\t\t\t\tctx.context.session = session;\n\t\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\t\t// Rehydrate date fields from JSON strings before parsing\n\t\t\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(session.session.expiresAt),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(session.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(session.session.updatedAt),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t\t...session.user,\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(session.user.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(session.user.updatedAt),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst timeUntilExpiry = sessionDataPayload.expiresAt - Date.now();\n\t\t\t\t\t\t\tconst updateAge = cookieRefreshCache.updateAge * 1000; // Convert to milliseconds\n\n\t\t\t\t\t\t\tif (timeUntilExpiry < updateAge) {\n\t\t\t\t\t\t\t\tconst cookieMaxAge =\n\t\t\t\t\t\t\t\t\tctx.context.options.session?.cookieCache?.maxAge || 60 * 5;\n\t\t\t\t\t\t\t\tconst newExpiresAt = getDate(cookieMaxAge, \"sec\");\n\t\t\t\t\t\t\t\tconst refreshedSession = {\n\t\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\t\t\texpiresAt: newExpiresAt,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Set the refreshed cookie cache\n\t\t\t\t\t\t\t\tawait setCookieCache(ctx, refreshedSession, false);\n\n\t\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\t\t// Rehydrate date fields from JSON strings before parsing\n\t\t\t\t\t\t\t\tconst parsedRefreshedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t...refreshedSession.session,\n\t\t\t\t\t\t\t\t\t\texpiresAt: new Date(refreshedSession.session.expiresAt),\n\t\t\t\t\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.session.updatedAt),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst parsedRefreshedUser = parseUserOutput(\n\t\t\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t...refreshedSession.user,\n\t\t\t\t\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.user.createdAt),\n\t\t\t\t\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.user.updatedAt),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tctx.context.session = {\n\t\t\t\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedRefreshedUser,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedRefreshedUser,\n\t\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(session.session.expiresAt),\n\t\t\t\t\t\t\t\tcreatedAt: new Date(session.session.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(session.session.updatedAt),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t...session.user,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(session.user.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(session.user.updatedAt),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tctx.context.session = {\n\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst session =\n\t\t\t\t\tawait ctx.context.internalAdapter.findSession(sessionCookieToken);\n\t\t\t\tctx.context.session = session;\n\t\t\t\tif (!session || session.session.expiresAt < new Date()) {\n\t\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\t\tif (session) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * if session expired clean up the session\n\t\t\t\t\t\t */\n\t\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(\n\t\t\t\t\t\t\tsession.session.token,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * We don't need to update the session if the user doesn't want to be remembered\n\t\t\t\t * or if the session refresh is disabled\n\t\t\t\t */\n\t\t\t\tif (dontRememberMe || ctx.query?.disableRefresh) {\n\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\tconst parsedSession = parseSessionOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tsession.session,\n\t\t\t\t\t);\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t} as {\n\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst expiresIn = ctx.context.sessionConfig.expiresIn;\n\t\t\t\tconst updateAge = ctx.context.sessionConfig.updateAge;\n\t\t\t\t/**\n\t\t\t\t * Calculate last updated date to throttle write updates to database\n\t\t\t\t * Formula: ({expiry date} - sessionMaxAge) + sessionUpdateAge\n\t\t\t\t *\n\t\t\t\t * e.g. ({expiry date} - 30 days) + 1 hour\n\t\t\t\t *\n\t\t\t\t * inspired by: https://github.com/nextauthjs/next-auth/blob/main/packages/core/src/lib/actions/session.ts\n\t\t\t\t */\n\t\t\t\tconst sessionIsDueToBeUpdatedDate =\n\t\t\t\t\tsession.session.expiresAt.valueOf() -\n\t\t\t\t\texpiresIn * 1000 +\n\t\t\t\t\tupdateAge * 1000;\n\t\t\t\tconst shouldBeUpdated = sessionIsDueToBeUpdatedDate <= Date.now();\n\n\t\t\t\tif (\n\t\t\t\t\tshouldBeUpdated &&\n\t\t\t\t\t(!ctx.query?.disableRefresh ||\n\t\t\t\t\t\t!ctx.context.options.session?.disableSessionRefresh)\n\t\t\t\t) {\n\t\t\t\t\tconst updatedSession =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateSession(\n\t\t\t\t\t\t\tsession.session.token,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\texpiresAt: getDate(ctx.context.sessionConfig.expiresIn, \"sec\"),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\tif (!updatedSession) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Handle case where session update fails (e.g., concurrent deletion)\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\t\t\treturn ctx.json(null, { status: 401 });\n\t\t\t\t\t}\n\t\t\t\t\tconst maxAge =\n\t\t\t\t\t\t(updatedSession.expiresAt.valueOf() - Date.now()) / 1000;\n\t\t\t\t\tawait setSessionCookie(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmaxAge,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\tconst parsedUpdatedSession = parseSessionOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tupdatedSession,\n\t\t\t\t\t);\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: parsedUpdatedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t} as unknown as {\n\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setCookieCache(ctx, session, !!dontRememberMe);\n\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\tconst parsedSession = parseSessionOutput(\n\t\t\t\t\tctx.context.options,\n\t\t\t\t\tsession.session,\n\t\t\t\t);\n\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\tuser: parsedUser,\n\t\t\t\t} as {\n\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\"INTERNAL_SERVER_ERROR\", error);\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_SESSION,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t);\n\nexport const getSessionFromCtx = async <\n\tU extends Record<string, any> = Record<string, any>,\n\tS extends Record<string, any> = Record<string, any>,\n>(\n\tctx: GenericEndpointContext,\n\tconfig?:\n\t\t| {\n\t\t\t\tdisableCookieCache?: boolean;\n\t\t\t\tdisableRefresh?: boolean;\n\t\t  }\n\t\t| undefined,\n) => {\n\tif (ctx.context.session) {\n\t\treturn ctx.context.session as {\n\t\t\tsession: S & Session;\n\t\t\tuser: U & User;\n\t\t};\n\t}\n\n\tconst session = await getSession()({\n\t\t...ctx,\n\t\tasResponse: false,\n\t\theaders: ctx.headers!,\n\t\treturnHeaders: false,\n\t\treturnStatus: false,\n\t\tquery: {\n\t\t\t...config,\n\t\t\t...ctx.query,\n\t\t},\n\t}).catch((e) => {\n\t\treturn null;\n\t});\n\tctx.context.session = session;\n\treturn session as {\n\t\tsession: S & Session;\n\t\tuser: U & User;\n\t} | null;\n};\n\n/**\n * The middleware forces the endpoint to require a valid session.\n */\nexport const sessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n\n/**\n * This middleware forces the endpoint to require a valid session and ignores cookie cache.\n * This should be used for sensitive operations like password changes, account deletion, etc.\n * to ensure that revoked sessions cannot be used even if they're still cached in cookies.\n */\nexport const sensitiveSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx, { disableCookieCache: true });\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n\n/**\n * This middleware allows you to call the endpoint on the client if session is valid.\n * However, if called on the server, no session is required.\n */\nexport const requestOnlySessionMiddleware = createAuthMiddleware(\n\tasync (ctx) => {\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session?.session && (ctx.request || ctx.headers)) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t\t}\n\t\treturn { session };\n\t},\n);\n\n/**\n * This middleware forces the endpoint to require a valid session,\n * as well as making sure the session is fresh before proceeding.\n *\n * Session freshness check will be skipped if the session config's freshAge\n * is set to 0\n */\nexport const freshSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\tif (ctx.context.sessionConfig.freshAge === 0) {\n\t\treturn {\n\t\t\tsession,\n\t\t};\n\t}\n\tconst freshAge = ctx.context.sessionConfig.freshAge;\n\tconst lastUpdated = new Date(\n\t\tsession.session.updatedAt || session.session.createdAt,\n\t).getTime();\n\tconst now = Date.now();\n\tconst isFresh = now - lastUpdated < freshAge * 1000;\n\tif (!isFresh) {\n\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\tmessage: \"Session is not fresh\",\n\t\t});\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n/**\n * user active sessions list\n */\nexport const listSessions = <Option extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/list-sessions\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\toperationId: \"listUserSessions\",\n\t\t\tuse: [sessionMiddleware],\n\t\t\trequireHeaders: true,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"listUserSessions\",\n\t\t\t\t\tdescription: \"List all active sessions for the user\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/Session\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\ttry {\n\t\t\t\tconst sessions = await ctx.context.internalAdapter.listSessions(\n\t\t\t\t\tctx.context.session.user.id,\n\t\t\t\t);\n\t\t\t\tconst activeSessions = sessions.filter((session) => {\n\t\t\t\t\treturn session.expiresAt > new Date();\n\t\t\t\t});\n\t\t\t\treturn ctx.json(\n\t\t\t\t\tactiveSessions.map((session) =>\n\t\t\t\t\t\tparseSessionOutput(ctx.context.options, session),\n\t\t\t\t\t) as unknown as Prettify<InferSession<Option>>[],\n\t\t\t\t);\n\t\t\t} catch (e: any) {\n\t\t\t\tctx.context.logger.error(e);\n\t\t\t\tthrow ctx.error(\"INTERNAL_SERVER_ERROR\");\n\t\t\t}\n\t\t},\n\t);\n\n/**\n * revoke a single session\n */\nexport const revokeSession = createAuthEndpoint(\n\t\"/revoke-session\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to revoke\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Revoke a single session\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The token to revoke\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"token\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the session was revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst token = ctx.body.token;\n\t\tconst session = await ctx.context.internalAdapter.findSession(token);\n\n\t\tif (session?.session.userId === ctx.context.session.user.id) {\n\t\t\ttry {\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(token);\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\n\t\t\t\t\terror && typeof error === \"object\" && \"name\" in error\n\t\t\t\t\t\t? (error.name as string)\n\t\t\t\t\t\t: \"\",\n\t\t\t\t\terror,\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t\t\t}\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n/**\n * revoke all user sessions\n */\nexport const revokeSessions = createAuthEndpoint(\n\t\"/revoke-sessions\",\n\t{\n\t\tmethod: \"POST\",\n\t\tuse: [sensitiveSessionMiddleware],\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Revoke all sessions for the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if all sessions were revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\ttry {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(\n\t\t\t\tctx.context.session.user.id,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tctx.context.logger.error(\n\t\t\t\terror && typeof error === \"object\" && \"name\" in error\n\t\t\t\t\t? (error.name as string)\n\t\t\t\t\t: \"\",\n\t\t\t\terror,\n\t\t\t);\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const revokeOtherSessions = createAuthEndpoint(\n\t\"/revoke-other-sessions\",\n\t{\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Revoke all other sessions for the user except the current one\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if all other sessions were revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst session = ctx.context.session;\n\t\tif (!session.user) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst sessions = await ctx.context.internalAdapter.listSessions(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst activeSessions = sessions.filter((session) => {\n\t\t\treturn session.expiresAt > new Date();\n\t\t});\n\t\tconst otherSessions = activeSessions.filter(\n\t\t\t(session) => session.token !== ctx.context.session.session.token,\n\t\t);\n\t\tawait Promise.all(\n\t\t\totherSessions.map((session) =>\n\t\t\t\tctx.context.internalAdapter.deleteSession(session.token),\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tgenerateCodeChallenge,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport type LoginType =\n\t| 0 /** Facebook OAuth */\n\t| 1 /** Google OAuth */\n\t| 24 /** Apple OAuth */\n\t| 27 /** Microsoft OAuth */\n\t| 97 /** Mobile device */\n\t| 98 /** RingCentral OAuth */\n\t| 99 /** API user */\n\t| 100 /** Zoom Work email */\n\t| 101; /** Single Sign-On (SSO) */\n\nexport type AccountStatus = \"pending\" | \"active\" | \"inactive\";\n\nexport type PronounOption =\n\t| 1 /** Ask the user every time */\n\t| 2 /** Always display */\n\t| 3; /** Do not display */\n\nexport interface PhoneNumber {\n\t/** The country code of the phone number (Example: \"+1\") */\n\tcode: string;\n\n\t/** The country of the phone number (Example: \"US\") */\n\tcountry: string;\n\n\t/** The label for the phone number (Example: \"Mobile\") */\n\tlabel: string;\n\n\t/** The phone number itself (Example: \"800000000\") */\n\tnumber: string;\n\n\t/** Whether the phone number has been verified (Example: true) */\n\tverified: boolean;\n}\n\n/**\n * See the full documentation below:\n * https://developers.zoom.us/docs/api/users/#tag/users/GET/users/{userId}\n */\nexport interface ZoomProfile extends Record<string, any> {\n\t/* cspell:disable-next-line */\n\t/** The user's account ID (Example: \"q6gBJVO5TzexKYTb_I2rpg\") */\n\taccount_id: string;\n\t/** The user's account number (Example: 10009239) */\n\taccount_number: number;\n\t/** The user's cluster (Example: \"us04\") */\n\tcluster: string;\n\t/** The user's CMS ID. Only enabled for Kaltura integration (Example: \"KDcuGIm1QgePTO8WbOqwIQ\") */\n\tcms_user_id: string;\n\t/** The user's cost center (Example: \"cost center\") */\n\tcost_center: string;\n\t/** User create time (Example: \"2018-10-31T04:32:37Z\") */\n\tcreated_at: string;\n\t/** Department (Example: \"Developers\") */\n\tdept: string;\n\t/** User's display name (Example: \"Jill Chill\") */\n\tdisplay_name: string;\n\t/** User's email address (Example: \"jchill@example.com\") */\n\temail: string;\n\t/** User's first name (Example: \"Jill\") */\n\tfirst_name: string;\n\t/* cspell:disable-next-line */\n\t/** IDs of the web groups that the user belongs to (Example: [\"RSMaSp8sTEGK0_oamiA2_w\"]) */\n\tgroup_ids: string[];\n\t/* cspell:disable-next-line */\n\t/** User ID (Example: \"zJKyaiAyTNC-MWjiWC18KQ\") */\n\tid: string;\n\t/* cspell:disable-next-line */\n\t/** IM IDs of the groups that the user belongs to (Example: [\"t-_-d56CSWG-7BF15LLrOw\"]) */\n\tim_group_ids: string[];\n\t/** The user's JID (Example: \"jchill@example.com\") */\n\tjid: string;\n\t/** The user's job title (Example: \"API Developer\") */\n\tjob_title: string;\n\t/** Default language for the Zoom Web Portal (Example: \"en-US\") */\n\tlanguage: string;\n\t/** User last login client version (Example: \"5.9.6.4993(mac)\") */\n\tlast_client_version: string;\n\t/** User last login time (Example: \"2021-05-05T20:40:30Z\") */\n\tlast_login_time: string;\n\t/** User's last name (Example: \"Chill\") */\n\tlast_name: string;\n\t/** The time zone of the user (Example: \"Asia/Shanghai\") */\n\ttimezone: string;\n\t/** User's location (Example: \"Paris\") */\n\tlocation: string;\n\t/** The user's login method (Example: 101) */\n\tlogin_types: LoginType[];\n\t/** User's personal meeting URL (Example: \"example.com\") */\n\tpersonal_meeting_url: string;\n\t/** This field has been deprecated and will not be supported in the future.\n\t * Use the phone_numbers field instead of this field.\n\t * The user's phone number (Example: \"+1 800000000\") */\n\t// @deprecated true\n\tphone_number?: string | undefined;\n\t/** The URL for user's profile picture (Example: \"example.com\") */\n\tpic_url: string;\n\t/** Personal Meeting ID (PMI) (Example: 3542471135) */\n\tpmi: number;\n\t/** Unique identifier of the user's assigned role (Example: \"0\") */\n\trole_id: string;\n\t/** User's role name (Example: \"Admin\") */\n\trole_name: string;\n\t/** Status of user's account (Example: \"pending\") */\n\tstatus: AccountStatus;\n\t/** Use the personal meeting ID (PMI) for instant meetings (Example: false) */\n\tuse_pmi: boolean;\n\t/** The time and date when the user was created (Example: \"2018-10-31T04:32:37Z\") */\n\tuser_created_at: string;\n\t/** Displays whether user is verified or not (Example: 1) */\n\tverified: number;\n\t/** The user's Zoom Workplace plan option (Example: 64) */\n\tzoom_one_type: number;\n\t/** The user's company (Example: \"Jill\") */\n\tcompany?: string | undefined;\n\t/* cspell:disable-next-line */\n\t/** Custom attributes that have been assigned to the user (Example: [{ \"key\": \"cbf_cywdkexrtqc73f97gd4w6g\", \"name\": \"A1\", \"value\": \"1\" }]) */\n\tcustom_attributes?:\n\t\t| { key: string; name: string; value: string }[]\n\t\t| undefined;\n\t/* cspell:disable-next-line */\n\t/** The employee's unique ID. This field only returns when SAML single sign-on (SSO) is enabled. The `login_type` value is `101` (SSO) (Example: \"HqDyI037Qjili1kNsSIrIg\") */\n\temployee_unique_id?: string | undefined;\n\t/** The manager for the user (Example: \"thill@example.com\") */\n\tmanager?: string | undefined;\n\t/** The user's country for the company phone number (Example: \"US\")\n\t * @deprecated true */\n\tphone_country?: string | undefined;\n\t/** The phone number's ISO country code (Example: \"+1\") */\n\tphone_numbers?: PhoneNumber[] | undefined;\n\t/** The user's plan type (Example: \"1\") */\n\tplan_united_type?: string | undefined;\n\t/** The user's pronouns (Example: \"3123\") */\n\tpronouns?: string | undefined;\n\t/** The user's display pronouns setting (Example: 1) */\n\tpronouns_option?: PronounOption | undefined;\n\t/** Personal meeting room URL, if the user has one (Example: \"example.com\") */\n\tvanity_url?: string | undefined;\n}\n\nexport interface ZoomOptions extends ProviderOptions<ZoomProfile> {\n\tclientId: string;\n\tpkce?: boolean | undefined;\n}\n\nexport const zoom = (userOptions: ZoomOptions) => {\n\tconst options = {\n\t\tpkce: true,\n\t\t...userOptions,\n\t};\n\n\treturn {\n\t\tid: \"zoom\",\n\t\tname: \"Zoom\",\n\t\tcreateAuthorizationURL: async ({ state, redirectURI, codeVerifier }) => {\n\t\t\tconst params = new URLSearchParams({\n\t\t\t\tresponse_type: \"code\",\n\t\t\t\tredirect_uri: options.redirectURI ? options.redirectURI : redirectURI,\n\t\t\t\tclient_id: options.clientId,\n\t\t\t\tstate,\n\t\t\t});\n\n\t\t\tif (options.pkce) {\n\t\t\t\tconst codeChallenge = await generateCodeChallenge(codeVerifier);\n\t\t\t\tparams.set(\"code_challenge_method\", \"S256\");\n\t\t\t\tparams.set(\"code_challenge\", codeChallenge);\n\t\t\t}\n\n\t\t\tconst url = new URL(\"https://zoom.us/oauth/authorize\");\n\t\t\turl.search = params.toString();\n\n\t\t\treturn url;\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI, codeVerifier }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI: options.redirectURI || redirectURI,\n\t\t\t\tcodeVerifier,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://zoom.us/oauth/token\",\n\t\t\t\tauthentication: \"post\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) =>\n\t\t\t\t\trefreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://zoom.us/oauth/token\",\n\t\t\t\t\t}),\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error } = await betterFetch<ZoomProfile>(\n\t\t\t\t\"https://api.zoom.us/v2/users/me\",\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tauthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.id,\n\t\t\t\t\tname: profile.display_name,\n\t\t\t\t\timage: profile.pic_url,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\temailVerified: Boolean(profile.verified),\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: {\n\t\t\t\t\t...profile,\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t} satisfies OAuthProvider<ZoomProfile>;\n};\n","import { decodeJwt } from \"jose\";\nimport { logger } from \"../env\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\n/**\n * @see https://dev.twitch.tv/docs/authentication/getting-tokens-oidc/#requesting-claims\n */\nexport interface TwitchProfile {\n\t/**\n\t * The sub of the user\n\t */\n\tsub: string;\n\t/**\n\t * The preferred username of the user\n\t */\n\tpreferred_username: string;\n\t/**\n\t * The email of the user\n\t */\n\temail: string;\n\t/**\n\t * Indicate if this user has a verified email.\n\t */\n\temail_verified: boolean;\n\t/**\n\t * The picture of the user\n\t */\n\tpicture: string;\n}\n\nexport interface TwitchOptions extends ProviderOptions<TwitchProfile> {\n\tclientId: string;\n\tclaims?: string[] | undefined;\n}\nexport const twitch = (options: TwitchOptions) => {\n\treturn {\n\t\tid: \"twitch\",\n\t\tname: \"Twitch\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI }) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"user:read:email\", \"openid\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"twitch\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://id.twitch.tv/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate,\n\t\t\t\tclaims: options.claims || [\n\t\t\t\t\t\"email\",\n\t\t\t\t\t\"email_verified\",\n\t\t\t\t\t\"preferred_username\",\n\t\t\t\t\t\"picture\",\n\t\t\t\t],\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://id.twitch.tv/oauth2/token\",\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://id.twitch.tv/oauth2/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst idToken = token.idToken;\n\t\t\tif (!idToken) {\n\t\t\t\tlogger.error(\"No idToken found in token\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst profile = decodeJwt(idToken) as TwitchProfile;\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.sub,\n\t\t\t\t\tname: profile.preferred_username,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.picture,\n\t\t\t\t\temailVerified: profile.email_verified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<TwitchProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface KickProfile {\n\t/**\n\t * The user id of the user\n\t */\n\tuser_id: string;\n\t/**\n\t * The name of the user\n\t */\n\tname: string;\n\t/**\n\t * The email of the user\n\t */\n\temail: string;\n\t/**\n\t * The picture of the user\n\t */\n\tprofile_picture: string;\n}\n\nexport interface KickOptions extends ProviderOptions<KickProfile> {\n\tclientId: string;\n}\n\nexport const kick = (options: KickOptions) => {\n\treturn {\n\t\tid: \"kick\",\n\t\tname: \"Kick\",\n\t\tcreateAuthorizationURL({ state, scopes, redirectURI, codeVerifier }) {\n\t\t\tconst _scopes = options.disableDefaultScope ? [] : [\"user:read\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (scopes) _scopes.push(...scopes);\n\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"kick\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://id.kick.com/oauth/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tcodeVerifier,\n\t\t\t\tstate,\n\t\t\t});\n\t\t},\n\t\tasync validateAuthorizationCode({ code, redirectURI, codeVerifier }) {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://id.kick.com/oauth/token\",\n\t\t\t\tcodeVerifier,\n\t\t\t});\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint: \"https://id.kick.com/oauth/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\n\t\t\tconst { data, error } = await betterFetch<{\n\t\t\t\tdata: KickProfile[];\n\t\t\t}>(\"https://api.kick.com/public/v1/users\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (error) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst profile = data.data[0]!;\n\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\t// Kick does not provide email_verified claim.\n\t\t\t// We default to false for security consistency.\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.user_id,\n\t\t\t\t\tname: profile.name,\n\t\t\t\t\temail: profile.email,\n\t\t\t\t\timage: profile.profile_picture,\n\t\t\t\t\temailVerified: false,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<KickProfile>;\n};\n","import { betterFetch } from \"@better-fetch/fetch\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\nexport interface TwitterProfile {\n\tdata: {\n\t\t/**\n\t\t * Unique identifier of this user. This is returned as a string in order to avoid complications with languages and tools\n\t\t * that cannot handle large integers.\n\t\t */\n\t\tid: string;\n\t\t/** The friendly name of this user, as shown on their profile. */\n\t\tname: string;\n\t\t/** The email address of this user. */\n\t\temail?: string | undefined;\n\t\t/** The Twitter handle (screen name) of this user. */\n\t\tusername: string;\n\t\t/**\n\t\t * The location specified in the user's profile, if the user provided one.\n\t\t * As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.\n\t\t *\n\t\t * To return this field, add `user.fields=location` in the authorization request's query parameter.\n\t\t */\n\t\tlocation?: string | undefined;\n\t\t/**\n\t\t * This object and its children fields contain details about text that has a special meaning in the user's description.\n\t\t *\n\t\t *To return this field, add `user.fields=entities` in the authorization request's query parameter.\n\t\t */\n\t\tentities?:\n\t\t\t| {\n\t\t\t\t\t/** Contains details about the user's profile website. */\n\t\t\t\t\turl: {\n\t\t\t\t\t\t/** Contains details about the user's profile website. */\n\t\t\t\t\t\turls: Array<{\n\t\t\t\t\t\t\t/** The start position (zero-based) of the recognized user's profile website. All start indices are inclusive. */\n\t\t\t\t\t\t\tstart: number;\n\t\t\t\t\t\t\t/** The end position (zero-based) of the recognized user's profile website. This end index is exclusive. */\n\t\t\t\t\t\t\tend: number;\n\t\t\t\t\t\t\t/** The URL in the format entered by the user. */\n\t\t\t\t\t\t\turl: string;\n\t\t\t\t\t\t\t/** The fully resolved URL. */\n\t\t\t\t\t\t\texpanded_url: string;\n\t\t\t\t\t\t\t/** The URL as displayed in the user's profile. */\n\t\t\t\t\t\t\tdisplay_url: string;\n\t\t\t\t\t\t}>;\n\t\t\t\t\t};\n\t\t\t\t\t/** Contains details about URLs, Hashtags, Cashtags, or mentions located within a user's description. */\n\t\t\t\t\tdescription: {\n\t\t\t\t\t\thashtags: Array<{\n\t\t\t\t\t\t\tstart: number;\n\t\t\t\t\t\t\tend: number;\n\t\t\t\t\t\t\ttag: string;\n\t\t\t\t\t\t}>;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t\t/**\n\t\t * Indicate if this user is a verified Twitter user.\n\t\t *\n\t\t * To return this field, add `user.fields=verified` in the authorization request's query parameter.\n\t\t */\n\t\tverified?: boolean | undefined;\n\t\t/**\n\t\t * The text of this user's profile description (also known as bio), if the user provided one.\n\t\t *\n\t\t * To return this field, add `user.fields=description` in the authorization request's query parameter.\n\t\t */\n\t\tdescription?: string | undefined;\n\t\t/**\n\t\t * The URL specified in the user's profile, if present.\n\t\t *\n\t\t * To return this field, add `user.fields=url` in the authorization request's query parameter.\n\t\t */\n\t\turl?: string | undefined;\n\t\t/** The URL to the profile image for this user, as shown on the user's profile. */\n\t\tprofile_image_url?: string | undefined;\n\t\tprotected?: boolean | undefined;\n\t\t/**\n\t\t * Unique identifier of this user's pinned Tweet.\n\t\t *\n\t\t *  You can obtain the expanded object in `includes.tweets` by adding `expansions=pinned_tweet_id` in the authorization request's query parameter.\n\t\t */\n\t\tpinned_tweet_id?: string | undefined;\n\t\tcreated_at?: string | undefined;\n\t};\n\tincludes?:\n\t\t| {\n\t\t\t\ttweets?: Array<{\n\t\t\t\t\tid: string;\n\t\t\t\t\ttext: string;\n\t\t\t\t}>;\n\t\t  }\n\t\t| undefined;\n\t[claims: string]: unknown;\n}\n\nexport interface TwitterOption extends ProviderOptions<TwitterProfile> {\n\tclientId: string;\n}\n\nexport const twitter = (options: TwitterOption) => {\n\treturn {\n\t\tid: \"twitter\",\n\t\tname: \"Twitter\",\n\t\tcreateAuthorizationURL(data) {\n\t\t\tconst _scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"users.read\", \"tweet.read\", \"offline.access\", \"users.email\"];\n\t\t\tif (options.scope) _scopes.push(...options.scope);\n\t\t\tif (data.scopes) _scopes.push(...data.scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"twitter\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint: \"https://x.com/i/oauth2/authorize\",\n\t\t\t\tscopes: _scopes,\n\t\t\t\tstate: data.state,\n\t\t\t\tcodeVerifier: data.codeVerifier,\n\t\t\t\tredirectURI: data.redirectURI,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode: async ({ code, codeVerifier, redirectURI }) => {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tauthentication: \"basic\",\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint: \"https://api.x.com/2/oauth2/token\",\n\t\t\t});\n\t\t},\n\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientKey: options.clientKey,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tauthentication: \"basic\",\n\t\t\t\t\t\ttokenEndpoint: \"https://api.x.com/2/oauth2/token\",\n\t\t\t\t\t});\n\t\t\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tconst { data: profile, error: profileError } =\n\t\t\t\tawait betterFetch<TwitterProfile>(\n\t\t\t\t\t\"https://api.x.com/2/users/me?user.fields=profile_image_url\",\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: \"GET\",\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\tif (profileError) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst { data: emailData, error: emailError } = await betterFetch<{\n\t\t\t\tdata: { confirmed_email: string };\n\t\t\t}>(\"https://api.x.com/2/users/me?user.fields=confirmed_email\", {\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t},\n\t\t\t});\n\t\t\tlet emailVerified = false;\n\t\t\tif (!emailError && emailData?.data?.confirmed_email) {\n\t\t\t\tprofile.data.email = emailData.data.confirmed_email;\n\t\t\t\temailVerified = true;\n\t\t\t}\n\t\t\tconst userMap = await options.mapProfileToUser?.(profile);\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: profile.data.id,\n\t\t\t\t\tname: profile.data.name,\n\t\t\t\t\temail: profile.data.email || profile.data.username || null,\n\t\t\t\t\timage: profile.data.profile_image_url,\n\t\t\t\t\temailVerified: emailVerified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: profile,\n\t\t\t};\n\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider<TwitterProfile>;\n};\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { decodeJwt } from \"jose\";\nimport { logger } from \"../env\";\nimport type { OAuthProvider, ProviderOptions } from \"../oauth2\";\nimport {\n\tcreateAuthorizationURL,\n\trefreshAccessToken,\n\tvalidateAuthorizationCode,\n} from \"../oauth2\";\n\n/**\n * @see [Microsoft Identity Platform - Optional claims reference](https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims-reference)\n */\nexport interface MicrosoftEntraIDProfile extends Record<string, any> {\n\t/** Identifies the intended recipient of the token */\n\taud: string;\n\t/** Identifies the issuer, or \"authorization server\" that constructs and returns the token */\n\tiss: string;\n\t/** Indicates when the authentication for the token occurred */\n\tiat: Date;\n\t/** Records the identity provider that authenticated the subject of the token */\n\tidp: string;\n\t/** Identifies the time before which the JWT can't be accepted for processing */\n\tnbf: Date;\n\t/** Identifies the expiration time on or after which the JWT can't be accepted for processing */\n\texp: Date;\n\t/** Code hash included in ID tokens when issued with an OAuth 2.0 authorization code */\n\tc_hash: string;\n\t/** Access token hash included in ID tokens when issued with an OAuth 2.0 access token */\n\tat_hash: string;\n\t/** Internal claim used to record data for token reuse */\n\taio: string;\n\t/** The primary username that represents the user */\n\tpreferred_username: string;\n\t/** User's email address */\n\temail: string;\n\t/** Human-readable value that identifies the subject of the token */\n\tname: string;\n\t/** Matches the parameter included in the original authorize request */\n\tnonce: string;\n\t/** User's profile picture */\n\tpicture: string;\n\t/** Immutable identifier for the user account */\n\toid: string;\n\t/** Set of roles assigned to the user */\n\troles: string[];\n\t/** Internal claim used to revalidate tokens */\n\trh: string;\n\t/** Subject identifier - unique to application ID */\n\tsub: string;\n\t/** Tenant ID the user is signing in to */\n\ttid: string;\n\t/** Unique identifier for a session */\n\tsid: string;\n\t/** Token identifier claim */\n\tuti: string;\n\t/** Indicates if user is in at least one group */\n\thasgroups: boolean;\n\t/** User account status in tenant (0 = member, 1 = guest) */\n\tacct: 0 | 1;\n\t/** Auth Context IDs */\n\tacrs: string;\n\t/** Time when the user last authenticated */\n\tauth_time: Date;\n\t/** User's country/region */\n\tctry: string;\n\t/** IP address of requesting client when inside VNET */\n\tfwd: string;\n\t/** Group claims */\n\tgroups: string;\n\t/** Login hint for SSO */\n\tlogin_hint: string;\n\t/** Resource tenant's country/region */\n\ttenant_ctry: string;\n\t/** Region of the resource tenant */\n\ttenant_region_scope: string;\n\t/** UserPrincipalName */\n\tupn: string;\n\t/** User's verified primary email addresses */\n\tverified_primary_email: string[];\n\t/** User's verified secondary email addresses */\n\tverified_secondary_email: string[];\n\t/** Whether the user's email is verified (optional claim, must be configured in app registration) */\n\temail_verified?: boolean | undefined;\n\t/** VNET specifier information */\n\tvnet: string;\n\t/** Client Capabilities */\n\txms_cc: string;\n\t/** Whether user's email domain is verified */\n\txms_edov: boolean;\n\t/** Preferred data location for Multi-Geo tenants */\n\txms_pdl: string;\n\t/** User preferred language */\n\txms_pl: string;\n\t/** Tenant preferred language */\n\txms_tpl: string;\n\t/** Zero-touch Deployment ID */\n\tztdid: string;\n\t/** IP Address */\n\tipaddr: string;\n\t/** On-premises Security Identifier */\n\tonprem_sid: string;\n\t/** Password Expiration Time */\n\tpwd_exp: number;\n\t/** Change Password URL */\n\tpwd_url: string;\n\t/** Inside Corporate Network flag */\n\tin_corp: string;\n\t/** User's family name/surname */\n\tfamily_name: string;\n\t/** User's given/first name */\n\tgiven_name: string;\n}\n\nexport interface MicrosoftOptions\n\textends ProviderOptions<MicrosoftEntraIDProfile> {\n\tclientId: string;\n\t/**\n\t * The tenant ID of the Microsoft account\n\t * @default \"common\"\n\t */\n\ttenantId?: string | undefined;\n\t/**\n\t * The authentication authority URL. Use the default \"https://login.microsoftonline.com\" for standard Entra ID or \"https://<tenant-id>.ciamlogin.com\" for CIAM scenarios.\n\t * @default \"https://login.microsoftonline.com\"\n\t */\n\tauthority?: string | undefined;\n\t/**\n\t * The size of the profile photo\n\t * @default 48\n\t */\n\tprofilePhotoSize?:\n\t\t| (48 | 64 | 96 | 120 | 240 | 360 | 432 | 504 | 648)\n\t\t| undefined;\n\t/**\n\t * Disable profile photo\n\t */\n\tdisableProfilePhoto?: boolean | undefined;\n}\n\nexport const microsoft = (options: MicrosoftOptions) => {\n\tconst tenant = options.tenantId || \"common\";\n\tconst authority = options.authority || \"https://login.microsoftonline.com\";\n\tconst authorizationEndpoint = `${authority}/${tenant}/oauth2/v2.0/authorize`;\n\tconst tokenEndpoint = `${authority}/${tenant}/oauth2/v2.0/token`;\n\treturn {\n\t\tid: \"microsoft\",\n\t\tname: \"Microsoft EntraID\",\n\t\tcreateAuthorizationURL(data) {\n\t\t\tconst scopes = options.disableDefaultScope\n\t\t\t\t? []\n\t\t\t\t: [\"openid\", \"profile\", \"email\", \"User.Read\", \"offline_access\"];\n\t\t\tif (options.scope) scopes.push(...options.scope);\n\t\t\tif (data.scopes) scopes.push(...data.scopes);\n\t\t\treturn createAuthorizationURL({\n\t\t\t\tid: \"microsoft\",\n\t\t\t\toptions,\n\t\t\t\tauthorizationEndpoint,\n\t\t\t\tstate: data.state,\n\t\t\t\tcodeVerifier: data.codeVerifier,\n\t\t\t\tscopes,\n\t\t\t\tredirectURI: data.redirectURI,\n\t\t\t\tprompt: options.prompt,\n\t\t\t\tloginHint: data.loginHint,\n\t\t\t});\n\t\t},\n\t\tvalidateAuthorizationCode({ code, codeVerifier, redirectURI }) {\n\t\t\treturn validateAuthorizationCode({\n\t\t\t\tcode,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI,\n\t\t\t\toptions,\n\t\t\t\ttokenEndpoint,\n\t\t\t});\n\t\t},\n\t\tasync getUserInfo(token) {\n\t\t\tif (options.getUserInfo) {\n\t\t\t\treturn options.getUserInfo(token);\n\t\t\t}\n\t\t\tif (!token.idToken) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst user = decodeJwt(token.idToken) as MicrosoftEntraIDProfile;\n\t\t\tconst profilePhotoSize = options.profilePhotoSize || 48;\n\t\t\tawait betterFetch<ArrayBuffer>(\n\t\t\t\t`https://graph.microsoft.com/v1.0/me/photos/${profilePhotoSize}x${profilePhotoSize}/$value`,\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAuthorization: `Bearer ${token.accessToken}`,\n\t\t\t\t\t},\n\t\t\t\t\tasync onResponse(context) {\n\t\t\t\t\t\tif (options.disableProfilePhoto || !context.response.ok) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst response = context.response.clone();\n\t\t\t\t\t\t\tconst pictureBuffer = await response.arrayBuffer();\n\t\t\t\t\t\t\tconst pictureBase64 = base64.encode(pictureBuffer);\n\t\t\t\t\t\t\tuser.picture = `data:image/jpeg;base64, ${pictureBase64}`;\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\te && typeof e === \"object\" && \"name\" in e\n\t\t\t\t\t\t\t\t\t? (e.name as string)\n\t\t\t\t\t\t\t\t\t: \"\",\n\t\t\t\t\t\t\t\te,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst userMap = await options.mapProfileToUser?.(user);\n\t\t\t// Microsoft Entra ID does NOT include email_verified claim by default.\n\t\t\t// It must be configured as an optional claim in the app registration.\n\t\t\t// We default to false when not provided for security consistency.\n\t\t\t// We can also check verified_primary_email/verified_secondary_email arrays as fallback.\n\t\t\tconst emailVerified =\n\t\t\t\tuser.email_verified !== undefined\n\t\t\t\t\t? user.email_verified\n\t\t\t\t\t: user.email &&\n\t\t\t\t\t\t\t(user.verified_primary_email?.includes(user.email) ||\n\t\t\t\t\t\t\t\tuser.verified_secondary_email?.includes(user.email))\n\t\t\t\t\t\t? true\n\t\t\t\t\t\t: false;\n\t\t\treturn {\n\t\t\t\tuser: {\n\t\t\t\t\tid: user.sub,\n\t\t\t\t\tname: user.name,\n\t\t\t\t\temail: user.email,\n\t\t\t\t\timage: user.picture,\n\t\t\t\t\temailVerified,\n\t\t\t\t\t...userMap,\n\t\t\t\t},\n\t\t\t\tdata: user,\n\t\t\t};\n\t\t},\n\t\trefreshAccessToken: options.refreshAccessToken\n\t\t\t? options.refreshAccessToken\n\t\t\t: async (refreshToken) => {\n\t\t\t\t\tconst scopes = options.disableDefaultScope\n\t\t\t\t\t\t? []\n\t\t\t\t\t\t: [\"openid\", \"profile\", \"email\", \"User.Read\", \"offline_access\"];\n\t\t\t\t\tif (options.scope) scopes.push(...options.scope);\n\n\t\t\t\t\treturn refreshAccessToken({\n\t\t\t\t\t\trefreshToken,\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tclientId: options.clientId,\n\t\t\t\t\t\t\tclientSecret: options.clientSecret,\n\t\t\t\t\t\t},\n\t\t\t\t\t\textraParams: {\n\t\t\t\t\t\t\tscope: scopes.join(\" \"), // Include the scopes in request to microsoft\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttokenEndpoint,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\toptions,\n\t} satisfies OAuthProvider;\n};\n","import * as z from \"zod\";\nimport { apple } from \"./apple\";\nimport { atlassian } from \"./atlassian\";\nimport { cognito } from \"./cognito\";\nimport { discord } from \"./discord\";\nimport { dropbox } from \"./dropbox\";\nimport { facebook } from \"./facebook\";\nimport { figma } from \"./figma\";\nimport { github } from \"./github\";\nimport { gitlab } from \"./gitlab\";\nimport { google } from \"./google\";\nimport { huggingface } from \"./huggingface\";\nimport { kakao } from \"./kakao\";\nimport { kick } from \"./kick\";\nimport { line } from \"./line\";\nimport { linear } from \"./linear\";\nimport { linkedin } from \"./linkedin\";\nimport { microsoft } from \"./microsoft-entra-id\";\nimport { naver } from \"./naver\";\nimport { notion } from \"./notion\";\nimport { paybin } from \"./paybin\";\nimport { paypal } from \"./paypal\";\nimport { polar } from \"./polar\";\nimport { reddit } from \"./reddit\";\nimport { roblox } from \"./roblox\";\nimport { salesforce } from \"./salesforce\";\nimport { slack } from \"./slack\";\nimport { spotify } from \"./spotify\";\nimport { tiktok } from \"./tiktok\";\nimport { twitch } from \"./twitch\";\nimport { twitter } from \"./twitter\";\nimport { vercel } from \"./vercel\";\nimport { vk } from \"./vk\";\nimport { zoom } from \"./zoom\";\n\nexport const socialProviders = {\n\tapple,\n\tatlassian,\n\tcognito,\n\tdiscord,\n\tfacebook,\n\tfigma,\n\tgithub,\n\tmicrosoft,\n\tgoogle,\n\thuggingface,\n\tslack,\n\tspotify,\n\ttwitch,\n\ttwitter,\n\tdropbox,\n\tkick,\n\tlinear,\n\tlinkedin,\n\tgitlab,\n\ttiktok,\n\treddit,\n\troblox,\n\tsalesforce,\n\tvk,\n\tzoom,\n\tnotion,\n\tkakao,\n\tnaver,\n\tline,\n\tpaybin,\n\tpaypal,\n\tpolar,\n\tvercel,\n};\n\nexport const socialProviderList = Object.keys(socialProviders) as [\n\t\"github\",\n\t...(keyof typeof socialProviders)[],\n];\n\nexport const SocialProviderListEnum = z\n\t.enum(socialProviderList)\n\t.or(z.string()) as z.ZodType<SocialProviderList[number] | (string & {})>;\n\nexport type SocialProvider = z.infer<typeof SocialProviderListEnum>;\n\nexport type SocialProviders = {\n\t[K in SocialProviderList[number]]?: Parameters<\n\t\t(typeof socialProviders)[K]\n\t>[0] & {\n\t\tenabled?: boolean | undefined;\n\t};\n};\n\nexport * from \"./apple\";\nexport * from \"./atlassian\";\nexport * from \"./cognito\";\nexport * from \"./discord\";\nexport * from \"./dropbox\";\nexport * from \"./facebook\";\nexport * from \"./figma\";\nexport * from \"./github\";\nexport * from \"./gitlab\";\nexport * from \"./google\";\nexport * from \"./huggingface\";\nexport * from \"./kakao\";\nexport * from \"./kick\";\nexport * from \"./kick\";\nexport * from \"./line\";\nexport * from \"./linear\";\nexport * from \"./linkedin\";\nexport * from \"./linkedin\";\nexport * from \"./microsoft-entra-id\";\nexport * from \"./naver\";\nexport * from \"./notion\";\nexport * from \"./paybin\";\nexport * from \"./paypal\";\nexport * from \"./polar\";\nexport * from \"./reddit\";\nexport * from \"./roblox\";\nexport * from \"./salesforce\";\nexport * from \"./slack\";\nexport * from \"./spotify\";\nexport * from \"./tiktok\";\nexport * from \"./twitch\";\nexport * from \"./twitter\";\nexport * from \"./vercel\";\nexport * from \"./vk\";\nexport * from \"./zoom\";\n\nexport type SocialProviderList = typeof socialProviderList;\n","export type RetryCondition = (\n\tresponse: Response | null,\n) => boolean | Promise<boolean>;\n\nexport type LinearRetry = {\n\ttype: \"linear\";\n\tattempts: number;\n\tdelay: number;\n\tshouldRetry?: RetryCondition;\n};\n\nexport type ExponentialRetry = {\n\ttype: \"exponential\";\n\tattempts: number;\n\tbaseDelay: number;\n\tmaxDelay: number;\n\tshouldRetry?: RetryCondition;\n};\n\nexport type RetryOptions = LinearRetry | ExponentialRetry | number;\n\nexport interface RetryStrategy {\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean>;\n\tgetDelay(attempt: number): number;\n}\n\nclass LinearRetryStrategy implements RetryStrategy {\n\tconstructor(private options: LinearRetry) {}\n\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean> {\n\t\tif (this.options.shouldRetry) {\n\t\t\treturn Promise.resolve(\n\t\t\t\tattempt < this.options.attempts && this.options.shouldRetry(response),\n\t\t\t);\n\t\t}\n\t\treturn Promise.resolve(attempt < this.options.attempts);\n\t}\n\n\tgetDelay(): number {\n\t\treturn this.options.delay;\n\t}\n}\n\nclass ExponentialRetryStrategy implements RetryStrategy {\n\tconstructor(private options: ExponentialRetry) {}\n\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean> {\n\t\tif (this.options.shouldRetry) {\n\t\t\treturn Promise.resolve(\n\t\t\t\tattempt < this.options.attempts && this.options.shouldRetry(response),\n\t\t\t);\n\t\t}\n\t\treturn Promise.resolve(attempt < this.options.attempts);\n\t}\n\n\tgetDelay(attempt: number): number {\n\t\tconst delay = Math.min(\n\t\t\tthis.options.maxDelay,\n\t\t\tthis.options.baseDelay * 2 ** attempt,\n\t\t);\n\t\treturn delay;\n\t}\n}\n\nexport function createRetryStrategy(options: RetryOptions): RetryStrategy {\n\tif (typeof options === \"number\") {\n\t\treturn new LinearRetryStrategy({\n\t\t\ttype: \"linear\",\n\t\t\tattempts: options,\n\t\t\tdelay: 1000,\n\t\t});\n\t}\n\n\tswitch (options.type) {\n\t\tcase \"linear\":\n\t\t\treturn new LinearRetryStrategy(options);\n\t\tcase \"exponential\":\n\t\t\treturn new ExponentialRetryStrategy(options);\n\t\tdefault:\n\t\t\tthrow new Error(\"Invalid retry strategy\");\n\t}\n}\n","import type { StandardSchemaV1 } from \"./standard-schema\";\nimport { getAuthHeader } from \"./auth\";\nimport { methods } from \"./create-fetch\";\nimport type { BetterFetchOption, FetchEsque } from \"./types\";\n\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\n\nexport type ResponseType = \"json\" | \"text\" | \"blob\";\nexport function detectResponseType(request: Response): ResponseType {\n\tconst _contentType = request.headers.get(\"content-type\");\n\tconst textTypes = new Set([\n\t\t\"image/svg\",\n\t\t\"application/xml\",\n\t\t\"application/xhtml\",\n\t\t\"application/html\",\n\t]);\n\tif (!_contentType) {\n\t\treturn \"json\";\n\t}\n\tconst contentType = _contentType.split(\";\").shift() || \"\";\n\tif (JSON_RE.test(contentType)) {\n\t\treturn \"json\";\n\t}\n\tif (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\treturn \"blob\";\n}\n\nexport function isJSONParsable(value: any) {\n\ttry {\n\t\tJSON.parse(value);\n\t\treturn true;\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\n//https://github.com/unjs/ofetch/blob/main/src/utils.ts\nexport function isJSONSerializable(value: any) {\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n\t\treturn true;\n\t}\n\tif (t !== \"object\") {\n\t\treturn false;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tif (value.buffer) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t(value.constructor && value.constructor.name === \"Object\") ||\n\t\ttypeof value.toJSON === \"function\"\n\t);\n}\n\nexport function jsonParse(text: string) {\n\ttry {\n\t\treturn JSON.parse(text);\n\t} catch (error) {\n\t\treturn text;\n\t}\n}\n\nexport function isFunction(value: any): value is () => any {\n\treturn typeof value === \"function\";\n}\n\nexport function getFetch(options?: BetterFetchOption): FetchEsque {\n\tif (options?.customFetchImpl) {\n\t\treturn options.customFetchImpl;\n\t}\n\tif (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n\t\treturn globalThis.fetch;\n\t}\n\tif (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n\t\treturn window.fetch;\n\t}\n\tthrow new Error(\"No fetch implementation found\");\n}\n\nexport function isPayloadMethod(method?: string) {\n\tif (!method) {\n\t\treturn false;\n\t}\n\tconst payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\treturn payloadMethod.includes(method.toUpperCase());\n}\n\nexport function isRouteMethod(method?: string) {\n\tconst routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\tif (!method) {\n\t\treturn false;\n\t}\n\treturn routeMethod.includes(method.toUpperCase());\n}\n\nexport async function getHeaders(opts?: BetterFetchOption) {\n\tconst headers = new Headers(opts?.headers);\n\tconst authHeader = await getAuthHeader(opts);\n\tfor (const [key, value] of Object.entries(authHeader || {})) {\n\t\theaders.set(key, value);\n\t}\n\tif (!headers.has(\"content-type\")) {\n\t\tconst t = detectContentType(opts?.body);\n\t\tif (t) {\n\t\t\theaders.set(\"content-type\", t);\n\t\t}\n\t}\n\n\treturn headers;\n}\n\nexport function getURL(url: string, options?: BetterFetchOption) {\n\tif (url.startsWith(\"@\")) {\n\t\tconst m = url.toString().split(\"@\")[1].split(\"/\")[0];\n\t\tif (methods.includes(m)) {\n\t\t\turl = url.replace(`@${m}/`, \"/\");\n\t\t}\n\t}\n\tlet _url: string | URL;\n\ttry {\n\t\tif (url.startsWith(\"http\")) {\n\t\t\t_url = url;\n\t\t} else {\n\t\t\tlet baseURL = options?.baseURL;\n\t\t\tif (baseURL && !baseURL?.endsWith(\"/\")) {\n\t\t\t\tbaseURL = baseURL + \"/\";\n\t\t\t}\n\t\t\tif (url.startsWith(\"/\")) {\n\t\t\t\t_url = new URL(url.substring(1), baseURL);\n\t\t\t} else {\n\t\t\t\t_url = new URL(url, options?.baseURL);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tif (!options?.baseURL) {\n\t\t\t\tthrow TypeError(\n\t\t\t\t\t`Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow TypeError(\n\t\t\t\t`Invalid URL ${url}. Please validate that you are passing the correct input.`,\n\t\t\t);\n\t\t}\n\t\tthrow e;\n\t}\n\n\t/**\n\t * Dynamic Parameters.\n\t */\n\tif (options?.params) {\n\t\tif (Array.isArray(options?.params)) {\n\t\t\tconst params = options?.params\n\t\t\t\t? Array.isArray(options.params)\n\t\t\t\t\t? `/${options.params.join(\"/\")}`\n\t\t\t\t\t: `/${Object.values(options.params).join(\"/\")}`\n\t\t\t\t: \"\";\n\t\t\t_url = _url.toString().split(\"/:\")[0];\n\t\t\t_url = `${_url.toString()}${params}`;\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(options?.params)) {\n\t\t\t\t_url = _url.toString().replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\tconst __url = new URL(_url);\n\t/**\n\t * Query Parameters\n\t */\n\tconst queryParams = options?.query;\n\tif (queryParams) {\n\t\tfor (const [key, value] of Object.entries(queryParams)) {\n\t\t\t__url.searchParams.append(key, String(value));\n\t\t}\n\t}\n\treturn __url;\n}\n\nexport function detectContentType(body: any) {\n\tif (isJSONSerializable(body)) {\n\t\treturn \"application/json\";\n\t}\n\n\treturn null;\n}\n\nexport function getBody(options?: BetterFetchOption) {\n\tif (!options?.body) {\n\t\treturn null;\n\t}\n\tconst headers = new Headers(options?.headers);\n\tif (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n\t\tfor (const [key, value] of Object.entries(options?.body)) {\n\t\t\tif (value instanceof Date) {\n\t\t\t\toptions.body[key] = value.toISOString();\n\t\t\t}\n\t\t}\n\t\treturn JSON.stringify(options.body);\n\t}\n\n\tif (\n\t\theaders.has(\"content-type\") &&\n\t\theaders.get(\"content-type\") === \"application/x-www-form-urlencoded\"\n\t) {\n\t\tif (isJSONSerializable(options.body)) {\n\t\t\treturn new URLSearchParams(options.body).toString();\n\t\t}\n\t\treturn options.body;\n\t}\n\n\treturn options.body;\n}\n\nexport function getMethod(url: string, options?: BetterFetchOption) {\n\tif (options?.method) {\n\t\treturn options.method.toUpperCase();\n\t}\n\tif (url.startsWith(\"@\")) {\n\t\tconst pMethod = url.split(\"@\")[1]?.split(\"/\")[0];\n\t\tif (!methods.includes(pMethod)) {\n\t\t\treturn options?.body ? \"POST\" : \"GET\";\n\t\t}\n\t\treturn pMethod.toUpperCase();\n\t}\n\treturn options?.body ? \"POST\" : \"GET\";\n}\n\nexport function getTimeout(\n\toptions?: BetterFetchOption,\n\tcontroller?: AbortController,\n) {\n\tlet abortTimeout: ReturnType<typeof setTimeout> | undefined;\n\tif (!options?.signal && options?.timeout) {\n\t\tabortTimeout = setTimeout(() => controller?.abort(), options?.timeout);\n\t}\n\treturn {\n\t\tabortTimeout,\n\t\tclearTimeout: () => {\n\t\t\tif (abortTimeout) {\n\t\t\t\tclearTimeout(abortTimeout);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport function bodyParser(data: any, responseType: ResponseType) {\n\tif (responseType === \"json\") {\n\t\treturn JSON.parse(data);\n\t}\n\treturn data;\n}\n\nexport class ValidationError extends Error {\n\tpublic readonly issues: ReadonlyArray<StandardSchemaV1.Issue>;\n\n\tconstructor(issues: ReadonlyArray<StandardSchemaV1.Issue>, message?: string) {\n\t\t// Default message fallback in case one isn't supplied.\n\t\tsuper(message || JSON.stringify(issues, null, 2));\n\t\tthis.issues = issues;\n\n\t\t// Set the prototype explicitly to ensure that instanceof works correctly.\n\t\tObject.setPrototypeOf(this, ValidationError.prototype);\n\t}\n}\n\nexport async function parseStandardSchema<TSchema extends StandardSchemaV1>(\n\tschema: TSchema,\n\tinput: StandardSchemaV1.InferInput<TSchema>,\n): Promise<StandardSchemaV1.InferOutput<TSchema>> {\n\tconst result = await schema[\"~standard\"].validate(input);\n\n\tif (result.issues) {\n\t\tthrow new ValidationError(result.issues);\n\t}\n\treturn result.value;\n}\n","import type { PackageJson } from \"type-fest\";\n\nlet packageJSONCache: PackageJson | undefined;\n\nasync function readRootPackageJson() {\n\tif (packageJSONCache) return packageJSONCache;\n\ttry {\n\t\tconst cwd =\n\t\t\ttypeof process !== \"undefined\" && typeof process.cwd === \"function\"\n\t\t\t\t? process.cwd()\n\t\t\t\t: \"\";\n\t\tif (!cwd) return undefined;\n\t\t// Lazily import Node built-ins only when available (Node/Bun/Deno) and\n\t\t// avoid static analyzer/bundler resolution by obfuscating module names\n\t\tconst importRuntime = (m: string) =>\n\t\t\t(Function(\"mm\", \"return import(mm)\") as any)(m);\n\t\tconst [{ default: fs }, { default: path }] = await Promise.all([\n\t\t\timportRuntime(\"fs/promises\"),\n\t\t\timportRuntime(\"path\"),\n\t\t]);\n\t\tconst raw = await fs.readFile(path.join(cwd, \"package.json\"), \"utf-8\");\n\t\tpackageJSONCache = JSON.parse(raw);\n\t\treturn packageJSONCache as PackageJson;\n\t} catch {}\n\treturn undefined;\n}\n\nexport async function getPackageVersion(pkg: string) {\n\tif (packageJSONCache) {\n\t\treturn (packageJSONCache.dependencies?.[pkg] ||\n\t\t\tpackageJSONCache.devDependencies?.[pkg] ||\n\t\t\tpackageJSONCache.peerDependencies?.[pkg]) as string | undefined;\n\t}\n\n\ttry {\n\t\tconst cwd =\n\t\t\ttypeof process !== \"undefined\" && typeof process.cwd === \"function\"\n\t\t\t\t? process.cwd()\n\t\t\t\t: \"\";\n\t\tif (!cwd) throw new Error(\"no-cwd\");\n\t\tconst importRuntime = (m: string) =>\n\t\t\t(Function(\"mm\", \"return import(mm)\") as any)(m);\n\t\tconst [{ default: fs }, { default: path }] = await Promise.all([\n\t\t\timportRuntime(\"fs/promises\"),\n\t\t\timportRuntime(\"path\"),\n\t\t]);\n\t\tconst pkgJsonPath = path.join(cwd, \"node_modules\", pkg, \"package.json\");\n\t\tconst raw = await fs.readFile(pkgJsonPath, \"utf-8\");\n\t\tconst json = JSON.parse(raw);\n\t\tconst resolved =\n\t\t\t(json.version as string) ||\n\t\t\t(await getVersionFromLocalPackageJson(pkg)) ||\n\t\t\tundefined;\n\t\treturn resolved;\n\t} catch {}\n\n\tconst fromRoot = await getVersionFromLocalPackageJson(pkg);\n\treturn fromRoot;\n}\n\nasync function getVersionFromLocalPackageJson(pkg: string) {\n\tconst json = await readRootPackageJson();\n\tif (!json) return undefined;\n\tconst allDeps = {\n\t\t...json.dependencies,\n\t\t...json.devDependencies,\n\t\t...json.peerDependencies,\n\t} as Record<string, string | undefined>;\n\treturn allDeps[pkg];\n}\n\nexport async function getNameFromLocalPackageJson() {\n\tconst json = await readRootPackageJson();\n\treturn json?.name as string | undefined;\n}\n","import type { DetectionInfo } from \"../types\";\nimport { getPackageVersion } from \"../utils/package-json\";\n\nconst DATABASES: Record<string, string> = {\n\tpg: \"postgresql\",\n\tmysql: \"mysql\",\n\tmariadb: \"mariadb\",\n\tsqlite3: \"sqlite\",\n\t\"better-sqlite3\": \"sqlite\",\n\t\"@prisma/client\": \"prisma\",\n\tmongoose: \"mongodb\",\n\tmongodb: \"mongodb\",\n\t\"drizzle-orm\": \"drizzle\",\n};\n\nexport async function detectDatabase(): Promise<DetectionInfo | undefined> {\n\tfor (const [pkg, name] of Object.entries(DATABASES)) {\n\t\tconst version = await getPackageVersion(pkg);\n\t\tif (version) return { name, version };\n\t}\n\treturn undefined;\n}\n","import { getPackageVersion } from \"../utils/package-json\";\n\nconst FRAMEWORKS: Record<string, string> = {\n\tnext: \"next\",\n\tnuxt: \"nuxt\",\n\t\"@remix-run/server-runtime\": \"remix\",\n\tastro: \"astro\",\n\t\"@sveltejs/kit\": \"sveltekit\",\n\t\"solid-start\": \"solid-start\",\n\t\"tanstack-start\": \"tanstack-start\",\n\thono: \"hono\",\n\texpress: \"express\",\n\telysia: \"elysia\",\n\texpo: \"expo\",\n};\n\nexport async function detectFramework() {\n\tfor (const [pkg, name] of Object.entries(FRAMEWORKS)) {\n\t\tconst version = await getPackageVersion(pkg);\n\t\tif (version) return { name, version };\n\t}\n\treturn undefined;\n}\n","// https://github.com/zkochan/packages/blob/main/which-pm-runs/index.js\nimport { env } from \"@better-auth/core/env\";\n\nexport function detectPackageManager() {\n\tconst userAgent = env.npm_config_user_agent;\n\tif (!userAgent) {\n\t\treturn undefined;\n\t}\n\n\tconst pmSpec = userAgent.split(\" \")[0]!;\n\tconst separatorPos = pmSpec.lastIndexOf(\"/\");\n\tconst name = pmSpec.substring(0, separatorPos);\n\n\treturn {\n\t\tname: name === \"npminstall\" ? \"cnpm\" : name,\n\t\tversion: pmSpec.substring(separatorPos + 1),\n\t};\n}\n","export const importRuntime = <T>(m: string): Promise<T> => {\n\treturn (Function(\"mm\", \"return import(mm)\") as any)(m);\n};\n","import { env } from \"@better-auth/core/env\";\nimport { importRuntime } from \"../utils/import-util\";\n\nfunction getVendor() {\n\tconst hasAny = (...keys: string[]) =>\n\t\tkeys.some((k) => Boolean((env as any)[k]));\n\n\tif (\n\t\thasAny(\"CF_PAGES\", \"CF_PAGES_URL\", \"CF_ACCOUNT_ID\") ||\n\t\t(typeof navigator !== \"undefined\" &&\n\t\t\tnavigator.userAgent === \"Cloudflare-Workers\")\n\t) {\n\t\treturn \"cloudflare\";\n\t}\n\n\tif (hasAny(\"VERCEL\", \"VERCEL_URL\", \"VERCEL_ENV\")) return \"vercel\";\n\n\tif (hasAny(\"NETLIFY\", \"NETLIFY_URL\")) return \"netlify\";\n\n\tif (\n\t\thasAny(\n\t\t\t\"RENDER\",\n\t\t\t\"RENDER_URL\",\n\t\t\t\"RENDER_INTERNAL_HOSTNAME\",\n\t\t\t\"RENDER_SERVICE_ID\",\n\t\t)\n\t) {\n\t\treturn \"render\";\n\t}\n\n\tif (\n\t\thasAny(\"AWS_LAMBDA_FUNCTION_NAME\", \"AWS_EXECUTION_ENV\", \"LAMBDA_TASK_ROOT\")\n\t) {\n\t\treturn \"aws\";\n\t}\n\n\tif (\n\t\thasAny(\n\t\t\t\"GOOGLE_CLOUD_FUNCTION_NAME\",\n\t\t\t\"GOOGLE_CLOUD_PROJECT\",\n\t\t\t\"GCP_PROJECT\",\n\t\t\t\"K_SERVICE\",\n\t\t)\n\t) {\n\t\treturn \"gcp\";\n\t}\n\n\tif (\n\t\thasAny(\n\t\t\t\"AZURE_FUNCTION_NAME\",\n\t\t\t\"FUNCTIONS_WORKER_RUNTIME\",\n\t\t\t\"WEBSITE_INSTANCE_ID\",\n\t\t\t\"WEBSITE_SITE_NAME\",\n\t\t)\n\t) {\n\t\treturn \"azure\";\n\t}\n\n\tif (hasAny(\"DENO_DEPLOYMENT_ID\", \"DENO_REGION\")) return \"deno-deploy\";\n\n\tif (hasAny(\"FLY_APP_NAME\", \"FLY_REGION\", \"FLY_ALLOC_ID\")) return \"fly-io\";\n\n\tif (hasAny(\"RAILWAY_STATIC_URL\", \"RAILWAY_ENVIRONMENT_NAME\"))\n\t\treturn \"railway\";\n\n\tif (hasAny(\"DYNO\", \"HEROKU_APP_NAME\")) return \"heroku\";\n\n\tif (hasAny(\"DO_DEPLOYMENT_ID\", \"DO_APP_NAME\", \"DIGITALOCEAN\"))\n\t\treturn \"digitalocean\";\n\n\tif (hasAny(\"KOYEB\", \"KOYEB_DEPLOYMENT_ID\", \"KOYEB_APP_NAME\")) return \"koyeb\";\n\n\treturn null;\n}\n\nexport async function detectSystemInfo() {\n\ttry {\n\t\t//check if it's cloudflare\n\t\tif (getVendor() === \"cloudflare\") return \"cloudflare\";\n\t\tconst os = await importRuntime<typeof import(\"os\")>(\"os\");\n\t\tconst cpus = os.cpus();\n\t\treturn {\n\t\t\tdeploymentVendor: getVendor(),\n\t\t\tsystemPlatform: os.platform(),\n\t\t\tsystemRelease: os.release(),\n\t\t\tsystemArchitecture: os.arch(),\n\t\t\tcpuCount: cpus.length,\n\t\t\tcpuModel: cpus.length ? cpus[0]!.model : null,\n\t\t\tcpuSpeed: cpus.length ? cpus[0]!.speed : null,\n\t\t\tmemory: os.totalmem(),\n\t\t\tisWSL: await isWsl(),\n\t\t\tisDocker: await isDocker(),\n\t\t\tisTTY:\n\t\t\t\ttypeof process !== \"undefined\" && (process as any).stdout\n\t\t\t\t\t? (process as any).stdout.isTTY\n\t\t\t\t\t: null,\n\t\t};\n\t} catch {\n\t\treturn {\n\t\t\tsystemPlatform: null,\n\t\t\tsystemRelease: null,\n\t\t\tsystemArchitecture: null,\n\t\t\tcpuCount: null,\n\t\t\tcpuModel: null,\n\t\t\tcpuSpeed: null,\n\t\t\tmemory: null,\n\t\t\tisWSL: null,\n\t\t\tisDocker: null,\n\t\t\tisTTY: null,\n\t\t};\n\t}\n}\n\nlet isDockerCached: boolean | undefined;\n\nasync function hasDockerEnv() {\n\tif (getVendor() === \"cloudflare\") return false;\n\n\ttry {\n\t\tconst fs = await importRuntime<typeof import(\"fs\")>(\"fs\");\n\t\tfs.statSync(\"/.dockerenv\");\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nasync function hasDockerCGroup() {\n\tif (getVendor() === \"cloudflare\") return false;\n\ttry {\n\t\tconst fs = await importRuntime<typeof import(\"fs\")>(\"fs\");\n\t\treturn fs.readFileSync(\"/proc/self/cgroup\", \"utf8\").includes(\"docker\");\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nasync function isDocker() {\n\tif (getVendor() === \"cloudflare\") return false;\n\n\tif (isDockerCached === undefined) {\n\t\tisDockerCached = (await hasDockerEnv()) || (await hasDockerCGroup());\n\t}\n\n\treturn isDockerCached;\n}\n\nasync function isWsl() {\n\ttry {\n\t\tif (getVendor() === \"cloudflare\") return false;\n\t\tif (typeof process === \"undefined\" || process?.platform !== \"linux\") {\n\t\t\treturn false;\n\t\t}\n\t\tconst fs = await importRuntime<typeof import(\"fs\")>(\"fs\");\n\t\tconst os = await importRuntime<typeof import(\"os\")>(\"os\");\n\t\tif (os.release().toLowerCase().includes(\"microsoft\")) {\n\t\t\tif (await isInsideContainer()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn fs\n\t\t\t.readFileSync(\"/proc/version\", \"utf8\")\n\t\t\t.toLowerCase()\n\t\t\t.includes(\"microsoft\")\n\t\t\t? !(await isInsideContainer())\n\t\t\t: false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nlet isInsideContainerCached: boolean | undefined;\n\nconst hasContainerEnv = async () => {\n\tif (getVendor() === \"cloudflare\") return false;\n\ttry {\n\t\tconst fs = await importRuntime<typeof import(\"fs\")>(\"fs\");\n\t\tfs.statSync(\"/run/.containerenv\");\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nasync function isInsideContainer() {\n\tif (isInsideContainerCached === undefined) {\n\t\tisInsideContainerCached = (await hasContainerEnv()) || (await isDocker());\n\t}\n\n\treturn isInsideContainerCached;\n}\n\nexport function isCI() {\n\treturn (\n\t\tenv.CI !== \"false\" &&\n\t\t(\"BUILD_ID\" in env || // Jenkins, Cloudbees\n\t\t\t\"BUILD_NUMBER\" in env || // Jenkins, TeamCity (fixed typo: extra space removed)\n\t\t\t\"CI\" in env || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari, Cloudflare\n\t\t\t\"CI_APP_ID\" in env || // Appflow\n\t\t\t\"CI_BUILD_ID\" in env || // Appflow\n\t\t\t\"CI_BUILD_NUMBER\" in env || // Appflow\n\t\t\t\"CI_NAME\" in env || // Codeship and others\n\t\t\t\"CONTINUOUS_INTEGRATION\" in env || // Travis CI, Cirrus CI\n\t\t\t\"RUN_ID\" in env) // TaskCluster, dsari\n\t);\n}\n","import { getEnvVar, isTest } from \"@better-auth/core/env\";\nimport { isCI } from \"./detect-system-info\";\n\nexport function detectRuntime() {\n\t// @ts-expect-error: TS doesn't know about Deno global\n\tif (typeof Deno !== \"undefined\") {\n\t\t// @ts-expect-error: TS doesn't know about Deno global\n\t\tconst denoVersion = Deno?.version?.deno ?? null;\n\t\treturn { name: \"deno\", version: denoVersion };\n\t}\n\n\tif (typeof Bun !== \"undefined\") {\n\t\tconst bunVersion = Bun?.version ?? null;\n\t\treturn { name: \"bun\", version: bunVersion };\n\t}\n\n\tif (typeof process !== \"undefined\" && process?.versions?.node) {\n\t\treturn { name: \"node\", version: process.versions.node ?? null };\n\t}\n\treturn { name: \"edge\", version: null };\n}\n\nexport function detectEnvironment() {\n\treturn getEnvVar(\"NODE_ENV\") === \"production\"\n\t\t? \"production\"\n\t\t: isCI()\n\t\t\t? \"ci\"\n\t\t\t: isTest()\n\t\t\t\t? \"test\"\n\t\t\t\t: \"development\";\n}\n","import { betterFetch } from \"../fetch\";\nimport { BetterFetchPlugin } from \"../plugins\";\nimport type { BetterFetchOption } from \"../types\";\nimport { parseStandardSchema } from \"../utils\";\nimport type { BetterFetch, CreateFetchOption } from \"./types\";\n\nexport const applySchemaPlugin = (config: CreateFetchOption) =>\n\t({\n\t\tid: \"apply-schema\",\n\t\tname: \"Apply Schema\",\n\t\tversion: \"1.0.0\",\n\t\tasync init(url, options) {\n\t\t\tconst schema =\n\t\t\t\tconfig.plugins?.find((plugin) =>\n\t\t\t\t\tplugin.schema?.config\n\t\t\t\t\t\t? url.startsWith(plugin.schema.config.baseURL || \"\") ||\n\t\t\t\t\t\t\turl.startsWith(plugin.schema.config.prefix || \"\")\n\t\t\t\t\t\t: false,\n\t\t\t\t)?.schema || config.schema;\n\t\t\tif (schema) {\n\t\t\t\tlet urlKey = url;\n\t\t\t\tif (schema.config?.prefix) {\n\t\t\t\t\tif (urlKey.startsWith(schema.config.prefix)) {\n\t\t\t\t\t\turlKey = urlKey.replace(schema.config.prefix, \"\");\n\t\t\t\t\t\tif (schema.config.baseURL) {\n\t\t\t\t\t\t\turl = url.replace(schema.config.prefix, schema.config.baseURL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (schema.config?.baseURL) {\n\t\t\t\t\tif (urlKey.startsWith(schema.config.baseURL)) {\n\t\t\t\t\t\turlKey = urlKey.replace(schema.config.baseURL, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst keySchema = schema.schema[urlKey];\n\t\t\t\tif (keySchema) {\n\t\t\t\t\tlet opts = {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tmethod: keySchema.method,\n\t\t\t\t\t\toutput: keySchema.output,\n\t\t\t\t\t};\n\t\t\t\t\tif (!options?.disableValidation) {\n\t\t\t\t\t\topts = {\n\t\t\t\t\t\t\t...opts,\n\t\t\t\t\t\t\tbody: keySchema.input\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.input, options?.body)\n\t\t\t\t\t\t\t\t: options?.body,\n\t\t\t\t\t\t\tparams: keySchema.params\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.params, options?.params)\n\t\t\t\t\t\t\t\t: options?.params,\n\t\t\t\t\t\t\tquery: keySchema.query\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.query, options?.query)\n\t\t\t\t\t\t\t\t: options?.query,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\toptions: opts,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\turl,\n\t\t\t\toptions,\n\t\t\t};\n\t\t},\n\t}) satisfies BetterFetchPlugin;\n\nexport const createFetch = <Option extends CreateFetchOption>(\n\tconfig?: Option,\n) => {\n\tasync function $fetch(url: string, options?: BetterFetchOption) {\n\t\tconst opts = {\n\t\t\t...config,\n\t\t\t...options,\n\t\t\tplugins: [...(config?.plugins || []), applySchemaPlugin(config || {}), ...(options?.plugins || [])],\n\t\t} as BetterFetchOption;\n\n\t\tif (config?.catchAllError) {\n\t\t\ttry {\n\t\t\t\treturn await betterFetch(url, opts);\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tstatus: 500,\n\t\t\t\t\t\tstatusText: \"Fetch Error\",\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n\t\t\t\t\t\terror,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn await betterFetch(url, opts);\n\t}\n\treturn $fetch as BetterFetch<Option>;\n};\n\nexport * from \"./schema\";\nexport * from \"./types\";\n","import { base64 } from \"@better-auth/utils/base64\";\nimport { createHash } from \"@better-auth/utils/hash\";\n\nexport async function hashToBase64(\n\tdata: string | ArrayBuffer,\n): Promise<string> {\n\tconst buffer = await createHash(\"SHA-256\").digest(data);\n\treturn base64.encode(buffer);\n}\n","import { createRandomStringGenerator } from \"@better-auth/utils/random\";\n\nexport const generateId = (size: number) => {\n\treturn createRandomStringGenerator(\"a-z\", \"A-Z\", \"0-9\")(size || 32);\n};\n","import { hashToBase64 } from \"./utils/hash\";\nimport { generateId } from \"./utils/id\";\nimport { getNameFromLocalPackageJson } from \"./utils/package-json\";\n\nlet projectIdCached: string | null = null;\n\nexport async function getProjectId(\n\tbaseUrl: string | undefined,\n): Promise<string> {\n\tif (projectIdCached) return projectIdCached;\n\n\tconst projectName = await getNameFromLocalPackageJson();\n\tif (projectName) {\n\t\tprojectIdCached = await hashToBase64(\n\t\t\tbaseUrl ? baseUrl + projectName : projectName,\n\t\t);\n\t\treturn projectIdCached;\n\t}\n\n\tif (baseUrl) {\n\t\tprojectIdCached = await hashToBase64(baseUrl);\n\t\treturn projectIdCached;\n\t}\n\n\tprojectIdCached = generateId(32);\n\treturn projectIdCached;\n}\n","import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { ENV, getBooleanEnvVar, isTest, logger } from \"@better-auth/core/env\";\nimport { betterFetch } from \"@better-fetch/fetch\";\nimport { getTelemetryAuthConfig } from \"./detectors/detect-auth-config\";\nimport { detectDatabase } from \"./detectors/detect-database\";\nimport { detectFramework } from \"./detectors/detect-framework\";\nimport { detectPackageManager } from \"./detectors/detect-project-info\";\nimport { detectEnvironment, detectRuntime } from \"./detectors/detect-runtime\";\nimport { detectSystemInfo } from \"./detectors/detect-system-info\";\nimport { getProjectId } from \"./project-id\";\nimport type { TelemetryContext, TelemetryEvent } from \"./types\";\nexport { getTelemetryAuthConfig };\nexport type { TelemetryEvent } from \"./types\";\n\nconst noop: (event: TelemetryEvent) => Promise<void> = async function noop() {};\n\nexport async function createTelemetry(\n\toptions: BetterAuthOptions,\n\tcontext?: TelemetryContext | undefined,\n) {\n\tconst debugEnabled =\n\t\toptions.telemetry?.debug ||\n\t\tgetBooleanEnvVar(\"BETTER_AUTH_TELEMETRY_DEBUG\", false);\n\n\tconst telemetryEndpoint = ENV.BETTER_AUTH_TELEMETRY_ENDPOINT;\n\t// Return noop if no endpoint and no custom track function\n\tif (!telemetryEndpoint && !context?.customTrack) {\n\t\treturn {\n\t\t\tpublish: noop,\n\t\t};\n\t}\n\tconst track = async (event: TelemetryEvent) => {\n\t\tif (context?.customTrack) {\n\t\t\tawait context.customTrack(event).catch(logger.error);\n\t\t} else if (telemetryEndpoint) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.info(\"telemetry event\", JSON.stringify(event, null, 2));\n\t\t\t} else {\n\t\t\t\tawait betterFetch(telemetryEndpoint, {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\tbody: event,\n\t\t\t\t}).catch(logger.error);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst isEnabled = async () => {\n\t\tconst telemetryEnabled =\n\t\t\toptions.telemetry?.enabled !== undefined\n\t\t\t\t? options.telemetry.enabled\n\t\t\t\t: false;\n\t\tconst envEnabled = getBooleanEnvVar(\"BETTER_AUTH_TELEMETRY\", false);\n\t\treturn (\n\t\t\t(envEnabled || telemetryEnabled) && (context?.skipTestCheck || !isTest())\n\t\t);\n\t};\n\n\tconst enabled = await isEnabled();\n\tlet anonymousId: string | undefined;\n\n\tif (enabled) {\n\t\tanonymousId = await getProjectId(options.baseURL);\n\n\t\tconst payload = {\n\t\t\tconfig: getTelemetryAuthConfig(options, context),\n\t\t\truntime: detectRuntime(),\n\t\t\tdatabase: await detectDatabase(),\n\t\t\tframework: await detectFramework(),\n\t\t\tenvironment: detectEnvironment(),\n\t\t\tsystemInfo: await detectSystemInfo(),\n\t\t\tpackageManager: detectPackageManager(),\n\t\t};\n\n\t\tvoid track({ type: \"init\", payload, anonymousId });\n\t}\n\n\treturn {\n\t\tpublish: async (event: TelemetryEvent) => {\n\t\t\tif (!enabled) return;\n\t\t\tif (!anonymousId) {\n\t\t\t\tanonymousId = await getProjectId(options.baseURL);\n\t\t\t}\n\t\t\tawait track({\n\t\t\t\ttype: event.type,\n\t\t\t\tpayload: event.payload,\n\t\t\t\tanonymousId,\n\t\t\t});\n\t\t},\n\t};\n}\n","import { methods } from \"./create-fetch\";\nimport type { BetterFetchOption } from \"./types\";\n\n/**\n * Normalize URL\n */\nexport function getURL(url: string, option?: BetterFetchOption) {\n\tconst { baseURL, params, query } = option || {\n\t\tquery: {},\n\t\tparams: {},\n\t\tbaseURL: \"\",\n\t};\n\tlet basePath = url.startsWith(\"http\")\n\t\t? url.split(\"/\").slice(0, 3).join(\"/\")\n\t\t: baseURL || \"\";\n\n\t/**\n\t * Remove method modifiers\n\t */\n\tif (url.startsWith(\"@\")) {\n\t\tconst m = url.toString().split(\"@\")[1].split(\"/\")[0];\n\t\tif (methods.includes(m)) {\n\t\t\turl = url.replace(`@${m}/`, \"/\");\n\t\t}\n\t}\n\n\tif (!basePath.endsWith(\"/\")) basePath += \"/\";\n\tlet [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n\tconst queryParams = new URLSearchParams(urlQuery);\n\tfor (const [key, value] of Object.entries(query || {})) {\n\t\tif (value == null) continue;\n\t\tlet serializedValue;\n\t\tif (typeof value === \"string\") {\n\t\t\tserializedValue = value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tfor (const val of value) {\n\t\t\t\tqueryParams.append(key, val);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tserializedValue = JSON.stringify(value);\n\t\t}\n\t\tqueryParams.set(key, serializedValue);\n\t}\n\tif (params) {\n\t\tif (Array.isArray(params)) {\n\t\t\tconst paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n\t\t\tfor (const [index, key] of paramPaths.entries()) {\n\t\t\t\tconst value = params[index];\n\t\t\t\tpath = path.replace(key, value);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(params)) {\n\t\t\t\tpath = path.replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\n\tpath = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n\tif (path.startsWith(\"/\")) path = path.slice(1);\n\tlet queryParamString = queryParams.toString();\n\tqueryParamString =\n\t\tqueryParamString.length > 0\n\t\t\t? `?${queryParamString}`.replace(/\\+/g, \"%20\")\n\t\t\t: \"\";\n\tif (!basePath.startsWith(\"http\")) {\n\t\treturn `${basePath}${path}${queryParamString}`;\n\t}\n\tconst _url = new URL(`${path}${queryParamString}`, basePath);\n\treturn _url;\n}\n","import { generateGenericState, parseGenericState } from \"./state.mjs\";\nimport { generateState, parseState } from \"./oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./utils/hide-metadata.mjs\";\nimport { generateId } from \"./utils/index.mjs\";\nimport { APIError } from \"./api/index.mjs\";\nimport { betterAuth } from \"./auth/full.mjs\";\nimport { getCurrentAdapter } from \"@better-auth/core/context\";\nimport { createTelemetry, getTelemetryAuthConfig } from \"@better-auth/telemetry\";\n\nexport * from \"@better-auth/core\"\n\nexport * from \"@better-auth/core/db\"\n\nexport * from \"@better-auth/core/env\"\n\nexport * from \"@better-auth/core/error\"\n\nexport * from \"@better-auth/core/oauth2\"\n\nexport * from \"@better-auth/core/utils\"\n\nexport { APIError, HIDE_METADATA, betterAuth, createTelemetry, generateGenericState, generateId, generateState, getCurrentAdapter, getTelemetryAuthConfig, parseGenericState, parseState };","import { NextRequest, NextResponse } from 'next/server';\nimport { betterAuth } from 'better-auth';\nimport { Pool, neonConfig } from '@neondatabase/serverless';\nimport ws from 'ws';\n\n// Enable WebSocket for serverless environments (Vercel)\nneonConfig.webSocketConstructor = ws;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nconst auth = betterAuth({\n  secret: process.env.BETTER_AUTH_SECRET!,\n  baseURL: process.env.NEXT_PUBLIC_BETTER_AUTH_URL || \"http://localhost:3000\",\n  database: pool,\n  session: {\n    expiresIn: 60 * 60 * 24,\n    updateAge: 60 * 60,\n  },\n  emailAndPassword: {\n    enabled: true,\n    requireEmailVerification: false,\n  },\n});\n\nexport async function GET(request: NextRequest) {\n  try {\n    return await auth.handler(request);\n  } catch (error: any) {\n    console.error('[Auth GET Error]', error);\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    return await auth.handler(request);\n  } catch (error: any) {\n    console.error('[Auth POST Error]', error);\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (\n        error,\n        _request,\n        errorContext,\n        silenceLog\n      ) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          silenceLog,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            const silenceLog = false\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              silenceLog,\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: normalizedSrcPage,\n          routeType: 'route',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n"],"names":["parsedData: Record<string, any>","key","error","body:\n\t\t\t| ({\n\t\t\t\t\tmessage?: string;\n\t\t\t\t\tcode?: string;\n\t\t\t\t\tcause?: unknown;\n\t\t\t  } & Record<string, any>)\n\t\t\t| undefined","cookies: Record<string, Cookie>","ctx","list: { token: string; expiresAt: number }[]","account","session","createdUser: User","cookieName","parsedSession","parsedUser","importRuntime","updatedUser","sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[]","account: Account | undefined","refreshToken","e: any","isInsideContainerCached: boolean | undefined","options","token","url","noop: (event: TelemetryEvent) => Promise<void>","noop","anonymousId: string | undefined","AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","addRequestMeta","getRequestMeta","getTracer","SpanKind","setManifestsSingleton","normalizeAppPath","NodeNextRequest","NodeNextResponse","NextRequestAdapter","signalFromNodeResponse","BaseServerSpan","getRevalidateReason","sendResponse","fromNodeOutgoingHttpHeaders","toNodeOutgoingHttpHeaders","getCacheControlHeader","INFINITE_CACHE","NEXT_CACHE_TAGS_HEADER","NoFallbackError","CachedRouteKind","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks","handler","req","res","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","params","nextConfig","parsedUrl","isDraftMode","prerenderManifest","routerServerContext","isOnDemandRevalidate","revalidateOnlyGenerated","resolvedPathname","clientReferenceManifest","serverActionsManifest","normalizedSrcPage","isIsr","Boolean","dynamicRoutes","routes","render404","isPrerendered","prerenderInfo","fallback","experimental","adapterPath","cacheKey","supportsDynamicResponse","isStaticGeneration","method","tracer","activeSpan","getActiveScopeSpan","context","renderOpts","authInterrupts","cacheComponents","incrementalCache","cacheLifeProfiles","cacheLife","onClose","cb","on","onAfterTaskError","undefined","onInstrumentationRequestError","_request","errorContext","silenceLog","onRequestError","sharedContext","nodeNextReq","nodeNextRes","nextReq","fromNodeNextRequest","invokeRouteModule","span","handle","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","isMinimalMode","MINIMAL_MODE","handleResponse","currentSpan","cacheEntry","responseGenerator","previousCacheEntry","setHeader","response","fetchMetrics","pendingWaitUntil","cacheTags","collectedTags","blob","headers","type","revalidate","collectedRevalidate","expire","collectedExpire","value","status","body","Buffer","from","arrayBuffer","cacheControl","err","isStale","routerKind","routePath","routeType","revalidateReason","routeKind","isFallback","isRoutePPREnabled","Error","isMiss","delete","getHeader","set","Response","withPropagatedContext","trace","spanName","SERVER","attributes"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,212]}