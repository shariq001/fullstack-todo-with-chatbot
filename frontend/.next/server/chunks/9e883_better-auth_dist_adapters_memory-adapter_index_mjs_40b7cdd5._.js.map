{"version":3,"sources":["../../../../frontend/node_modules/better-auth/src/adapters/memory-adapter/memory-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tCleanedWhere,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\n\nexport interface MemoryDB {\n\t[key: string]: any[];\n}\n\nexport interface MemoryAdapterConfig {\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n}\n\nexport const memoryAdapter = (\n\tdb: MemoryDB,\n\tconfig?: MemoryAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tsupportsArrays: true,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tconst useNumberId =\n\t\t\t\t\tprops.options.advanced?.database?.useNumberId ||\n\t\t\t\t\tprops.options.advanced?.database?.generateId === \"serial\";\n\t\t\t\tif (useNumberId && props.field === \"id\" && props.action === \"create\") {\n\t\t\t\t\treturn db[props.model]!.length + 1;\n\t\t\t\t}\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tconst clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\tconst r = await cb(adapterCreator(lazyOptions!));\n\t\t\t\t\treturn r;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Rollback changes\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key]!;\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (\n\t\t\t\trecords: any[],\n\t\t\t\tsortBy: { field: string; direction: \"asc\" | \"desc\" } | undefined,\n\t\t\t\tmodel: string,\n\t\t\t) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a: any, b: any) => {\n\t\t\t\t\tconst field = getFieldName({ model, field: sortBy.field });\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\n\t\t\t\t\tlet comparison = 0;\n\n\t\t\t\t\t// Handle null/undefined values\n\t\t\t\t\tif (aValue == null && bValue == null) {\n\t\t\t\t\t\tcomparison = 0;\n\t\t\t\t\t} else if (aValue == null) {\n\t\t\t\t\t\tcomparison = -1;\n\t\t\t\t\t} else if (bValue == null) {\n\t\t\t\t\t\tcomparison = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle string comparison\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") {\n\t\t\t\t\t\tcomparison = aValue.localeCompare(bValue);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle date comparison\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) {\n\t\t\t\t\t\tcomparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\t}\n\t\t\t\t\t// Handle numeric comparison\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") {\n\t\t\t\t\t\tcomparison = aValue - bValue;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle boolean comparison\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") {\n\t\t\t\t\t\tcomparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t\t// Fallback to string comparison\n\t\t\t\t\telse {\n\t\t\t\t\t\tcomparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfunction convertWhereClause(\n\t\t\t\twhere: CleanedWhere[],\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig,\n\t\t\t): any[] {\n\t\t\t\tconst execute = (where: CleanedWhere[], model: string) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t`[MemoryAdapter] Model ${model} not found in the DB`,\n\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(`Model ${model} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst evalClause = (record: any, clause: CleanedWhere): boolean => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\":\n\t\t\t\t\t\t\t\treturn record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\t\t\treturn record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\t\t\treturn record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\t\t\treturn record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\treturn table.filter((record: any) => {\n\t\t\t\t\t\tif (!where.length || where.length === 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet result = evalClause(record, where[0]!);\n\t\t\t\t\t\tfor (const clause of where) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") {\n\t\t\t\t\t\t\t\tresult = result || clauseResult;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult = result && clauseResult;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!join) return execute(where, model);\n\n\t\t\t\tconst baseRecords = execute(where, model);\n\n\t\t\t\t// Group results by base model and nest joined data as arrays\n\t\t\t\tconst grouped = new Map<string, any>();\n\t\t\t\t// Track seen IDs per joined model for O(1) deduplication\n\t\t\t\tconst seenIds = new Map<string, Set<string>>();\n\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested: Record<string, any> = { ...baseRecord };\n\n\t\t\t\t\t\t// Initialize joined data structures based on isUnique\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t\tnested[joinModelName] = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId)!;\n\n\t\t\t\t\t// Add joined data\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`,\n\t\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter(\n\t\t\t\t\t\t\t(joinRecord: any) =>\n\t\t\t\t\t\t\t\tjoinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from],\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t// For unique relationships, store a single object (or null)\n\t\t\t\t\t\t\tnestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-unique relationships, store array with limit\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`)!;\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tconst useNumberId =\n\t\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdata.id = db[getModelName(model)]!.length + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tdb[model] = [];\n\t\t\t\t\t}\n\t\t\t\t\tdb[model]!.push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Return the first nested object\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\t// Without join, res is an array\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tconst record = resArray[0] || null;\n\t\t\t\t\treturn record;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where || [], model, join);\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply sorting to nested objects\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\n\t\t\t\t\t\t// Apply offset and limit\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Without join - original logic\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tlet table = applySortToRecords(resArray, sortBy, model);\n\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(offset);\n\t\t\t\t\t}\n\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(0, limit);\n\t\t\t\t\t}\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) {\n\t\t\t\t\t\tconst filteredRecords = convertWhereClause(where, model);\n\t\t\t\t\t\treturn filteredRecords.length;\n\t\t\t\t\t}\n\t\t\t\t\treturn db[model]!.length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t});\n\treturn (options: BetterAuthOptions) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n"],"names":["lazyOptions: BetterAuthOptions | null","model","where","nested: Record<string, any>"],"mappings":"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","ignoreList":[0]}