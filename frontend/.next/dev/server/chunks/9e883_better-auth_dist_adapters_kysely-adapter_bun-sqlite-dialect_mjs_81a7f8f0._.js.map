{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/adapters/kysely-adapter/bun-sqlite-dialect.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/adapters/kysely-adapter/bun-sqlite-dialect.ts"],"sourcesContent":["/**\n * @see {@link https://github.com/dylanblokhuis/kysely-bun-sqlite} - Fork of the original kysely-bun-sqlite package by @dylanblokhuis\n */\n\nimport type { Database } from \"bun:sqlite\";\nimport type {\n\tDatabaseConnection,\n\tDatabaseIntrospector,\n\tDatabaseMetadata,\n\tDatabaseMetadataOptions,\n\tDialect,\n\tDialectAdapter,\n\tDialectAdapterBase,\n\tDriver,\n\tKysely,\n\tQueryCompiler,\n\tQueryResult,\n\tSchemaMetadata,\n\tTableMetadata,\n} from \"kysely\";\nimport {\n\tCompiledQuery,\n\tDEFAULT_MIGRATION_LOCK_TABLE,\n\tDEFAULT_MIGRATION_TABLE,\n\tDefaultQueryCompiler,\n\tsql,\n} from \"kysely\";\n\nclass BunSqliteAdapter implements DialectAdapterBase {\n\tget supportsCreateIfNotExists(): boolean {\n\t\treturn true;\n\t}\n\n\tget supportsTransactionalDdl(): boolean {\n\t\treturn false;\n\t}\n\n\tget supportsReturning(): boolean {\n\t\treturn true;\n\t}\n\n\tasync acquireMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\n\tasync releaseMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\tget supportsOutput(): boolean {\n\t\treturn true;\n\t}\n}\n\n/**\n * Config for the SQLite dialect.\n */\nexport interface BunSqliteDialectConfig {\n\t/**\n\t * An sqlite Database instance or a function that returns one.\n\t */\n\tdatabase: Database;\n\n\t/**\n\t * Called once when the first query is executed.\n\t */\n\tonCreateConnection?:\n\t\t| ((connection: DatabaseConnection) => Promise<void>)\n\t\t| undefined;\n}\n\nclass BunSqliteDriver implements Driver {\n\treadonly #config: BunSqliteDialectConfig;\n\treadonly #connectionMutex = new ConnectionMutex();\n\n\t#db?: Database;\n\t#connection?: DatabaseConnection;\n\n\tconstructor(config: BunSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tasync init(): Promise<void> {\n\t\tthis.#db = this.#config.database;\n\n\t\tthis.#connection = new BunSqliteConnection(this.#db);\n\n\t\tif (this.#config.onCreateConnection) {\n\t\t\tawait this.#config.onCreateConnection(this.#connection);\n\t\t}\n\t}\n\n\tasync acquireConnection(): Promise<DatabaseConnection> {\n\t\t// SQLite only has one single connection. We use a mutex here to wait\n\t\t// until the single connection has been released.\n\t\tawait this.#connectionMutex.lock();\n\t\treturn this.#connection!;\n\t}\n\n\tasync beginTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"begin\"));\n\t}\n\n\tasync commitTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"commit\"));\n\t}\n\n\tasync rollbackTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"rollback\"));\n\t}\n\n\tasync releaseConnection(): Promise<void> {\n\t\tthis.#connectionMutex.unlock();\n\t}\n\n\tasync destroy(): Promise<void> {\n\t\tthis.#db?.close();\n\t}\n}\n\nclass BunSqliteConnection implements DatabaseConnection {\n\treadonly #db: Database;\n\n\tconstructor(db: Database) {\n\t\tthis.#db = db;\n\t}\n\n\texecuteQuery<O>(compiledQuery: CompiledQuery): Promise<QueryResult<O>> {\n\t\tconst { sql, parameters } = compiledQuery;\n\t\tconst stmt = this.#db.prepare(sql);\n\n\t\treturn Promise.resolve({\n\t\t\trows: stmt.all(parameters as any) as O[],\n\t\t});\n\t}\n\n\tasync *streamQuery() {\n\t\tthrow new Error(\"Streaming query is not supported by SQLite driver.\");\n\t}\n}\n\nclass ConnectionMutex {\n\t#promise?: Promise<void>;\n\t#resolve?: () => void;\n\n\tasync lock(): Promise<void> {\n\t\twhile (await this.#promise) {\n\t\t\tawait this.#promise;\n\t\t}\n\n\t\tthis.#promise = new Promise((resolve) => {\n\t\t\tthis.#resolve = resolve;\n\t\t});\n\t}\n\n\tunlock(): void {\n\t\tconst resolve = this.#resolve;\n\n\t\tthis.#promise = undefined;\n\t\tthis.#resolve = undefined;\n\n\t\tresolve?.();\n\t}\n}\n\nclass BunSqliteIntrospector implements DatabaseIntrospector {\n\treadonly #db: Kysely<unknown>;\n\n\tconstructor(db: Kysely<unknown>) {\n\t\tthis.#db = db;\n\t}\n\n\tasync getSchemas(): Promise<SchemaMetadata[]> {\n\t\t// Sqlite doesn't support schemas.\n\t\treturn [];\n\t}\n\n\tasync getTables(\n\t\toptions: DatabaseMetadataOptions = { withInternalKyselyTables: false },\n\t): Promise<TableMetadata[]> {\n\t\tlet query = this.#db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_schema\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"type\", \"=\", \"table\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"not like\", \"sqlite_%\")\n\t\t\t.select(\"name\")\n\t\t\t.$castTo<{ name: string }>();\n\n\t\tif (!options.withInternalKyselyTables) {\n\t\t\tquery = query\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_TABLE)\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_LOCK_TABLE);\n\t\t}\n\n\t\tconst tables = await query.execute();\n\t\treturn Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));\n\t}\n\n\tasync getMetadata(\n\t\toptions?: DatabaseMetadataOptions | undefined,\n\t): Promise<DatabaseMetadata> {\n\t\treturn {\n\t\t\ttables: await this.getTables(options),\n\t\t};\n\t}\n\n\tasync #getTableMetadata(table: string): Promise<TableMetadata> {\n\t\tconst db = this.#db;\n\n\t\t// Get the SQL that was used to create the table.\n\t\tconst createSql = await db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_master\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"=\", table)\n\t\t\t.select(\"sql\")\n\t\t\t.$castTo<{ sql: string | undefined }>()\n\t\t\t.execute();\n\n\t\t// Try to find the name of the column that has `autoincrement` ðŸ¤¦\n\t\tconst autoIncrementCol = createSql[0]?.sql\n\t\t\t?.split(/[\\(\\),]/)\n\t\t\t?.find((it) => it.toLowerCase().includes(\"autoincrement\"))\n\t\t\t?.split(/\\s+/)?.[0]\n\t\t\t?.replace(/[\"`]/g, \"\");\n\n\t\tconst columns = await db\n\t\t\t.selectFrom(\n\t\t\t\tsql<{\n\t\t\t\t\tname: string;\n\t\t\t\t\ttype: string;\n\t\t\t\t\tnotnull: 0 | 1;\n\t\t\t\t\tdflt_value: any;\n\t\t\t\t}>`pragma_table_info(${table})`.as(\"table_info\"),\n\t\t\t)\n\t\t\t.select([\"name\", \"type\", \"notnull\", \"dflt_value\"])\n\t\t\t.execute();\n\n\t\treturn {\n\t\t\tname: table,\n\t\t\tcolumns: columns.map((col) => ({\n\t\t\t\tname: col.name,\n\t\t\t\tdataType: col.type,\n\t\t\t\tisNullable: !col.notnull,\n\t\t\t\tisAutoIncrementing: col.name === autoIncrementCol,\n\t\t\t\thasDefaultValue: col.dflt_value != null,\n\t\t\t})),\n\t\t\tisView: true,\n\t\t};\n\t}\n}\n\nclass BunSqliteQueryCompiler extends DefaultQueryCompiler {\n\tprotected override getCurrentParameterPlaceholder() {\n\t\treturn \"?\";\n\t}\n\n\tprotected override getLeftIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getRightIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getAutoIncrement() {\n\t\treturn \"autoincrement\";\n\t}\n}\n\nexport class BunSqliteDialect implements Dialect {\n\treadonly #config: BunSqliteDialectConfig;\n\n\tconstructor(config: BunSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tcreateDriver(): Driver {\n\t\treturn new BunSqliteDriver(this.#config);\n\t}\n\n\tcreateQueryCompiler(): QueryCompiler {\n\t\treturn new BunSqliteQueryCompiler();\n\t}\n\n\tcreateAdapter(): DialectAdapter {\n\t\treturn new BunSqliteAdapter();\n\t}\n\n\tcreateIntrospector(db: Kysely<any>): DatabaseIntrospector {\n\t\treturn new BunSqliteIntrospector(db);\n\t}\n}\n"],"names":["#config","#connectionMutex","#db","#connection","sql","#promise","#resolve","#getTableMetadata"],"mappings":"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"}}]
}