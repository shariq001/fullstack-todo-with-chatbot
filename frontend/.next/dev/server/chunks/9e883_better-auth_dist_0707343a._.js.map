{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/crypto/random.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/crypto/random.ts"],"sourcesContent":["import { createRandomStringGenerator } from \"@better-auth/utils/random\";\nexport const generateRandomString = createRandomStringGenerator(\n\t\"a-z\",\n\t\"0-9\",\n\t\"A-Z\",\n\t\"-_\",\n);\n"],"names":[],"mappings":";;;;;;;AACA,MAAa,2BAAuB,yMAAA,EACnC,OACA,OACA,OACA,KACA"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/crypto/buffer.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/crypto/buffer.ts"],"sourcesContent":["/**\n * Compare two buffers in constant time.\n */\nexport function constantTimeEqual(\n\ta: ArrayBuffer | Uint8Array | string,\n\tb: ArrayBuffer | Uint8Array | string,\n): boolean {\n\tif (typeof a === \"string\") {\n\t\ta = new TextEncoder().encode(a);\n\t}\n\tif (typeof b === \"string\") {\n\t\tb = new TextEncoder().encode(b);\n\t}\n\tconst aBuffer = new Uint8Array(a);\n\tconst bBuffer = new Uint8Array(b);\n\tlet c = aBuffer.length ^ bBuffer.length;\n\tconst length = Math.max(aBuffer.length, bBuffer.length);\n\tfor (let i = 0; i < length; i++) {\n\t\tc |=\n\t\t\t(i < aBuffer.length ? aBuffer[i]! : 0) ^\n\t\t\t(i < bBuffer.length ? bBuffer[i]! : 0);\n\t}\n\treturn c === 0;\n}\n"],"names":[],"mappings":";;;;;;;GAGA,SAAgB,kBACf,CAAA,EACA,CAAA,EACU;IACV,IAAI,OAAO,MAAM,SAChB,CAAA,IAAI,IAAI,aAAa,CAAC,MAAA,CAAO,EAAE;IAEhC,IAAI,OAAO,MAAM,SAChB,CAAA,IAAI,IAAI,aAAa,CAAC,MAAA,CAAO,EAAE;IAEhC,MAAM,UAAU,IAAI,WAAW,EAAE;IACjC,MAAM,UAAU,IAAI,WAAW,EAAE;IACjC,IAAI,IAAI,QAAQ,MAAA,GAAS,QAAQ,MAAA;IACjC,MAAM,SAAS,KAAK,GAAA,CAAI,QAAQ,MAAA,EAAQ,QAAQ,MAAA,CAAO;IACvD,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC3B,KAAA,CACE,IAAI,QAAQ,MAAA,GAAS,OAAA,CAAQ,EAAA,GAAM,CAAA,IAAA,CACnC,IAAI,QAAQ,MAAA,GAAS,OAAA,CAAQ,EAAA,GAAM,CAAA;IAEtC,OAAO,MAAM"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/crypto/jwt.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/crypto/jwt.ts"],"sourcesContent":["import { hkdf } from \"@noble/hashes/hkdf.js\";\nimport { sha256 } from \"@noble/hashes/sha2.js\";\nimport {\n\tbase64url,\n\tcalculateJwkThumbprint,\n\tEncryptJWT,\n\tjwtDecrypt,\n\tjwtVerify,\n\tSignJWT,\n} from \"jose\";\n\nexport async function signJWT(\n\tpayload: any,\n\tsecret: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst jwt = await new SignJWT(payload)\n\t\t.setProtectedHeader({ alg: \"HS256\" })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)\n\t\t.sign(new TextEncoder().encode(secret));\n\n\treturn jwt;\n}\n\nexport async function verifyJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n): Promise<T | null> {\n\ttry {\n\t\tconst verified = await jwtVerify(token, new TextEncoder().encode(secret));\n\t\treturn verified.payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\n// \"BetterAuth.js Generated Encryption Key\"\nconst info: Uint8Array = new Uint8Array([\n\t66, 101, 116, 116, 101, 114, 65, 117, 116, 104, 46, 106, 115, 32, 71, 101,\n\t110, 101, 114, 97, 116, 101, 100, 32, 69, 110, 99, 114, 121, 112, 116, 105,\n\t111, 110, 32, 75, 101, 121,\n]);\n\nconst now = () => (Date.now() / 1000) | 0;\n\nconst alg = \"dir\";\nconst enc = \"A256CBC-HS512\"; // 64 bytes key\n\nexport async function symmetricEncodeJWT<T extends Record<string, any>>(\n\tpayload: T,\n\tsecret: string,\n\tsalt: string,\n\texpiresIn: number = 3600,\n): Promise<string> {\n\tconst encryptionSecret = hkdf(\n\t\tsha256,\n\t\tnew TextEncoder().encode(secret),\n\t\tnew TextEncoder().encode(salt),\n\t\tinfo,\n\t\t64,\n\t);\n\n\tconst thumbprint = await calculateJwkThumbprint(\n\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\"sha256\",\n\t);\n\n\treturn await new EncryptJWT(payload)\n\t\t.setProtectedHeader({ alg, enc, kid: thumbprint })\n\t\t.setIssuedAt()\n\t\t.setExpirationTime(now() + expiresIn)\n\t\t.setJti(crypto.randomUUID())\n\t\t.encrypt(encryptionSecret);\n}\n\nexport async function symmetricDecodeJWT<T = any>(\n\ttoken: string,\n\tsecret: string,\n\tsalt: string,\n): Promise<T | null> {\n\tif (!token) return null;\n\ttry {\n\t\tconst { payload } = await jwtDecrypt(\n\t\t\ttoken,\n\t\t\tasync ({ kid }) => {\n\t\t\t\tconst encryptionSecret = hkdf(\n\t\t\t\t\tsha256,\n\t\t\t\t\tnew TextEncoder().encode(secret),\n\t\t\t\t\tnew TextEncoder().encode(salt),\n\t\t\t\t\tinfo,\n\t\t\t\t\t64,\n\t\t\t\t);\n\t\t\t\tif (kid === undefined) return encryptionSecret;\n\n\t\t\t\tconst thumbprint = await calculateJwkThumbprint(\n\t\t\t\t\t{ kty: \"oct\", k: base64url.encode(encryptionSecret) },\n\t\t\t\t\t\"sha256\",\n\t\t\t\t);\n\t\t\t\tif (kid === thumbprint) return encryptionSecret;\n\n\t\t\t\tthrow new Error(\"no matching decryption secret\");\n\t\t\t},\n\t\t\t{\n\t\t\t\tclockTolerance: 15,\n\t\t\t\tkeyManagementAlgorithms: [alg],\n\t\t\t\tcontentEncryptionAlgorithms: [enc, \"A256GCM\"],\n\t\t\t},\n\t\t);\n\t\treturn payload as T;\n\t} catch {\n\t\treturn null;\n\t}\n}\n"],"names":["info: Uint8Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAWA,eAAsB,QACrB,OAAA,EACA,MAAA,EACA,YAAoB,IAAA,EACF;IAOlB,OANY,MAAM,IAAI,8KAAA,CAAQ,QAAQ,CACpC,kBAAA,CAAmB;QAAE,KAAK;IAAA,CAAS,CAAC,CACpC,WAAA,EAAa,CACb,iBAAA,CAAkB,KAAK,KAAA,CAAM,KAAK,GAAA,EAAK,GAAG,IAAK,GAAG,UAAU,CAC5D,IAAA,CAAK,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,CAAC;;AAKzC,eAAsB,UACrB,KAAA,EACA,MAAA,EACoB;IACpB,IAAI;QAEH,OAAA,CADiB,UAAM,kLAAA,EAAU,OAAO,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,CAAC,EACzD,OAAA;aACT;QACP,OAAO;;;AAKT,MAAMA,OAAmB,IAAI,WAAW;IACvC;IAAI;IAAK;IAAK;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAI;IAAI;IACtE;IAAK;IAAK;IAAK;IAAI;IAAK;IAAK;IAAK;IAAI;IAAI;IAAK;IAAI;IAAK;IAAK;IAAK;IAAK;IACvE;IAAK;IAAK;IAAI;IAAI;IAAK;CACvB,CAAC;AAEF,MAAM,MAAA,IAAa,KAAK,GAAA,EAAK,GAAG,MAAQ;AAExC,MAAM,MAAM;AACZ,MAAM,MAAM;AAEZ,eAAsB,mBACrB,OAAA,EACA,MAAA,EACA,IAAA,EACA,YAAoB,IAAA,EACF;IAClB,MAAM,uBAAmB,+JAAA,EACxB,iKAAA,EACA,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,EAChC,IAAI,aAAa,CAAC,MAAA,CAAO,KAAK,EAC9B,MACA,GACA;IAED,MAAM,aAAa,UAAM,mMAAA,EACxB;QAAE,KAAK;QAAO,GAAG,2NAAA,CAAU,MAAA,CAAO,iBAAiB;KAAE,EACrD,SACA;IAED,OAAO,MAAM,IAAI,oLAAA,CAAW,QAAQ,CAClC,kBAAA,CAAmB;QAAE;QAAK;QAAK,KAAK;KAAY,CAAC,CACjD,WAAA,EAAa,CACb,iBAAA,CAAkB,KAAK,GAAG,UAAU,CACpC,MAAA,CAAO,OAAO,UAAA,EAAY,CAAC,CAC3B,OAAA,CAAQ,iBAAiB;;AAG5B,eAAsB,mBACrB,KAAA,EACA,MAAA,EACA,IAAA,EACoB;IACpB,IAAI,CAAC,MAAO,CAAA,OAAO;IACnB,IAAI;QACH,MAAM,EAAE,OAAA,EAAA,GAAY,UAAM,oLAAA,EACzB,OACA,OAAO,EAAE,GAAA,EAAA,KAAU;YAClB,MAAM,uBAAmB,+JAAA,EACxB,iKAAA,EACA,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,EAChC,IAAI,aAAa,CAAC,MAAA,CAAO,KAAK,EAC9B,MACA,GACA;YACD,IAAI,QAAQ,KAAA,EAAW,CAAA,OAAO;YAM9B,IAAI,QAJe,UAAM,mMAAA,EACxB;gBAAE,KAAK;gBAAO,GAAG,2NAAA,CAAU,MAAA,CAAO,iBAAiB;aAAE,EACrD,SACA,CACuB,CAAA,OAAO;YAE/B,MAAM,IAAI,MAAM,gCAAgC;WAEjD;YACC,gBAAgB;YAChB,yBAAyB;gBAAC;aAAI;YAC9B,6BAA6B;gBAAC;gBAAK;aAAU;SAC7C,CACD;QACD,OAAO;aACA;QACP,OAAO"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/crypto/password.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/crypto/password.ts"],"sourcesContent":["import { BetterAuthError } from \"@better-auth/core/error\";\nimport { hex } from \"@better-auth/utils/hex\";\nimport { scryptAsync } from \"@noble/hashes/scrypt.js\";\nimport { hexToBytes } from \"@noble/hashes/utils.js\";\nimport { constantTimeEqual } from \"./buffer\";\n\nconst config = {\n\tN: 16384,\n\tr: 16,\n\tp: 1,\n\tdkLen: 64,\n};\n\nasync function generateKey(password: string, salt: string) {\n\treturn await scryptAsync(password.normalize(\"NFKC\"), salt, {\n\t\tN: config.N,\n\t\tp: config.p,\n\t\tr: config.r,\n\t\tdkLen: config.dkLen,\n\t\tmaxmem: 128 * config.N * config.r * 2,\n\t});\n}\n\nexport const hashPassword = async (password: string) => {\n\tconst salt = hex.encode(crypto.getRandomValues(new Uint8Array(16)));\n\tconst key = await generateKey(password, salt);\n\treturn `${salt}:${hex.encode(key)}`;\n};\n\nexport const verifyPassword = async ({\n\thash,\n\tpassword,\n}: {\n\thash: string;\n\tpassword: string;\n}) => {\n\tconst [salt, key] = hash.split(\":\");\n\tif (!salt || !key) {\n\t\tthrow new BetterAuthError(\"Invalid password hash\");\n\t}\n\tconst targetKey = await generateKey(password, salt!);\n\treturn constantTimeEqual(targetKey, hexToBytes(key));\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAMA,MAAM,SAAS;IACd,GAAG;IACH,GAAG;IACH,GAAG;IACH,OAAO;CACP;AAED,eAAe,YAAY,QAAA,EAAkB,IAAA,EAAc;IAC1D,OAAO,UAAM,wKAAA,EAAY,SAAS,SAAA,CAAU,OAAO,EAAE,MAAM;QAC1D,GAAG,OAAO,CAAA;QACV,GAAG,OAAO,CAAA;QACV,GAAG,OAAO,CAAA;QACV,OAAO,OAAO,KAAA;QACd,QAAQ,MAAM,OAAO,CAAA,GAAI,OAAO,CAAA,GAAI;KACpC,CAAC;;AAGH,MAAa,eAAe,OAAO,aAAqB;IACvD,MAAM,OAAO,8KAAA,CAAI,MAAA,CAAO,OAAO,eAAA,CAAgB,IAAI,WAAW,GAAG,CAAC,CAAC;IACnE,MAAM,MAAM,MAAM,YAAY,UAAU,KAAK;IAC7C,OAAO,GAAG,KAAK,CAAA,EAAG,8KAAA,CAAI,MAAA,CAAO,IAAI,EAAA;;AAGlC,MAAa,iBAAiB,OAAO,EACpC,IAAA,EACA,QAAA,EAAA,KAIK;IACL,MAAM,CAAC,MAAM,IAAA,GAAO,KAAK,KAAA,CAAM,IAAI;IACnC,IAAI,CAAC,QAAQ,CAAC,IACb,CAAA,MAAM,IAAI,oNAAA,CAAgB,wBAAwB;IAGnD,WAAO,8LAAA,EADW,MAAM,YAAY,UAAU,KAAM,MAChB,sKAAA,EAAW,IAAI,CAAC"}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/crypto/index.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/crypto/index.ts"],"sourcesContent":["import { getWebcryptoSubtle } from \"@better-auth/utils\";\nimport { createHash } from \"@better-auth/utils/hash\";\nimport { xchacha20poly1305 } from \"@noble/ciphers/chacha.js\";\nimport {\n\tbytesToHex,\n\thexToBytes,\n\tmanagedNonce,\n\tutf8ToBytes,\n} from \"@noble/ciphers/utils.js\";\n\nconst algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n\nexport type SymmetricEncryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricEncrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricEncryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = utf8ToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn bytesToHex(chacha.encrypt(dataAsBytes));\n};\n\nexport type SymmetricDecryptOptions = {\n\tkey: string;\n\tdata: string;\n};\n\nexport const symmetricDecrypt = async ({\n\tkey,\n\tdata,\n}: SymmetricDecryptOptions) => {\n\tconst keyAsBytes = await createHash(\"SHA-256\").digest(key);\n\tconst dataAsBytes = hexToBytes(data);\n\tconst chacha = managedNonce(xchacha20poly1305)(new Uint8Array(keyAsBytes));\n\treturn new TextDecoder().decode(chacha.decrypt(dataAsBytes));\n};\n\nexport const getCryptoKey = async (secret: string | BufferSource) => {\n\tconst secretBuf =\n\t\ttypeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await getWebcryptoSubtle().importKey(\n\t\t\"raw\",\n\t\tsecretBuf,\n\t\talgorithm,\n\t\tfalse,\n\t\t[\"sign\", \"verify\"],\n\t);\n};\n\nexport const makeSignature = async (\n\tvalue: string,\n\tsecret: string | BufferSource,\n): Promise<string> => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await getWebcryptoSubtle().sign(\n\t\talgorithm.name,\n\t\tkey,\n\t\tnew TextEncoder().encode(value),\n\t);\n\t// the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\n\nexport * from \"./buffer\";\nexport * from \"./jwt\";\nexport * from \"./password\";\nexport * from \"./random\";\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,MAAM,YAAY;IAAE,MAAM;IAAQ,MAAM;CAAW;AAOnD,MAAa,mBAAmB,OAAO,EACtC,GAAA,EACA,IAAA,EAAA,KAC8B;IAC9B,MAAM,aAAa,UAAM,sLAAA,EAAW,UAAU,CAAC,MAAA,CAAO,IAAI;IAC1D,MAAM,kBAAc,wKAAA,EAAY,KAAK;IAErC,WAAO,uKAAA,MADQ,yKAAA,EAAa,+KAAA,CAAkB,CAAC,IAAI,WAAW,WAAW,CAAC,CACjD,OAAA,CAAQ,YAAY,CAAC;;AAQ/C,MAAa,mBAAmB,OAAO,EACtC,GAAA,EACA,IAAA,EAAA,KAC8B;IAC9B,MAAM,aAAa,UAAM,sLAAA,EAAW,UAAU,CAAC,MAAA,CAAO,IAAI;IAC1D,MAAM,kBAAc,uKAAA,EAAW,KAAK;IACpC,MAAM,aAAS,yKAAA,EAAa,+KAAA,CAAkB,CAAC,IAAI,WAAW,WAAW,CAAC;IAC1E,OAAO,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,OAAA,CAAQ,YAAY,CAAC;;AAG7D,MAAa,eAAe,OAAO,WAAkC;IACpE,MAAM,YACL,OAAO,WAAW,WAAW,IAAI,aAAa,CAAC,MAAA,CAAO,OAAO,GAAG;IACjE,OAAO,UAAM,+LAAA,EAAoB,EAAC,SAAA,CACjC,OACA,WACA,WACA,OACA;QAAC;QAAQ;KAAS,CAClB;;AAGF,MAAa,gBAAgB,OAC5B,OACA,WACqB;IACrB,MAAM,MAAM,MAAM,aAAa,OAAO;IACtC,MAAM,YAAY,UAAM,+LAAA,EAAoB,EAAC,IAAA,CAC5C,UAAU,IAAA,EACV,KACA,IAAI,aAAa,CAAC,MAAA,CAAO,MAAM,CAC/B;IAED,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,IAAI,WAAW,UAAU,CAAC,CAAC"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/date.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/date.ts"],"sourcesContent":["export const getDate = (span: number, unit: \"sec\" | \"ms\" = \"ms\") => {\n\treturn new Date(Date.now() + (unit === \"sec\" ? span * 1000 : span));\n};\n"],"names":[],"mappings":";;;;;AAAA,MAAa,UAAA,CAAW,MAAc,OAAqB,IAAA,KAAS;IACnE,OAAO,IAAI,KAAK,KAAK,GAAA,EAAK,GAAA,CAAI,SAAS,QAAQ,OAAO,MAAO,IAAA,EAAM"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/schema.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tBetterAuthPluginDBSchema,\n\tDBFieldAttribute,\n} from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport { APIError } from \"better-call\";\nimport type { Account, Session, User } from \"../types\";\n\n// Cache for parsed schemas to avoid reparsing on every request\nconst cache = new WeakMap<\n\tBetterAuthOptions,\n\tMap<string, Record<string, DBFieldAttribute>>\n>();\n\nfunction parseOutputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t},\n) {\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = {};\n\tfor (const key in data) {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\t\tif (\n\t\t\tfield.returned === false &&\n\t\t\tkey !== \"id\" // id is always returned\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tparsedData[key] = data[key];\n\t}\n\treturn parsedData as T;\n}\n\nfunction getFields(\n\toptions: BetterAuthOptions,\n\ttable: string,\n\tmode: \"input\" | \"output\",\n) {\n\tconst cacheKey = `${table}:${mode}`;\n\tif (!cache.has(options)) {\n\t\tcache.set(options, new Map());\n\t}\n\tconst tableCache = cache.get(options)!;\n\tif (tableCache.has(cacheKey)) {\n\t\treturn tableCache.get(cacheKey)!;\n\t}\n\tconst coreSchema =\n\t\tmode === \"output\" ? (getAuthTables(options)[table]?.fields ?? {}) : {};\n\tconst additionalFields =\n\t\ttable === \"user\" || table === \"session\" || table === \"account\"\n\t\t\t? options[table]?.additionalFields\n\t\t\t: undefined;\n\tlet schema: Record<string, DBFieldAttribute> = {\n\t\t...coreSchema,\n\t\t...(additionalFields ?? {}),\n\t};\n\tfor (const plugin of options.plugins || []) {\n\t\tif (plugin.schema && plugin.schema[table]) {\n\t\t\tschema = {\n\t\t\t\t...schema,\n\t\t\t\t...plugin.schema[table].fields,\n\t\t\t};\n\t\t}\n\t}\n\ttableCache.set(cacheKey, schema);\n\treturn schema;\n}\n\nexport function parseUserOutput<T extends User>(\n\toptions: BetterAuthOptions,\n\tuser: T,\n) {\n\tconst schema = getFields(options, \"user\", \"output\");\n\treturn parseOutputData(user, { fields: schema });\n}\n\nexport function parseSessionOutput<T extends Session>(\n\toptions: BetterAuthOptions,\n\tsession: T,\n) {\n\tconst schema = getFields(options, \"session\", \"output\");\n\treturn parseOutputData(session, { fields: schema });\n}\n\nexport function parseAccountOutput<T extends Account>(\n\toptions: BetterAuthOptions,\n\taccount: T,\n) {\n\tconst schema = getFields(options, \"account\", \"output\");\n\tconst parsed = parseOutputData(account, { fields: schema });\n\t// destructuring for type inference\n\t// runtime filtering is already done by `parseOutputData`\n\tconst {\n\t\taccessToken: _accessToken,\n\t\trefreshToken: _refreshToken,\n\t\tidToken: _idToken,\n\t\taccessTokenExpiresAt: _accessTokenExpiresAt,\n\t\trefreshTokenExpiresAt: _refreshTokenExpiresAt,\n\t\tpassword: _password,\n\t\t...rest\n\t} = parsed;\n\treturn rest;\n}\n\nexport function parseInputData<T extends Record<string, any>>(\n\tdata: T,\n\tschema: {\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\taction?: (\"create\" | \"update\") | undefined;\n\t},\n) {\n\tconst action = schema.action || \"create\";\n\tconst fields = schema.fields;\n\tconst parsedData: Record<string, any> = Object.assign(\n\t\tObject.create(null),\n\t\tnull,\n\t);\n\tfor (const key in fields) {\n\t\tif (key in data) {\n\t\t\tif (fields[key]!.input === false) {\n\t\t\t\tif (fields[key]!.defaultValue !== undefined) {\n\t\t\t\t\tif (action !== \"update\") {\n\t\t\t\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data[key]) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: `${key} is not allowed to be set`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.validator?.input && data[key] !== undefined) {\n\t\t\t\tconst result = fields[key]!.validator.input[\"~standard\"].validate(\n\t\t\t\t\tdata[key],\n\t\t\t\t);\n\t\t\t\tif (result instanceof Promise) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Async validation is not supported for additional fields\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (\"issues\" in result && result.issues) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: result.issues[0]?.message || \"Validation Error\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tparsedData[key] = result.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fields[key]!.transform?.input && data[key] !== undefined) {\n\t\t\t\tparsedData[key] = fields[key]!.transform?.input(data[key]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = data[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.defaultValue !== undefined && action === \"create\") {\n\t\t\tif (typeof fields[key]!.defaultValue === \"function\") {\n\t\t\t\tparsedData[key] = fields[key]!.defaultValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparsedData[key] = fields[key]!.defaultValue;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fields[key]!.required && action === \"create\") {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `${key} is required`,\n\t\t\t});\n\t\t}\n\t}\n\treturn parsedData as Partial<T>;\n}\n\nexport function parseUserInput(\n\toptions: BetterAuthOptions,\n\tuser: Record<string, any> = {},\n\taction: \"create\" | \"update\",\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user, { fields: schema, action });\n}\n\nexport function parseAdditionalUserInput(\n\toptions: BetterAuthOptions,\n\tuser?: Record<string, any> | undefined,\n) {\n\tconst schema = getFields(options, \"user\", \"input\");\n\treturn parseInputData(user || {}, { fields: schema });\n}\n\nexport function parseAccountInput(\n\toptions: BetterAuthOptions,\n\taccount: Partial<Account>,\n) {\n\tconst schema = getFields(options, \"account\", \"input\");\n\treturn parseInputData(account, { fields: schema });\n}\n\nexport function parseSessionInput(\n\toptions: BetterAuthOptions,\n\tsession: Partial<Session>,\n) {\n\tconst schema = getFields(options, \"session\", \"input\");\n\treturn parseInputData(session, { fields: schema });\n}\n\nexport function mergeSchema<S extends BetterAuthPluginDBSchema>(\n\tschema: S,\n\tnewSchema?:\n\t\t| {\n\t\t\t\t[K in keyof S]?:\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tmodelName?: string | undefined;\n\t\t\t\t\t\t\tfields?:\n\t\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\t\t[P: string]: string;\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t  }\n\t\t\t\t\t| undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tif (!newSchema) {\n\t\treturn schema;\n\t}\n\tfor (const table in newSchema) {\n\t\tconst newModelName = newSchema[table]?.modelName;\n\t\tif (newModelName) {\n\t\t\tschema[table]!.modelName = newModelName;\n\t\t}\n\t\tfor (const field in schema[table]!.fields) {\n\t\t\tconst newField = newSchema[table]?.fields?.[field];\n\t\t\tif (!newField) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tschema[table]!.fields[field]!.fieldName = newField;\n\t\t}\n\t}\n\treturn schema;\n}\n"],"names":["parsedData: Record<string, any>","schema: Record<string, DBFieldAttribute>"],"mappings":"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"}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/cookies/session-store.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/cookies/session-store.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport type { Account } from \"@better-auth/core/db\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport type { CookieOptions } from \"better-call\";\nimport * as z from \"zod\";\nimport { symmetricDecodeJWT, symmetricEncodeJWT } from \"../crypto\";\n\n// Cookie size constants based on browser limits\nconst ALLOWED_COOKIE_SIZE = 4096;\n// Estimated size of an empty cookie with all attributes\n// (name, path, domain, secure, httpOnly, sameSite, expires/maxAge)\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 200;\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE;\n\ninterface Cookie {\n\tname: string;\n\tvalue: string;\n\tattributes: CookieOptions;\n}\n\ntype Chunks = Record<string, string>;\n\n/**\n * Parse cookies from the request headers\n */\nfunction parseCookiesFromContext(\n\tctx: GenericEndpointContext,\n): Record<string, string> {\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn {};\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\treturn cookies;\n}\n\n/**\n * Extract the chunk index from a cookie name\n */\nfunction getChunkIndex(cookieName: string): number {\n\tconst parts = cookieName.split(\".\");\n\tconst lastPart = parts[parts.length - 1];\n\tconst index = parseInt(lastPart || \"0\", 10);\n\treturn isNaN(index) ? 0 : index;\n}\n\n/**\n * Read all existing chunks from cookies\n */\nfunction readExistingChunks(\n\tcookieName: string,\n\tctx: GenericEndpointContext,\n): Chunks {\n\tconst chunks: Chunks = {};\n\tconst cookies = parseCookiesFromContext(ctx);\n\n\tfor (const [name, value] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName)) {\n\t\t\tchunks[name] = value;\n\t\t}\n\t}\n\n\treturn chunks;\n}\n\n/**\n * Get the full session data by joining all chunks\n */\nfunction joinChunks(chunks: Chunks): string {\n\tconst sortedKeys = Object.keys(chunks).sort((a, b) => {\n\t\tconst aIndex = getChunkIndex(a);\n\t\tconst bIndex = getChunkIndex(b);\n\t\treturn aIndex - bIndex;\n\t});\n\n\treturn sortedKeys.map((key) => chunks[key]).join(\"\");\n}\n\n/**\n * Split a cookie value into chunks if needed\n */\nfunction chunkCookie(\n\tstoreName: string,\n\tcookie: Cookie,\n\tchunks: Chunks,\n\tlogger: InternalLogger,\n): Cookie[] {\n\tconst chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE);\n\n\tif (chunkCount === 1) {\n\t\tchunks[cookie.name] = cookie.value;\n\t\treturn [cookie];\n\t}\n\n\tconst cookies: Cookie[] = [];\n\tfor (let i = 0; i < chunkCount; i++) {\n\t\tconst name = `${cookie.name}.${i}`;\n\t\tconst start = i * CHUNK_SIZE;\n\t\tconst value = cookie.value.substring(start, start + CHUNK_SIZE);\n\t\tcookies.push({ ...cookie, name, value });\n\t\tchunks[name] = value;\n\t}\n\n\tlogger.debug(`CHUNKING_${storeName.toUpperCase()}_COOKIE`, {\n\t\tmessage: `${storeName} cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n\t\temptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n\t\tvalueSize: cookie.value.length,\n\t\tchunkCount,\n\t\tchunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n\t});\n\n\treturn cookies;\n}\n\n/**\n * Get all cookies that should be cleaned (removed)\n */\nfunction getCleanCookies(\n\tchunks: Chunks,\n\tcookieOptions: CookieOptions,\n): Record<string, Cookie> {\n\tconst cleanedChunks: Record<string, Cookie> = {};\n\tfor (const name in chunks) {\n\t\tcleanedChunks[name] = {\n\t\t\tname,\n\t\t\tvalue: \"\",\n\t\t\tattributes: { ...cookieOptions, maxAge: 0 },\n\t\t};\n\t}\n\treturn cleanedChunks;\n}\n\n/**\n * Create a session store for handling cookie chunking.\n * When session data exceeds 4KB, it automatically splits it into multiple cookies.\n *\n * Based on next-auth's SessionStore implementation.\n * @see https://github.com/nextauthjs/next-auth/blob/27b2519b84b8eb9cf053775dea29d577d2aa0098/packages/next-auth/src/core/lib/cookie.ts\n */\nconst storeFactory =\n\t(storeName: string) =>\n\t(\n\t\tcookieName: string,\n\t\tcookieOptions: CookieOptions,\n\t\tctx: GenericEndpointContext,\n\t) => {\n\t\tconst chunks = readExistingChunks(cookieName, ctx);\n\t\tconst logger = ctx.context.logger;\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Get the full session data by joining all chunks\n\t\t\t */\n\t\t\tgetValue(): string {\n\t\t\t\treturn joinChunks(chunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Check if there are existing chunks\n\t\t\t */\n\t\t\thasChunks(): boolean {\n\t\t\t\treturn Object.keys(chunks).length > 0;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Chunk a cookie value and return all cookies to set (including cleanup cookies)\n\t\t\t */\n\t\t\tchunk(value: string, options?: Partial<CookieOptions>): Cookie[] {\n\t\t\t\t// Start by cleaning all existing chunks\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\tconst cookies: Record<string, Cookie> = cleanedChunks;\n\n\t\t\t\t// Create new chunks\n\t\t\t\tconst chunked = chunkCookie(\n\t\t\t\t\tstoreName,\n\t\t\t\t\t{\n\t\t\t\t\t\tname: cookieName,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tattributes: { ...cookieOptions, ...options },\n\t\t\t\t\t},\n\t\t\t\t\tchunks,\n\t\t\t\t\tlogger,\n\t\t\t\t);\n\n\t\t\t\t// Update with new chunks\n\t\t\t\tfor (const chunk of chunked) {\n\t\t\t\t\tcookies[chunk.name] = chunk;\n\t\t\t\t}\n\n\t\t\t\treturn Object.values(cookies);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Get cookies to clean up all chunks\n\t\t\t */\n\t\t\tclean(): Cookie[] {\n\t\t\t\tconst cleanedChunks = getCleanCookies(chunks, cookieOptions);\n\t\t\t\t// Clear the chunks object\n\t\t\t\tfor (const name in chunks) {\n\t\t\t\t\tdelete chunks[name];\n\t\t\t\t}\n\t\t\t\treturn Object.values(cleanedChunks);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Set all cookies in the context\n\t\t\t */\n\t\t\tsetCookies(cookies: Cookie[]): void {\n\t\t\t\tfor (const cookie of cookies) {\n\t\t\t\t\tctx.setCookie(cookie.name, cookie.value, cookie.attributes);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t};\n\nexport const createSessionStore = storeFactory(\"Session\");\nexport const createAccountStore = storeFactory(\"Account\");\n\nexport function getChunkedCookie(\n\tctx: GenericEndpointContext,\n\tcookieName: string,\n): string | null {\n\tconst value = ctx.getCookie(cookieName);\n\tif (value) {\n\t\treturn value;\n\t}\n\n\tconst chunks: Array<{ index: number; value: string }> = [];\n\n\tconst cookieHeader = ctx.headers?.get(\"cookie\");\n\tif (!cookieHeader) {\n\t\treturn null;\n\t}\n\n\tconst cookies: Record<string, string> = {};\n\tconst pairs = cookieHeader.split(\"; \");\n\tfor (const pair of pairs) {\n\t\tconst [name, ...valueParts] = pair.split(\"=\");\n\t\tif (name && valueParts.length > 0) {\n\t\t\tcookies[name] = valueParts.join(\"=\");\n\t\t}\n\t}\n\n\tfor (const [name, val] of Object.entries(cookies)) {\n\t\tif (name.startsWith(cookieName + \".\")) {\n\t\t\tconst parts = name.split(\".\");\n\t\t\tconst indexStr = parts.at(-1);\n\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\tif (!isNaN(index)) {\n\t\t\t\tchunks.push({ index, value: val });\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chunks.length > 0) {\n\t\tchunks.sort((a, b) => a.index - b.index);\n\t\treturn chunks.map((c) => c.value).join(\"\");\n\t}\n\n\treturn null;\n}\n\nexport async function setAccountCookie(\n\tc: GenericEndpointContext,\n\taccountData: Record<string, any>,\n) {\n\tconst accountDataCookie = c.context.authCookies.accountData;\n\tconst options = {\n\t\tmaxAge: 60 * 5,\n\t\t...accountDataCookie.attributes,\n\t};\n\tconst data = await symmetricEncodeJWT(\n\t\taccountData,\n\t\tc.context.secret,\n\t\t\"better-auth-account\",\n\t\toptions.maxAge,\n\t);\n\n\tif (data.length > ALLOWED_COOKIE_SIZE) {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\n\t\tconst cookies = accountStore.chunk(data, options);\n\t\taccountStore.setCookies(cookies);\n\t} else {\n\t\tconst accountStore = createAccountStore(accountDataCookie.name, options, c);\n\t\tif (accountStore.hasChunks()) {\n\t\t\tconst cleanCookies = accountStore.clean();\n\t\t\taccountStore.setCookies(cleanCookies);\n\t\t}\n\t\tc.setCookie(accountDataCookie.name, data, options);\n\t}\n}\n\nexport async function getAccountCookie(c: GenericEndpointContext) {\n\tconst accountCookie = getChunkedCookie(\n\t\tc,\n\t\tc.context.authCookies.accountData.name,\n\t);\n\tif (accountCookie) {\n\t\tconst accountData = safeJSONParse<Account>(\n\t\t\tawait symmetricDecodeJWT(\n\t\t\t\taccountCookie,\n\t\t\t\tc.context.secret,\n\t\t\t\t\"better-auth-account\",\n\t\t\t),\n\t\t);\n\t\tif (accountData) {\n\t\t\treturn accountData;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport const getSessionQuerySchema = z.optional(\n\tz.object({\n\t\t/**\n\t\t * If cookie cache is enabled, it will disable the cache\n\t\t * and fetch the session from the database\n\t\t */\n\t\tdisableCookieCache: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription: \"Disable cookie cache and fetch session from database\",\n\t\t\t})\n\t\t\t.optional(),\n\t\tdisableRefresh: z.coerce\n\t\t\t.boolean()\n\t\t\t.meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"Disable session refresh. Useful for checking session status, without updating the session\",\n\t\t\t})\n\t\t\t.optional(),\n\t}),\n);\n"],"names":["cookies: Record<string, string>","chunks: Chunks","cookies: Cookie[]","cleanedChunks: Record<string, Cookie>","cookies: Record<string, Cookie>","chunks: Array<{ index: number; value: string }>"],"mappings":"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"}},
    {"offset": {"line": 671, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/is-promise.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/is-promise.ts"],"sourcesContent":["export function isPromise(obj?: unknown): obj is Promise<unknown> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === \"object\" || typeof obj === \"function\") &&\n\t\ttypeof (obj as Promise<unknown>).then === \"function\"\n\t);\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,UAAU,GAAA,EAAwC;IACjE,OACC,CAAC,CAAC,OAAA,CACD,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAA,KAC3C,OAAQ,IAAyB,IAAA,KAAS"}},
    {"offset": {"line": 685, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/time.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/time.ts"],"sourcesContent":["// Time constants (in milliseconds)\nconst SEC = 1000;\nconst MIN = SEC * 60;\nconst HOUR = MIN * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * 30;\nconst YEAR = DAY * 365.25;\n\n// Unit type definitions\ntype Years = \"years\" | \"year\" | \"yrs\" | \"yr\" | \"y\";\ntype Months = \"months\" | \"month\" | \"mo\";\ntype Weeks = \"weeks\" | \"week\" | \"w\";\ntype Days = \"days\" | \"day\" | \"d\";\ntype Hours = \"hours\" | \"hour\" | \"hrs\" | \"hr\" | \"h\";\ntype Minutes = \"minutes\" | \"minute\" | \"mins\" | \"min\" | \"m\";\ntype Seconds = \"seconds\" | \"second\" | \"secs\" | \"sec\" | \"s\";\ntype Unit = Years | Months | Weeks | Days | Hours | Minutes | Seconds;\ntype UnitAnyCase = Capitalize<Unit> | Uppercase<Unit> | Unit;\ntype Suffix = \" ago\" | \" from now\";\ntype Prefix = \"+\" | \"-\" | \"+ \" | \"- \";\n\n// Base time string formats\ntype BaseTimeString = `${number}${UnitAnyCase}` | `${number} ${UnitAnyCase}`;\n\n/**\n * A typed string representing a time duration.\n * Supports formats like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\", \"-5m\", etc.\n */\nexport type TimeString =\n\t| BaseTimeString\n\t| `${BaseTimeString}${Suffix}`\n\t| `${Prefix}${BaseTimeString}`;\n\nconst REGEX =\n\t/^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)(?: (ago|from now))?$/i;\n\nfunction parse(value: string): number {\n\tconst match = REGEX.exec(value);\n\n\tif (!match || (match[4] && match[1])) {\n\t\tthrow new TypeError(\n\t\t\t`Invalid time string format: \"${value}\". Use formats like \"7d\", \"30m\", \"1 hour\", etc.`,\n\t\t);\n\t}\n\n\tconst n = parseFloat(match[2]!);\n\tconst unit = match[3]!.toLowerCase();\n\n\tlet result: number;\n\tswitch (unit) {\n\t\tcase \"years\":\n\t\tcase \"year\":\n\t\tcase \"yrs\":\n\t\tcase \"yr\":\n\t\tcase \"y\":\n\t\t\tresult = n * YEAR;\n\t\t\tbreak;\n\t\tcase \"months\":\n\t\tcase \"month\":\n\t\tcase \"mo\":\n\t\t\tresult = n * MONTH;\n\t\t\tbreak;\n\t\tcase \"weeks\":\n\t\tcase \"week\":\n\t\tcase \"w\":\n\t\t\tresult = n * WEEK;\n\t\t\tbreak;\n\t\tcase \"days\":\n\t\tcase \"day\":\n\t\tcase \"d\":\n\t\t\tresult = n * DAY;\n\t\t\tbreak;\n\t\tcase \"hours\":\n\t\tcase \"hour\":\n\t\tcase \"hrs\":\n\t\tcase \"hr\":\n\t\tcase \"h\":\n\t\t\tresult = n * HOUR;\n\t\t\tbreak;\n\t\tcase \"minutes\":\n\t\tcase \"minute\":\n\t\tcase \"mins\":\n\t\tcase \"min\":\n\t\tcase \"m\":\n\t\t\tresult = n * MIN;\n\t\t\tbreak;\n\t\tcase \"seconds\":\n\t\tcase \"second\":\n\t\tcase \"secs\":\n\t\tcase \"sec\":\n\t\tcase \"s\":\n\t\t\tresult = n * SEC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new TypeError(`Unknown time unit: \"${unit}\"`);\n\t}\n\n\tif (match[1] === \"-\" || match[4] === \"ago\") {\n\t\treturn -result;\n\t}\n\n\treturn result;\n}\n\n/**\n * Parse a time string and return the value in milliseconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in milliseconds\n * @throws TypeError if the string format is invalid\n *\n * @example\n * ms(\"1d\")          // 86400000\n * ms(\"2 hours\")     // 7200000\n * ms(\"30s\")         // 30000\n * ms(\"2 hours ago\") // -7200000\n */\nexport function ms(value: TimeString): number {\n\treturn parse(value);\n}\n\n/**\n * Parse a time string and return the value in seconds.\n *\n * @param value - A time string like \"7d\", \"30m\", \"1 hour\", \"2 hours ago\"\n * @returns The parsed value in seconds (rounded)\n * @throws TypeError if the string format is invalid\n *\n * @example\n * sec(\"1d\")          // 86400\n * sec(\"2 hours\")     // 7200\n * sec(\"-30s\")        // -30\n * sec(\"2 hours ago\") // -7200\n */\nexport function sec(value: TimeString): number {\n\treturn Math.round(parse(value) / 1000);\n}\n"],"names":["result: number"],"mappings":";;;;;;;AACA,MAAM,MAAM;AACZ,MAAM,MAAM,MAAM;AAClB,MAAM,OAAO,MAAM;AACnB,MAAM,MAAM,OAAO;AACnB,MAAM,OAAO,MAAM;AACnB,MAAM,QAAQ,MAAM;AACpB,MAAM,OAAO,MAAM;AA2BnB,MAAM,QACL;AAED,SAAS,MAAM,KAAA,EAAuB;IACrC,MAAM,QAAQ,MAAM,IAAA,CAAK,MAAM;IAE/B,IAAI,CAAC,SAAU,KAAA,CAAM,EAAA,IAAM,KAAA,CAAM,EAAA,CAChC,CAAA,MAAM,IAAI,UACT,CAAA,6BAAA,EAAgC,MAAM,+CAAA,CAAA,CACtC;IAGF,MAAM,IAAI,WAAW,KAAA,CAAM,EAAA,CAAI;IAC/B,MAAM,OAAO,KAAA,CAAM,EAAA,CAAI,WAAA,EAAa;IAEpC,IAAIA;IACJ,OAAQ,MAAR;QACC,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACJ,SAAS,IAAI;YACb;QACD,QACC;YAAA,MAAM,IAAI,UAAU,CAAA,oBAAA,EAAuB,KAAK,CAAA,CAAA,CAAG;;IAGrD,IAAI,KAAA,CAAM,EAAA,KAAO,OAAO,KAAA,CAAM,EAAA,KAAO,MACpC,CAAA,OAAO,CAAC;IAGT,OAAO;;;;;;;;;;;;;;GAgBR,SAAgB,GAAG,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAM;;;;;;;;;;;;;;GAgBpB,SAAgB,IAAI,KAAA,EAA2B;IAC9C,OAAO,KAAK,KAAA,CAAM,MAAM,MAAM,GAAG,IAAK"}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/cookies/cookie-utils.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/cookies/cookie-utils.ts"],"sourcesContent":["interface CookieAttributes {\n\tvalue: string;\n\t\"max-age\"?: number | undefined;\n\texpires?: Date | undefined;\n\tdomain?: string | undefined;\n\tpath?: string | undefined;\n\tsecure?: boolean | undefined;\n\thttponly?: boolean | undefined;\n\tsamesite?: (\"strict\" | \"lax\" | \"none\") | undefined;\n\t[key: string]: any;\n}\n\nexport const SECURE_COOKIE_PREFIX = \"__Secure-\";\nexport const HOST_COOKIE_PREFIX = \"__Host-\";\n\n/**\n * Remove __Secure- or __Host- prefix from cookie name.\n */\nexport function stripSecureCookiePrefix(cookieName: string): string {\n\tif (cookieName.startsWith(SECURE_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(SECURE_COOKIE_PREFIX.length);\n\t}\n\tif (cookieName.startsWith(HOST_COOKIE_PREFIX)) {\n\t\treturn cookieName.slice(HOST_COOKIE_PREFIX.length);\n\t}\n\treturn cookieName;\n}\n\n/**\n * Split `Set-Cookie` header, handling commas in `Expires` dates.\n */\nexport function splitSetCookieHeader(setCookie: string): string[] {\n\tif (!setCookie) return [];\n\n\tconst result: string[] = [];\n\tlet current = \"\";\n\tlet i = 0;\n\n\twhile (i < setCookie.length) {\n\t\tconst c = setCookie[i];\n\n\t\tif (c === \",\") {\n\t\t\tconst lower = current.toLowerCase();\n\t\t\tif (lower.includes(\"expires=\") && !lower.includes(\"gmt\")) {\n\t\t\t\tcurrent += c;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tconst trimmed = current.trim();\n\t\t\t\tif (trimmed) {\n\t\t\t\t\tresult.push(trimmed);\n\t\t\t\t}\n\t\t\t\tcurrent = \"\";\n\t\t\t\ti++;\n\t\t\t\tif (i < setCookie.length && setCookie[i] === \" \") {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent += c;\n\t\ti++;\n\t}\n\n\tconst trimmed = current.trim();\n\tif (trimmed) {\n\t\tresult.push(trimmed);\n\t}\n\n\treturn result;\n}\n\nexport function parseSetCookieHeader(\n\tsetCookie: string,\n): Map<string, CookieAttributes> {\n\tconst cookies = new Map<string, CookieAttributes>();\n\tconst cookieArray = splitSetCookieHeader(setCookie);\n\n\tcookieArray.forEach((cookieString) => {\n\t\tconst parts = cookieString.split(\";\").map((part) => part.trim());\n\t\tconst [nameValue, ...attributes] = parts;\n\t\tconst [name, ...valueParts] = (nameValue || \"\").split(\"=\");\n\n\t\tconst value = valueParts.join(\"=\");\n\n\t\tif (!name || value === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst attrObj: CookieAttributes = { value };\n\n\t\tattributes.forEach((attribute) => {\n\t\t\tconst [attrName, ...attrValueParts] = attribute!.split(\"=\");\n\t\t\tconst attrValue = attrValueParts.join(\"=\");\n\n\t\t\tconst normalizedAttrName = attrName!.trim().toLowerCase();\n\n\t\t\tswitch (normalizedAttrName) {\n\t\t\t\tcase \"max-age\":\n\t\t\t\t\tattrObj[\"max-age\"] = attrValue\n\t\t\t\t\t\t? parseInt(attrValue.trim(), 10)\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"expires\":\n\t\t\t\t\tattrObj.expires = attrValue ? new Date(attrValue.trim()) : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"domain\":\n\t\t\t\t\tattrObj.domain = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"path\":\n\t\t\t\t\tattrObj.path = attrValue ? attrValue.trim() : undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"secure\":\n\t\t\t\t\tattrObj.secure = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"httponly\":\n\t\t\t\t\tattrObj.httponly = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"samesite\":\n\t\t\t\t\tattrObj.samesite = attrValue\n\t\t\t\t\t\t? (attrValue.trim().toLowerCase() as \"strict\" | \"lax\" | \"none\")\n\t\t\t\t\t\t: undefined;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Handle any other attributes\n\t\t\t\t\tattrObj[normalizedAttrName] = attrValue ? attrValue.trim() : true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\tcookies.set(name, attrObj);\n\t});\n\n\treturn cookies;\n}\n\nexport function setCookieToHeader(headers: Headers) {\n\treturn (context: { response: Response }) => {\n\t\tconst setCookieHeader = context.response.headers.get(\"set-cookie\");\n\t\tif (!setCookieHeader) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst cookieMap = new Map<string, string>();\n\n\t\tconst existingCookiesHeader = headers.get(\"cookie\") || \"\";\n\t\texistingCookiesHeader.split(\";\").forEach((cookie) => {\n\t\t\tconst [name, ...rest] = cookie!.trim().split(\"=\");\n\t\t\tif (name && rest.length > 0) {\n\t\t\t\tcookieMap.set(name, rest.join(\"=\"));\n\t\t\t}\n\t\t});\n\n\t\tconst cookies = parseSetCookieHeader(setCookieHeader);\n\t\tcookies.forEach((value, name) => {\n\t\t\tcookieMap.set(name, value.value);\n\t\t});\n\n\t\tconst updatedCookies = Array.from(cookieMap.entries())\n\t\t\t.map(([name, value]) => `${name}=${value}`)\n\t\t\t.join(\"; \");\n\t\theaders.set(\"cookie\", updatedCookies);\n\t};\n}\n"],"names":["result: string[]","trimmed","attrObj: CookieAttributes"],"mappings":";;;;;;;;;;;;;;;AAYA,MAAa,uBAAuB;AACpC,MAAa,qBAAqB;;;GAKlC,SAAgB,wBAAwB,UAAA,EAA4B;IACnE,IAAI,WAAW,UAAA,CAAW,qBAAqB,CAC9C,CAAA,OAAO,WAAW,KAAA,CAAM,EAA4B;IAErD,IAAI,WAAW,UAAA,CAAW,mBAAmB,CAC5C,CAAA,OAAO,WAAW,KAAA,CAAM,EAA0B;IAEnD,OAAO;;;;GAMR,SAAgB,qBAAqB,SAAA,EAA6B;IACjE,IAAI,CAAC,UAAW,CAAA,OAAO,EAAE;IAEzB,MAAMA,SAAmB,EAAE;IAC3B,IAAI,UAAU;IACd,IAAI,IAAI;IAER,MAAO,IAAI,UAAU,MAAA,CAAQ;QAC5B,MAAM,IAAI,SAAA,CAAU,EAAA;QAEpB,IAAI,MAAM,KAAK;YACd,MAAM,QAAQ,QAAQ,WAAA,EAAa;YACnC,IAAI,MAAM,QAAA,CAAS,WAAW,IAAI,CAAC,MAAM,QAAA,CAAS,MAAM,EAAE;gBACzD,WAAW;gBACX;mBACM;gBACN,MAAMC,YAAU,QAAQ,IAAA,EAAM;gBAC9B,IAAIA,UACH,CAAA,OAAO,IAAA,CAAKA,UAAQ;gBAErB,UAAU;gBACV;gBACA,IAAI,IAAI,UAAU,MAAA,IAAU,SAAA,CAAU,EAAA,KAAO,IAC5C,CAAA;;YAGF;;QAGD,WAAW;QACX;;IAGD,MAAM,UAAU,QAAQ,IAAA,EAAM;IAC9B,IAAI,QACH,CAAA,OAAO,IAAA,CAAK,QAAQ;IAGrB,OAAO;;AAGR,SAAgB,qBACf,SAAA,EACgC;IAChC,MAAM,UAAA,aAAA,GAAU,IAAI,KAA+B;IAC/B,qBAAqB,UAAU,CAEvC,OAAA,CAAA,CAAS,iBAAiB;QAErC,MAAM,CAAC,WAAW,GAAG,WAAA,GADP,aAAa,KAAA,CAAM,IAAI,CAAC,GAAA,CAAA,CAAK,OAAS,KAAK,IAAA,EAAM,CAAC;QAEhE,MAAM,CAAC,MAAM,GAAG,WAAA,GAAA,CAAe,aAAa,EAAA,EAAI,KAAA,CAAM,IAAI;QAE1D,MAAM,QAAQ,WAAW,IAAA,CAAK,IAAI;QAElC,IAAI,CAAC,QAAQ,UAAU,KAAA,EACtB,CAAA;QAGD,MAAMC,UAA4B;YAAE;QAAA,CAAO;QAE3C,WAAW,OAAA,CAAA,CAAS,cAAc;YACjC,MAAM,CAAC,UAAU,GAAG,eAAA,GAAkB,UAAW,KAAA,CAAM,IAAI;YAC3D,MAAM,YAAY,eAAe,IAAA,CAAK,IAAI;YAE1C,MAAM,qBAAqB,SAAU,IAAA,EAAM,CAAC,WAAA,EAAa;YAEzD,OAAQ,oBAAR;gBACC,KAAK;oBACJ,OAAA,CAAQ,UAAA,GAAa,YAClB,SAAS,UAAU,IAAA,EAAM,EAAE,GAAG,GAC9B,KAAA;oBACH;gBACD,KAAK;oBACJ,QAAQ,OAAA,GAAU,YAAY,IAAI,KAAK,UAAU,IAAA,EAAM,CAAC,GAAG,KAAA;oBAC3D;gBACD,KAAK;oBACJ,QAAQ,MAAA,GAAS,YAAY,UAAU,IAAA,EAAM,GAAG,KAAA;oBAChD;gBACD,KAAK;oBACJ,QAAQ,IAAA,GAAO,YAAY,UAAU,IAAA,EAAM,GAAG,KAAA;oBAC9C;gBACD,KAAK;oBACJ,QAAQ,MAAA,GAAS;oBACjB;gBACD,KAAK;oBACJ,QAAQ,QAAA,GAAW;oBACnB;gBACD,KAAK;oBACJ,QAAQ,QAAA,GAAW,YACf,UAAU,IAAA,EAAM,CAAC,WAAA,EAAa,GAC/B,KAAA;oBACH;gBACD;oBAEC,OAAA,CAAQ,mBAAA,GAAsB,YAAY,UAAU,IAAA,EAAM,GAAG;oBAC7D;;UAED;QAEF,QAAQ,GAAA,CAAI,MAAM,QAAQ;MACzB;IAEF,OAAO;;AAGR,SAAgB,kBAAkB,OAAA,EAAkB;IACnD,OAAA,CAAQ,YAAoC;QAC3C,MAAM,kBAAkB,QAAQ,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,aAAa;QAClE,IAAI,CAAC,gBACJ,CAAA;QAGD,MAAM,YAAA,aAAA,GAAY,IAAI,KAAqB;QAG3C,CAD8B,QAAQ,GAAA,CAAI,SAAS,IAAI,EAAA,EACjC,KAAA,CAAM,IAAI,CAAC,OAAA,CAAA,CAAS,WAAW;YACpD,MAAM,CAAC,MAAM,GAAG,KAAA,GAAQ,OAAQ,IAAA,EAAM,CAAC,KAAA,CAAM,IAAI;YACjD,IAAI,QAAQ,KAAK,MAAA,GAAS,EACzB,CAAA,UAAU,GAAA,CAAI,MAAM,KAAK,IAAA,CAAK,IAAI,CAAC;UAEnC;QAEc,qBAAqB,gBAAgB,CAC7C,OAAA,CAAA,CAAS,OAAO,SAAS;YAChC,UAAU,GAAA,CAAI,MAAM,MAAM,KAAA,CAAM;UAC/B;QAEF,MAAM,iBAAiB,MAAM,IAAA,CAAK,UAAU,OAAA,EAAS,CAAC,CACpD,GAAA,CAAA,CAAK,CAAC,MAAM,MAAA,GAAW,GAAG,KAAK,CAAA,EAAG,OAAA,CAAQ,CAC1C,IAAA,CAAK,KAAK;QACZ,QAAQ,GAAA,CAAI,UAAU,eAAe"}},
    {"offset": {"line": 913, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/cookies/index.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/cookies/index.ts"],"sourcesContent":["import type {\n\tBetterAuthCookie,\n\tBetterAuthCookies,\n\tBetterAuthOptions,\n\tGenericEndpointContext,\n} from \"@better-auth/core\";\nimport { env, isProduction } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { filterOutputFields, safeJSONParse } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport type { CookieOptions } from \"better-call\";\nimport {\n\tsignJWT,\n\tsymmetricDecodeJWT,\n\tsymmetricEncodeJWT,\n\tverifyJWT,\n} from \"../crypto/jwt\";\nimport { parseUserOutput } from \"../db/schema\";\nimport type { Session, User } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { sec } from \"../utils/time\";\nimport { SECURE_COOKIE_PREFIX } from \"./cookie-utils\";\nimport {\n\tcreateAccountStore,\n\tcreateSessionStore,\n\tgetAccountCookie,\n\tsetAccountCookie,\n} from \"./session-store\";\n\nexport function createCookieGetter(options: BetterAuthOptions) {\n\tconst secure =\n\t\toptions.advanced?.useSecureCookies !== undefined\n\t\t\t? options.advanced?.useSecureCookies\n\t\t\t: options.baseURL\n\t\t\t\t? options.baseURL.startsWith(\"https://\")\n\t\t\t\t\t? true\n\t\t\t\t\t: false\n\t\t\t\t: isProduction;\n\tconst secureCookiePrefix = secure ? SECURE_COOKIE_PREFIX : \"\";\n\tconst crossSubdomainEnabled =\n\t\t!!options.advanced?.crossSubDomainCookies?.enabled;\n\tconst domain = crossSubdomainEnabled\n\t\t? options.advanced?.crossSubDomainCookies?.domain ||\n\t\t\t(options.baseURL ? new URL(options.baseURL).hostname : undefined)\n\t\t: undefined;\n\tif (crossSubdomainEnabled && !domain) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"baseURL is required when crossSubdomainCookies are enabled\",\n\t\t);\n\t}\n\tfunction createCookie(\n\t\tcookieName: string,\n\t\toverrideAttributes: Partial<CookieOptions> = {},\n\t) {\n\t\tconst prefix = options.advanced?.cookiePrefix || \"better-auth\";\n\t\tconst name =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.name ||\n\t\t\t`${prefix}.${cookieName}`;\n\n\t\tconst attributes =\n\t\t\toptions.advanced?.cookies?.[cookieName as \"session_token\"]?.attributes;\n\n\t\treturn {\n\t\t\tname: `${secureCookiePrefix}${name}`,\n\t\t\tattributes: {\n\t\t\t\tsecure: !!secureCookiePrefix,\n\t\t\t\tsameSite: \"lax\",\n\t\t\t\tpath: \"/\",\n\t\t\t\thttpOnly: true,\n\t\t\t\t...(crossSubdomainEnabled ? { domain } : {}),\n\t\t\t\t...options.advanced?.defaultCookieAttributes,\n\t\t\t\t...overrideAttributes,\n\t\t\t\t...attributes,\n\t\t\t},\n\t\t} satisfies BetterAuthCookie;\n\t}\n\treturn createCookie;\n}\n\nexport function getCookies(options: BetterAuthOptions) {\n\tconst createCookie = createCookieGetter(options);\n\tconst sessionMaxAge = options.session?.expiresIn || sec(\"7d\");\n\tconst sessionToken = createCookie(\"session_token\", {\n\t\tmaxAge: sessionMaxAge,\n\t});\n\tconst sessionData = createCookie(\"session_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst accountData = createCookie(\"account_data\", {\n\t\tmaxAge: options.session?.cookieCache?.maxAge || 60 * 5,\n\t});\n\tconst dontRememberToken = createCookie(\"dont_remember\");\n\treturn {\n\t\tsessionToken: {\n\t\t\tname: sessionToken.name,\n\t\t\tattributes: sessionToken.attributes,\n\t\t},\n\t\t/**\n\t\t * This cookie is used to store the session data in the cookie\n\t\t * This is useful for when you want to cache the session in the cookie\n\t\t */\n\t\tsessionData: {\n\t\t\tname: sessionData.name,\n\t\t\tattributes: sessionData.attributes,\n\t\t},\n\t\tdontRememberToken: {\n\t\t\tname: dontRememberToken.name,\n\t\t\tattributes: dontRememberToken.attributes,\n\t\t},\n\t\taccountData: {\n\t\t\tname: accountData.name,\n\t\t\tattributes: accountData.attributes,\n\t\t},\n\t};\n}\n\nexport async function setCookieCache(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe: boolean,\n) {\n\tif (!ctx.context.options.session?.cookieCache?.enabled) {\n\t\treturn;\n\t}\n\n\tconst filteredSession = filterOutputFields(\n\t\tsession.session,\n\t\tctx.context.options.session?.additionalFields,\n\t);\n\n\tconst filteredUser = parseUserOutput(ctx.context.options, session.user);\n\n\tconst versionConfig = ctx.context.options.session?.cookieCache?.version;\n\tlet version = \"1\";\n\tif (versionConfig) {\n\t\tif (typeof versionConfig === \"string\") {\n\t\t\tversion = versionConfig;\n\t\t} else if (typeof versionConfig === \"function\") {\n\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\tversion = isPromise(result) ? await result : result;\n\t\t}\n\t}\n\n\tconst sessionData = {\n\t\tsession: filteredSession,\n\t\tuser: filteredUser,\n\t\tupdatedAt: Date.now(),\n\t\tversion,\n\t};\n\n\tconst options = {\n\t\t...ctx.context.authCookies.sessionData.attributes,\n\t\tmaxAge: dontRememberMe\n\t\t\t? undefined\n\t\t\t: ctx.context.authCookies.sessionData.attributes.maxAge,\n\t};\n\n\tconst expiresAtDate = getDate(options.maxAge || 60, \"sec\").getTime();\n\tconst strategy =\n\t\tctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\n\tlet data: string;\n\n\tif (strategy === \"jwe\") {\n\t\t// Use JWE strategy (JSON Web Encryption) with A256CBC-HS512 + HKDF\n\t\tdata = await symmetricEncodeJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\t\"better-auth-session\",\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else if (strategy === \"jwt\") {\n\t\t// Use JWT strategy with HMAC-SHA256 signature (HS256), no encryption\n\t\tdata = await signJWT(\n\t\t\tsessionData,\n\t\t\tctx.context.secret,\n\t\t\toptions.maxAge || 60 * 5,\n\t\t);\n\t} else {\n\t\t// Use compact strategy (base64url + HMAC, no JWT spec overhead)\n\t\t// Also handles legacy \"base64-hmac\" for backward compatibility\n\t\tdata = base64Url.encode(\n\t\t\tJSON.stringify({\n\t\t\t\tsession: sessionData,\n\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\tsignature: await createHMAC(\"SHA-256\", \"base64urlnopad\").sign(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t...sessionData,\n\t\t\t\t\t\texpiresAt: expiresAtDate,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t\t{\n\t\t\t\tpadding: false,\n\t\t\t},\n\t\t);\n\t}\n\n\t// Check if we need to chunk the cookie (only if it exceeds 4093 bytes)\n\tif (data.length > 4093) {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tconst cookies = sessionStore.chunk(data, options);\n\t\tsessionStore.setCookies(cookies);\n\t} else {\n\t\tconst sessionStore = createSessionStore(\n\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\toptions,\n\t\t\tctx,\n\t\t);\n\t\tif (sessionStore.hasChunks()) {\n\t\t\tconst cleanCookies = sessionStore.clean();\n\t\t\tsessionStore.setCookies(cleanCookies);\n\t\t}\n\t\tctx.setCookie(ctx.context.authCookies.sessionData.name, data, options);\n\t}\n\n\t// Refresh account cookie to keep it in sync\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tif (accountData) {\n\t\t\tawait setAccountCookie(ctx, accountData);\n\t\t}\n\t}\n}\n\nexport async function setSessionCookie(\n\tctx: GenericEndpointContext,\n\tsession: {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User;\n\t},\n\tdontRememberMe?: boolean | undefined,\n\toverrides?: Partial<CookieOptions> | undefined,\n) {\n\tconst dontRememberMeCookie = await ctx.getSignedCookie(\n\t\tctx.context.authCookies.dontRememberToken.name,\n\t\tctx.context.secret,\n\t);\n\t// if dontRememberMe is not set, use the cookie value\n\tdontRememberMe =\n\t\tdontRememberMe !== undefined ? dontRememberMe : !!dontRememberMeCookie;\n\n\tconst options = ctx.context.authCookies.sessionToken.attributes;\n\tconst maxAge = dontRememberMe\n\t\t? undefined\n\t\t: ctx.context.sessionConfig.expiresIn;\n\tawait ctx.setSignedCookie(\n\t\tctx.context.authCookies.sessionToken.name,\n\t\tsession.session.token,\n\t\tctx.context.secret,\n\t\t{\n\t\t\t...options,\n\t\t\tmaxAge,\n\t\t\t...overrides,\n\t\t},\n\t);\n\n\tif (dontRememberMe) {\n\t\tawait ctx.setSignedCookie(\n\t\t\tctx.context.authCookies.dontRememberToken.name,\n\t\t\t\"true\",\n\t\t\tctx.context.secret,\n\t\t\tctx.context.authCookies.dontRememberToken.attributes,\n\t\t);\n\t}\n\tawait setCookieCache(ctx, session, dontRememberMe);\n\tctx.context.setNewSession(session);\n}\n\n/**\n * Expires a cookie by setting `maxAge: 0` while preserving its attributes\n */\nexport function expireCookie(\n\tctx: GenericEndpointContext,\n\tcookie: BetterAuthCookie,\n) {\n\tctx.setCookie(cookie.name, \"\", {\n\t\t...cookie.attributes,\n\t\tmaxAge: 0,\n\t});\n}\n\nexport function deleteSessionCookie(\n\tctx: GenericEndpointContext,\n\tskipDontRememberMe?: boolean | undefined,\n) {\n\texpireCookie(ctx, ctx.context.authCookies.sessionToken);\n\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\n\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\texpireCookie(ctx, ctx.context.authCookies.accountData);\n\n\t\t//clean up the account data chunks\n\t\tconst accountStore = createAccountStore(\n\t\t\tctx.context.authCookies.accountData.name,\n\t\t\tctx.context.authCookies.accountData.attributes,\n\t\t\tctx,\n\t\t);\n\t\tconst cleanCookies = accountStore.clean();\n\t\taccountStore.setCookies(cleanCookies);\n\t}\n\n\tif (ctx.context.oauthConfig.storeStateStrategy === \"cookie\") {\n\t\tconst stateCookie = ctx.context.createAuthCookie(\"oauth_state\");\n\t\texpireCookie(ctx, stateCookie);\n\t}\n\n\t// Use createSessionStore to clean up all session data chunks\n\tconst sessionStore = createSessionStore(\n\t\tctx.context.authCookies.sessionData.name,\n\t\tctx.context.authCookies.sessionData.attributes,\n\t\tctx,\n\t);\n\tconst cleanCookies = sessionStore.clean();\n\tsessionStore.setCookies(cleanCookies);\n\n\tif (!skipDontRememberMe) {\n\t\texpireCookie(ctx, ctx.context.authCookies.dontRememberToken);\n\t}\n}\n\nexport function parseCookies(cookieHeader: string) {\n\tconst cookies = cookieHeader.split(\"; \");\n\tconst cookieMap = new Map<string, string>();\n\n\tcookies.forEach((cookie) => {\n\t\tconst [name, value] = cookie.split(/=(.*)/s);\n\t\tcookieMap.set(name!, value!);\n\t});\n\treturn cookieMap;\n}\n\nexport type EligibleCookies = (string & {}) | (keyof BetterAuthCookies & {});\n\nexport const getSessionCookie = (\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tpath?: string;\n\t\t  }\n\t\t| undefined,\n) => {\n\tif (config?.cookiePrefix) {\n\t\tif (config.cookieName) {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}-`;\n\t\t} else {\n\t\t\tconfig.cookiePrefix = `${config.cookiePrefix}.`;\n\t\t}\n\t}\n\tconst headers = \"headers\" in request ? request.headers : request;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_token\", cookiePrefix = \"better-auth.\" } =\n\t\tconfig || {};\n\tconst name = `${cookiePrefix}${cookieName}`;\n\tconst secureCookieName = `${SECURE_COOKIE_PREFIX}${name}`;\n\tconst parsedCookie = parseCookies(cookies);\n\tconst sessionToken =\n\t\tparsedCookie.get(name) || parsedCookie.get(secureCookieName);\n\tif (sessionToken) {\n\t\treturn sessionToken;\n\t}\n\n\treturn null;\n};\n\nexport const getCookieCache = async <\n\tS extends {\n\t\tsession: Session & Record<string, any>;\n\t\tuser: User & Record<string, any>;\n\t\tupdatedAt: number;\n\t\tversion?: string;\n\t},\n>(\n\trequest: Request | Headers,\n\tconfig?:\n\t\t| {\n\t\t\t\tcookiePrefix?: string;\n\t\t\t\tcookieName?: string;\n\t\t\t\tisSecure?: boolean;\n\t\t\t\tsecret?: string;\n\t\t\t\tstrategy?: \"compact\" | \"jwt\" | \"jwe\"; // base64-hmac for backward compatibility\n\t\t\t\tversion?:\n\t\t\t\t\t| string\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => string)\n\t\t\t\t\t| ((\n\t\t\t\t\t\t\tsession: Session & Record<string, any>,\n\t\t\t\t\t\t\tuser: User & Record<string, any>,\n\t\t\t\t\t  ) => Promise<string>);\n\t\t  }\n\t\t| undefined,\n) => {\n\tconst headers = request instanceof Headers ? request : request.headers;\n\tconst cookies = headers.get(\"cookie\");\n\tif (!cookies) {\n\t\treturn null;\n\t}\n\tconst { cookieName = \"session_data\", cookiePrefix = \"better-auth\" } =\n\t\tconfig || {};\n\tconst name =\n\t\tconfig?.isSecure !== undefined\n\t\t\t? config.isSecure\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`\n\t\t\t: isProduction\n\t\t\t\t? `${SECURE_COOKIE_PREFIX}${cookiePrefix}.${cookieName}`\n\t\t\t\t: `${cookiePrefix}.${cookieName}`;\n\tconst parsedCookie = parseCookies(cookies);\n\n\t// Check for chunked cookies\n\tlet sessionData = parsedCookie.get(name);\n\tif (!sessionData) {\n\t\t// Try to reconstruct from chunks\n\t\tconst chunks: Array<{ index: number; value: string }> = [];\n\t\tfor (const [cookieName, value] of parsedCookie.entries()) {\n\t\t\tif (cookieName.startsWith(name + \".\")) {\n\t\t\t\tconst parts = cookieName.split(\".\");\n\t\t\t\tconst indexStr = parts[parts.length - 1];\n\t\t\t\tconst index = parseInt(indexStr || \"0\", 10);\n\t\t\t\tif (!isNaN(index)) {\n\t\t\t\t\tchunks.push({ index, value });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chunks.length > 0) {\n\t\t\t// Sort by index and join\n\t\t\tchunks.sort((a, b) => a.index - b.index);\n\t\t\tsessionData = chunks.map((c) => c.value).join(\"\");\n\t\t}\n\t}\n\n\tif (sessionData) {\n\t\tconst secret = config?.secret || env.BETTER_AUTH_SECRET;\n\t\tif (!secret) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"getCookieCache requires a secret to be provided. Either pass it as an option or set the BETTER_AUTH_SECRET environment variable\",\n\t\t\t);\n\t\t}\n\n\t\tconst strategy = config?.strategy || \"compact\";\n\n\t\tif (strategy === \"jwe\") {\n\t\t\t// Use JWE strategy (encrypted)\n\t\t\tconst payload = await symmetricDecodeJWT<S>(\n\t\t\t\tsessionData,\n\t\t\t\tsecret,\n\t\t\t\t\"better-auth-session\",\n\t\t\t);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else if (strategy === \"jwt\") {\n\t\t\t// Use JWT strategy with HMAC signature (HS256), no encryption\n\t\t\tconst payload = await verifyJWT<S>(sessionData, secret);\n\n\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t// Validate version if provided\n\t\t\t\tif (config?.version) {\n\t\t\t\t\tconst cookieVersion = payload.version || \"1\";\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\t\tconst result = config.version(payload.session, payload.user);\n\t\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t\t}\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn payload;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Use compact strategy (or legacy base64-hmac)\n\t\t\tconst sessionDataPayload = safeJSONParse<{\n\t\t\t\tsession: S;\n\t\t\t\texpiresAt: number;\n\t\t\t\tsignature: string;\n\t\t\t}>(binary.decode(base64Url.decode(sessionData)));\n\t\t\tif (!sessionDataPayload) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst isValid = await createHMAC(\"SHA-256\", \"base64urlnopad\").verify(\n\t\t\t\tsecret,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\t...sessionDataPayload.session,\n\t\t\t\t\texpiresAt: sessionDataPayload.expiresAt,\n\t\t\t\t}),\n\t\t\t\tsessionDataPayload.signature,\n\t\t\t);\n\t\t\tif (!isValid) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Validate version if provided\n\t\t\tif (config?.version && sessionDataPayload.session) {\n\t\t\t\tconst cookieVersion = sessionDataPayload.session.version || \"1\";\n\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\tif (typeof config.version === \"string\") {\n\t\t\t\t\texpectedVersion = config.version;\n\t\t\t\t} else if (typeof config.version === \"function\") {\n\t\t\t\t\tconst result = config.version(\n\t\t\t\t\t\tsessionDataPayload.session.session,\n\t\t\t\t\t\tsessionDataPayload.session.user,\n\t\t\t\t\t);\n\t\t\t\t\texpectedVersion = isPromise(result) ? await result : result;\n\t\t\t\t}\n\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sessionDataPayload.session;\n\t\t}\n\t}\n\treturn null;\n};\n\nexport * from \"./cookie-utils\";\nexport { createSessionStore, getChunkedCookie } from \"./session-store\";\n"],"names":["data: string","cleanCookies","chunks: Array<{ index: number; value: string }>","cookieName"],"mappings":"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"}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/state.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/state.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport * as z from \"zod\";\nimport { expireCookie } from \"./cookies\";\nimport {\n\tgenerateRandomString,\n\tsymmetricDecrypt,\n\tsymmetricEncrypt,\n} from \"./crypto\";\n\nconst stateDataSchema = z.looseObject({\n\tcallbackURL: z.string(),\n\tcodeVerifier: z.string(),\n\terrorURL: z.string().optional(),\n\tnewUserURL: z.string().optional(),\n\texpiresAt: z.number(),\n\tlink: z\n\t\t.object({\n\t\t\temail: z.string(),\n\t\t\tuserId: z.coerce.string(),\n\t\t})\n\t\t.optional(),\n\trequestSignUp: z.boolean().optional(),\n});\n\nexport type StateData = z.infer<typeof stateDataSchema>;\n\nexport type StateErrorCode =\n\t| \"state_generation_error\"\n\t| \"state_invalid\"\n\t| \"state_mismatch\"\n\t| \"state_security_mismatch\";\n\nexport class StateError extends BetterAuthError {\n\tcode: string;\n\tdetails?: Record<string, any>;\n\n\tconstructor(\n\t\tmessage: string,\n\t\toptions: ErrorOptions & {\n\t\t\tcode: StateErrorCode;\n\t\t\tdetails?: Record<string, any>;\n\t\t},\n\t) {\n\t\tsuper(message, options);\n\t\tthis.code = options.code;\n\t\tthis.details = options.details;\n\t}\n}\n\nexport async function generateGenericState(\n\tc: GenericEndpointContext,\n\tstateData: StateData,\n\tsettings?: { cookieName: string },\n) {\n\tconst state = generateRandomString(32);\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Store state data in an encrypted cookie\n\n\t\tconst encryptedData = await symmetricEncrypt({\n\t\t\tkey: c.context.secret,\n\t\t\tdata: JSON.stringify(stateData),\n\t\t});\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t\t{\n\t\t\t\tmaxAge: 10 * 60, // 10 minutes\n\t\t\t},\n\t\t);\n\n\t\tc.setCookie(stateCookie.name, encryptedData, stateCookie.attributes);\n\n\t\treturn {\n\t\t\tstate,\n\t\t\tcodeVerifier: stateData.codeVerifier,\n\t\t};\n\t}\n\n\t// Default: database strategy\n\n\tconst stateCookie = c.context.createAuthCookie(\n\t\tsettings?.cookieName ?? \"state\",\n\t\t{\n\t\t\tmaxAge: 5 * 60, // 5 minutes\n\t\t},\n\t);\n\n\tawait c.setSignedCookie(\n\t\tstateCookie.name,\n\t\tstate,\n\t\tc.context.secret,\n\t\tstateCookie.attributes,\n\t);\n\n\tconst expiresAt = new Date();\n\texpiresAt.setMinutes(expiresAt.getMinutes() + 10);\n\n\tconst verification = await c.context.internalAdapter.createVerificationValue({\n\t\tvalue: JSON.stringify(stateData),\n\t\tidentifier: state,\n\t\texpiresAt,\n\t});\n\n\tif (!verification) {\n\t\tthrow new StateError(\n\t\t\t\"Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database\",\n\t\t\t{\n\t\t\t\tcode: \"state_generation_error\",\n\t\t\t},\n\t\t);\n\t}\n\n\treturn {\n\t\tstate: verification.identifier,\n\t\tcodeVerifier: stateData.codeVerifier,\n\t};\n}\n\nexport async function parseGenericState(\n\tc: GenericEndpointContext,\n\tstate: string,\n\tsettings?: { cookieName: string },\n) {\n\tconst storeStateStrategy = c.context.oauthConfig.storeStateStrategy;\n\tlet parsedData: StateData;\n\n\tif (storeStateStrategy === \"cookie\") {\n\t\t// Retrieve state data from encrypted cookie\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"oauth_state\",\n\t\t);\n\t\tconst encryptedData = c.getCookie(stateCookie.name);\n\n\t\tif (!encryptedData) {\n\t\t\tthrow new StateError(\"State mismatch: auth state cookie not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tconst decryptedData = await symmetricDecrypt({\n\t\t\t\tkey: c.context.secret,\n\t\t\t\tdata: encryptedData,\n\t\t\t});\n\n\t\t\tparsedData = stateDataSchema.parse(JSON.parse(decryptedData));\n\t\t} catch (error) {\n\t\t\tthrow new StateError(\n\t\t\t\t\"State invalid: Failed to decrypt or parse auth state\",\n\t\t\t\t{\n\t\t\t\t\tcode: \"state_invalid\",\n\t\t\t\t\tdetails: { state },\n\t\t\t\t\tcause: error,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\t// Clear the cookie after successful parsing\n\t\texpireCookie(c, stateCookie);\n\t} else {\n\t\t// Default: database strategy\n\t\tconst data = await c.context.internalAdapter.findVerificationValue(state);\n\t\tif (!data) {\n\t\t\tthrow new StateError(\"State mismatch: verification not found\", {\n\t\t\t\tcode: \"state_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\tparsedData = stateDataSchema.parse(JSON.parse(data.value));\n\n\t\tconst stateCookie = c.context.createAuthCookie(\n\t\t\tsettings?.cookieName ?? \"state\",\n\t\t);\n\n\t\tconst stateCookieValue = await c.getSignedCookie(\n\t\t\tstateCookie.name,\n\t\t\tc.context.secret,\n\t\t);\n\n\t\t/**\n\t\t * This is generally cause security issue and should only be used in\n\t\t * dev or staging environments. It's currently used by the oauth-proxy\n\t\t * plugin\n\t\t */\n\t\tconst skipStateCookieCheck = c.context.oauthConfig.skipStateCookieCheck;\n\t\tif (\n\t\t\t!skipStateCookieCheck &&\n\t\t\t(!stateCookieValue || stateCookieValue !== state)\n\t\t) {\n\t\t\tthrow new StateError(\"State mismatch: State not persisted correctly\", {\n\t\t\t\tcode: \"state_security_mismatch\",\n\t\t\t\tdetails: { state },\n\t\t\t});\n\t\t}\n\n\t\texpireCookie(c, stateCookie);\n\n\t\t// Delete verification value after retrieval\n\t\tawait c.context.internalAdapter.deleteVerificationValue(data.id);\n\t}\n\n\t// Check expiration\n\tif (parsedData.expiresAt < Date.now()) {\n\t\tthrow new StateError(\"Invalid state: request expired\", {\n\t\t\tcode: \"state_mismatch\",\n\t\t\tdetails: {\n\t\t\t\texpiresAt: parsedData.expiresAt,\n\t\t\t},\n\t\t});\n\t}\n\n\treturn parsedData;\n}\n"],"names":["stateCookie","parsedData: StateData"],"mappings":"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"}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/middlewares/oauth.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/middlewares/oauth.ts"],"sourcesContent":["import { defineRequestState } from \"@better-auth/core/context\";\n\ntype OAuthState = {\n\tcallbackURL: string;\n\tcodeVerifier: string;\n\terrorURL?: string;\n\tnewUserURL?: string;\n\tlink?: {\n\t\temail: string;\n\t\tuserId: string;\n\t};\n\texpiresAt: number;\n\trequestSignUp?: boolean;\n\t[key: string]: any;\n};\n\nconst {\n\tget: getOAuthState,\n\t/**\n\t * @internal This is unsafe to be used directly. Use setOAuthState instead.\n\t */\n\tset: setOAuthState,\n} = defineRequestState<OAuthState | null>(() => null);\n\nexport { getOAuthState, setOAuthState };\n"],"names":[],"mappings":";;;;;;;;;;AAgBA,MAAM,EACL,KAAK,aAAA,EAIL,KAAK,aAAA,EAAA,OACF,oNAAA,EAAA,IAA4C,KAAK"}},
    {"offset": {"line": 1377, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/oauth2/state.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/oauth2/state.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\nimport { setOAuthState } from \"../api/middlewares/oauth\";\nimport { generateRandomString } from \"../crypto\";\nimport type { StateData } from \"../state\";\nimport { generateGenericState, parseGenericState, StateError } from \"../state\";\n\nexport async function generateState(\n\tc: GenericEndpointContext,\n\tlink:\n\t\t| {\n\t\t\t\temail: string;\n\t\t\t\tuserId: string;\n\t\t  }\n\t\t| undefined,\n\tadditionalData: Record<string, any> | false | undefined,\n) {\n\tconst callbackURL = c.body?.callbackURL || c.context.options.baseURL;\n\tif (!callbackURL) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"callbackURL is required\",\n\t\t});\n\t}\n\n\tconst codeVerifier = generateRandomString(128);\n\n\tconst stateData: StateData = {\n\t\t...(additionalData ? additionalData : {}),\n\t\tcallbackURL,\n\t\tcodeVerifier,\n\t\terrorURL: c.body?.errorCallbackURL,\n\t\tnewUserURL: c.body?.newUserCallbackURL,\n\t\tlink,\n\t\texpiresAt: Date.now() + 10 * 60 * 1000,\n\t\trequestSignUp: c.body?.requestSignUp,\n\t};\n\n\tawait setOAuthState(stateData);\n\n\ttry {\n\t\treturn generateGenericState(c, stateData);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to create verification\", error);\n\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\tmessage: \"Unable to create verification\",\n\t\t\tcause: error,\n\t\t});\n\t}\n}\n\nexport async function parseState(c: GenericEndpointContext) {\n\tconst state = c.query.state || c.body.state;\n\tconst errorURL =\n\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\n\tlet parsedData: StateData;\n\n\ttry {\n\t\tparsedData = await parseGenericState(c, state);\n\t} catch (error) {\n\t\tc.context.logger.error(\"Failed to parse state\", error);\n\n\t\tif (\n\t\t\terror instanceof StateError &&\n\t\t\terror.code === \"state_security_mismatch\"\n\t\t) {\n\t\t\tthrow c.redirect(`${errorURL}?error=state_mismatch`);\n\t\t}\n\n\t\tthrow c.redirect(`${errorURL}?error=please_restart_the_process`);\n\t}\n\n\tif (!parsedData.errorURL) {\n\t\tparsedData.errorURL = errorURL;\n\t}\n\n\tif (parsedData) {\n\t\tawait setOAuthState(parsedData);\n\t}\n\n\treturn parsedData;\n}\n"],"names":["stateData: StateData","parsedData: StateData"],"mappings":";;;;;;;;;;;;;;;;;;AAOA,eAAsB,cACrB,CAAA,EACA,IAAA,EAMA,cAAA,EACC;IACD,MAAM,cAAc,EAAE,IAAA,EAAM,eAAe,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA;IAC7D,IAAI,CAAC,YACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAGH,MAAM,mBAAe,iMAAA,EAAqB,IAAI;IAE9C,MAAMA,YAAuB;QAC5B,GAAI,iBAAiB,iBAAiB,CAAA,CAAE;QACxC;QACA;QACA,UAAU,EAAE,IAAA,EAAM;QAClB,YAAY,EAAE,IAAA,EAAM;QACpB;QACA,WAAW,KAAK,GAAA,EAAK,GAAG,MAAU;QAClC,eAAe,EAAE,IAAA,EAAM;KACvB;IAED,UAAM,qMAAA,EAAc,UAAU;IAE9B,IAAI;QACH,WAAO,sLAAA,EAAqB,GAAG,UAAU;aACjC,OAAO;QACf,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,iCAAiC,MAAM;QAC9D,MAAM,IAAI,0KAAA,CAAS,yBAAyB;YAC3C,SAAS;YACT,OAAO;SACP,CAAC;;;AAIJ,eAAsB,WAAW,CAAA,EAA2B;IAC3D,MAAM,QAAQ,EAAE,KAAA,CAAM,KAAA,IAAS,EAAE,IAAA,CAAK,KAAA;IACtC,MAAM,WACL,EAAE,OAAA,CAAQ,OAAA,CAAQ,UAAA,EAAY,YAAY,GAAG,EAAE,OAAA,CAAQ,OAAA,CAAQ,MAAA,CAAA;IAEhE,IAAIC;IAEJ,IAAI;QACH,aAAa,UAAM,mLAAA,EAAkB,GAAG,MAAM;aACtC,OAAO;QACf,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,yBAAyB,MAAM;QAEtD,IACC,iBAAiB,4KAAA,IACjB,MAAM,IAAA,KAAS,0BAEf,CAAA,MAAM,EAAE,QAAA,CAAS,GAAG,SAAS,qBAAA,CAAA,CAAuB;QAGrD,MAAM,EAAE,QAAA,CAAS,GAAG,SAAS,iCAAA,CAAA,CAAmC;;IAGjE,IAAI,CAAC,WAAW,QAAA,CACf,CAAA,WAAW,QAAA,GAAW;IAGvB,IAAI,WACH,CAAA,UAAM,qMAAA,EAAc,WAAW;IAGhC,OAAO"}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/hide-metadata.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/hide-metadata.ts"],"sourcesContent":["export const HIDE_METADATA = {\n\tscope: \"server\",\n} as const;\n"],"names":[],"mappings":";;;;;AAAA,MAAa,gBAAgB;IAC5B,OAAO;AAAA,CACP"}},
    {"offset": {"line": 1457, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/utils/index.mjs"],"sourcesContent":["import { generateGenericState, parseGenericState } from \"../state.mjs\";\nimport { generateState, parseState } from \"../oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./hide-metadata.mjs\";\nimport { generateId as generateId$1 } from \"@better-auth/core/utils\";\n\nexport { generateId$1 as generateId };"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAAA","ignoreList":[0]}},
    {"offset": {"line": 1472, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/get-request-ip.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/get-request-ip.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { isDevelopment, isTest } from \"@better-auth/core/env\";\nimport { isValidIP, normalizeIP } from \"@better-auth/core/utils\";\n\n// Localhost IP used for test and development environments\nconst LOCALHOST_IP = \"127.0.0.1\";\n\nexport function getIp(\n\treq: Request | Headers,\n\toptions: BetterAuthOptions,\n): string | null {\n\tif (options.advanced?.ipAddress?.disableIpTracking) {\n\t\treturn null;\n\t}\n\n\tconst headers = \"headers\" in req ? req.headers : req;\n\n\tconst defaultHeaders = [\"x-forwarded-for\"];\n\n\tconst ipHeaders =\n\t\toptions.advanced?.ipAddress?.ipAddressHeaders || defaultHeaders;\n\n\tfor (const key of ipHeaders) {\n\t\tconst value = \"get\" in headers ? headers.get(key) : headers[key];\n\t\tif (typeof value === \"string\") {\n\t\t\tconst ip = value.split(\",\")[0]!.trim();\n\t\t\tif (isValidIP(ip)) {\n\t\t\t\treturn normalizeIP(ip, {\n\t\t\t\t\tipv6Subnet: options.advanced?.ipAddress?.ipv6Subnet,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to localhost IP in development/test environments when no IP found in headers\n\tif (isTest() || isDevelopment()) {\n\t\treturn LOCALHOST_IP;\n\t}\n\n\treturn null;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAKA,MAAM,eAAe;AAErB,SAAgB,MACf,GAAA,EACA,OAAA,EACgB;IAChB,IAAI,QAAQ,QAAA,EAAU,WAAW,kBAChC,CAAA,OAAO;IAGR,MAAM,UAAU,aAAa,MAAM,IAAI,OAAA,GAAU;IAIjD,MAAM,YACL,QAAQ,QAAA,EAAU,WAAW,oBAHP;QAAC;KAAkB;IAK1C,KAAK,MAAM,OAAO,UAAW;QAC5B,MAAM,QAAQ,SAAS,UAAU,QAAQ,GAAA,CAAI,IAAI,GAAG,OAAA,CAAQ,IAAA;QAC5D,IAAI,OAAO,UAAU,UAAU;YAC9B,MAAM,KAAK,MAAM,KAAA,CAAM,IAAI,CAAC,EAAA,CAAI,IAAA,EAAM;YACtC,QAAI,2LAAA,EAAU,GAAG,CAChB,CAAA,WAAO,6LAAA,EAAY,IAAI;gBACtB,YAAY,QAAQ,QAAA,EAAU,WAAW;YAAA,CACzC,CAAC;;;IAML,QAAI,+LAAA,EAAQ,SAAI,sMAAA,EAAe,CAC9B,EAAA,OAAO;IAGR,OAAO"}},
    {"offset": {"line": 1508, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/url.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/url.ts"],"sourcesContent":["import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nfunction checkHasPath(url: string): boolean {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tconst pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n\t\treturn pathname !== \"/\";\n\t} catch {\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t);\n\t}\n}\n\nfunction assertHasProtocol(url: string): void {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`,\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t\t{\n\t\t\t\tcause: error,\n\t\t\t},\n\t\t);\n\t}\n}\n\nfunction withPath(url: string, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\n\tconst hasPath = checkHasPath(url);\n\tif (hasPath) {\n\t\treturn url;\n\t}\n\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\n\tif (!path || path === \"/\") {\n\t\treturn trimmedUrl;\n\t}\n\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\n\nfunction validateProxyHeader(header: string, type: \"host\" | \"proto\"): boolean {\n\tif (!header || header.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif (type === \"proto\") {\n\t\t// Only allow http and https protocols\n\t\treturn header === \"http\" || header === \"https\";\n\t}\n\n\tif (type === \"host\") {\n\t\tconst suspiciousPatterns = [\n\t\t\t/\\.\\./, // Path traversal\n\t\t\t/\\0/, // Null bytes\n\t\t\t/[\\s]/, // Whitespace (except legitimate spaces that should be trimmed)\n\t\t\t/^[.]/, // Starting with dot\n\t\t\t/[<>'\"]/, // HTML/script injection characters\n\t\t\t/javascript:/i, // Protocol injection\n\t\t\t/file:/i, // File protocol\n\t\t\t/data:/i, // Data protocol\n\t\t];\n\n\t\tif (suspiciousPatterns.some((pattern) => pattern.test(header))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Basic hostname validation (allows localhost, IPs, and domains with ports)\n\t\t// This is a simple check, not exhaustive RFC validation\n\t\tconst hostnameRegex =\n\t\t\t/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv4 addresses\n\t\tconst ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv6 addresses in brackets\n\t\tconst ipv6Regex = /^\\[[0-9a-fA-F:]+\\](:[0-9]{1,5})?$/;\n\n\t\t// Allow localhost variations\n\t\tconst localhostRegex = /^localhost(:[0-9]{1,5})?$/i;\n\n\t\treturn (\n\t\t\thostnameRegex.test(header) ||\n\t\t\tipv4Regex.test(header) ||\n\t\t\tipv6Regex.test(header) ||\n\t\t\tlocalhostRegex.test(header)\n\t\t);\n\t}\n\n\treturn false;\n}\n\nexport function getBaseURL(\n\turl?: string,\n\tpath?: string,\n\trequest?: Request,\n\tloadEnv?: boolean,\n\ttrustedProxyHeaders?: boolean | undefined,\n) {\n\tif (url) {\n\t\treturn withPath(url, path);\n\t}\n\n\tif (loadEnv !== false) {\n\t\tconst fromEnv =\n\t\t\tenv.BETTER_AUTH_URL ||\n\t\t\tenv.NEXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_AUTH_URL ||\n\t\t\t(env.BASE_URL !== \"/\" ? env.BASE_URL : undefined);\n\n\t\tif (fromEnv) {\n\t\t\treturn withPath(fromEnv, path);\n\t\t}\n\t}\n\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) {\n\t\tif (\n\t\t\tvalidateProxyHeader(fromRequestProto, \"proto\") &&\n\t\t\tvalidateProxyHeader(fromRequest, \"host\")\n\t\t) {\n\t\t\ttry {\n\t\t\t\treturn withPath(`${fromRequestProto}://${fromRequest}`, path);\n\t\t\t} catch (_error) {}\n\t\t}\n\t}\n\n\tif (request) {\n\t\tconst url = getOrigin(request.url);\n\t\tif (!url) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Could not get origin from request. Please provide a valid base URL.\",\n\t\t\t);\n\t\t}\n\t\treturn withPath(url, path);\n\t}\n\n\tif (typeof window !== \"undefined\" && window.location) {\n\t\treturn withPath(window.location.origin, path);\n\t}\n\treturn undefined;\n}\n\nexport function getOrigin(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\t// For custom URL schemes (like exp://), the origin property returns the string \"null\"\n\t\t// instead of null. We need to handle this case and return null so the fallback logic works.\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getProtocol(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.protocol;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getHost(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.host;\n\t} catch {\n\t\treturn null;\n\t}\n}\n"],"names":["url"],"mappings":"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"}},
    {"offset": {"line": 1617, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/wildcard.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/wildcard.ts"],"sourcesContent":["//https://github.com/axtgr/wildcard-match\n\n/**\n * Escapes a character if it has a special meaning in regular expressions\n * and returns the character as is if it doesn't\n */\nfunction escapeRegExpChar(char: string) {\n\tif (\n\t\tchar === \"-\" ||\n\t\tchar === \"^\" ||\n\t\tchar === \"$\" ||\n\t\tchar === \"+\" ||\n\t\tchar === \".\" ||\n\t\tchar === \"(\" ||\n\t\tchar === \")\" ||\n\t\tchar === \"|\" ||\n\t\tchar === \"[\" ||\n\t\tchar === \"]\" ||\n\t\tchar === \"{\" ||\n\t\tchar === \"}\" ||\n\t\tchar === \"*\" ||\n\t\tchar === \"?\" ||\n\t\tchar === \"\\\\\"\n\t) {\n\t\treturn `\\\\${char}`;\n\t} else {\n\t\treturn char;\n\t}\n}\n\n/**\n * Escapes all characters in a given string that have a special meaning in regular expressions\n */\nfunction escapeRegExpString(str: string) {\n\tlet result = \"\";\n\tfor (let i = 0; i < str.length; i++) {\n\t\tresult += escapeRegExpChar(str[i]!);\n\t}\n\treturn result;\n}\n\n/**\n * Transforms one or more glob patterns into a RegExp pattern\n */\nfunction transform(\n\tpattern: string | string[],\n\tseparator: string | boolean = true,\n): string {\n\tif (Array.isArray(pattern)) {\n\t\tconst regExpPatterns = pattern.map((p) => `^${transform(p, separator)}$`);\n\t\treturn `(?:${regExpPatterns.join(\"|\")})`;\n\t}\n\n\tlet separatorSplitter = \"\";\n\tlet separatorMatcher = \"\";\n\tlet wildcard = \".\";\n\n\tif (separator === true) {\n\t\t// In this case forward slashes in patterns match both forward and backslashes in samples:\n\t\t//\n\t\t// `foo/bar` will match `foo/bar`\n\t\t//           will match `foo\\bar`\n\t\t//\n\t\tseparatorSplitter = \"/\";\n\t\tseparatorMatcher = \"[/\\\\\\\\]\";\n\t\twildcard = \"[^/\\\\\\\\]\";\n\t} else if (separator) {\n\t\tseparatorSplitter = separator;\n\t\tseparatorMatcher = escapeRegExpString(separatorSplitter);\n\n\t\tif (separatorMatcher.length > 1) {\n\t\t\tseparatorMatcher = `(?:${separatorMatcher})`;\n\t\t\twildcard = `((?!${separatorMatcher}).)`;\n\t\t} else {\n\t\t\twildcard = `[^${separatorMatcher}]`;\n\t\t}\n\t}\n\n\t// When a separator is explicitly specified in a pattern,\n\t// it MUST match ONE OR MORE separators in a sample:\n\t//\n\t// `foo/bar/` will match  `foo//bar///`\n\t//            won't match `foo/bar`\n\t//\n\t// When a pattern doesn't have a trailing separator,\n\t// a sample can still optionally have them:\n\t//\n\t// `foo/bar` will match `foo/bar//`\n\t//\n\t// So we use different quantifiers depending on the index of a segment.\n\tconst requiredSeparator = separator ? `${separatorMatcher}+?` : \"\";\n\tconst optionalSeparator = separator ? `${separatorMatcher}*?` : \"\";\n\n\tconst segments = separator ? pattern.split(separatorSplitter) : [pattern];\n\tlet result = \"\";\n\n\tfor (let s = 0; s < segments.length; s++) {\n\t\tconst segment = segments[s]!;\n\t\tconst nextSegment = segments[s + 1]!;\n\t\tlet currentSeparator = \"\";\n\n\t\tif (!segment && s > 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (separator) {\n\t\t\tif (s === segments.length - 1) {\n\t\t\t\tcurrentSeparator = optionalSeparator;\n\t\t\t} else if (nextSegment !== \"**\") {\n\t\t\t\tcurrentSeparator = requiredSeparator;\n\t\t\t} else {\n\t\t\t\tcurrentSeparator = \"\";\n\t\t\t}\n\t\t}\n\n\t\tif (separator && segment === \"**\") {\n\t\t\tif (currentSeparator) {\n\t\t\t\tresult += s === 0 ? \"\" : currentSeparator;\n\t\t\t\tresult += `(?:${wildcard}*?${currentSeparator})*?`;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (let c = 0; c < segment.length; c++) {\n\t\t\tconst char = segment[c]!;\n\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tif (c < segment.length - 1) {\n\t\t\t\t\tresult += escapeRegExpChar(segment[c + 1]!);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t} else if (char === \"?\") {\n\t\t\t\tresult += wildcard;\n\t\t\t} else if (char === \"*\") {\n\t\t\t\tresult += `${wildcard}*?`;\n\t\t\t} else {\n\t\t\t\tresult += escapeRegExpChar(char);\n\t\t\t}\n\t\t}\n\n\t\tresult += currentSeparator;\n\t}\n\n\treturn result;\n}\n\ninterface WildcardMatchOptions {\n\t/** Separator to be used to split patterns and samples into segments */\n\tseparator?: string | boolean;\n\n\t/** Flags to pass to the RegExp */\n\tflags?: string;\n}\n\n// This overrides the function's signature because for the end user\n// the function is always bound to a RegExp\ninterface isMatch {\n\t/**\n\t * Tests if a sample string matches the pattern(s)\n\t *\n\t * ```js\n\t * isMatch('foo') //=> true\n\t * ```\n\t */\n\t(sample: string): boolean;\n\n\t/** Compiled regular expression */\n\tregexp: RegExp;\n\n\t/** Original pattern or array of patterns that was used to compile the RegExp */\n\tpattern: string | string[];\n\n\t/** Options that were used to compile the RegExp */\n\toptions: WildcardMatchOptions;\n}\n\nfunction isMatch(regexp: RegExp, sample: string) {\n\tif (typeof sample !== \"string\") {\n\t\tthrow new TypeError(`Sample must be a string, but ${typeof sample} given`);\n\t}\n\n\treturn regexp.test(sample);\n}\n\n/**\n * Compiles one or more glob patterns into a RegExp and returns an isMatch function.\n * The isMatch function takes a sample string as its only argument and returns `true`\n * if the string matches the pattern(s).\n *\n * ```js\n * wildcardMatch('src/*.js')('src/index.js') //=> true\n * ```\n *\n * ```js\n * const isMatch = wildcardMatch('*.example.com', '.')\n * isMatch('foo.example.com') //=> true\n * isMatch('foo.bar.com') //=> false\n * ```\n */\nfunction wildcardMatch(\n\tpattern: string | string[],\n\toptions?: string | boolean | WildcardMatchOptions,\n) {\n\tif (typeof pattern !== \"string\" && !Array.isArray(pattern)) {\n\t\tthrow new TypeError(\n\t\t\t`The first argument must be a single pattern string or an array of patterns, but ${typeof pattern} given`,\n\t\t);\n\t}\n\n\tif (typeof options === \"string\" || typeof options === \"boolean\") {\n\t\toptions = { separator: options };\n\t}\n\n\tif (\n\t\targuments.length === 2 &&\n\t\t!(\n\t\t\ttypeof options === \"undefined\" ||\n\t\t\t(typeof options === \"object\" &&\n\t\t\t\toptions !== null &&\n\t\t\t\t!Array.isArray(options))\n\t\t)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t`The second argument must be an options object or a string/boolean separator, but ${typeof options} given`,\n\t\t);\n\t}\n\n\toptions = options || {};\n\n\tif (options.separator === \"\\\\\") {\n\t\tthrow new Error(\n\t\t\t\"\\\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead\",\n\t\t);\n\t}\n\n\tconst regexpPattern = transform(pattern, options.separator);\n\tconst regexp = new RegExp(`^${regexpPattern}$`, options.flags);\n\n\tconst fn = isMatch.bind(null, regexp) as isMatch;\n\tfn.options = options;\n\tfn.pattern = pattern;\n\tfn.regexp = regexp;\n\treturn fn;\n}\n\nexport { wildcardMatch };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1731, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/auth/trusted-origins.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/auth/trusted-origins.ts"],"sourcesContent":["import { getHost, getOrigin, getProtocol } from \"../utils/url\";\nimport { wildcardMatch } from \"../utils/wildcard\";\n\n/**\n * Matches the given url against an origin or origin pattern\n * See \"options.trustedOrigins\" for details of supported patterns\n *\n * @param url The url to test\n * @param pattern The origin pattern\n * @param [settings] Specify supported pattern matching settings\n * @returns {boolean} true if the URL matches the origin pattern, false otherwise.\n */\nexport const matchesOriginPattern = (\n\turl: string,\n\tpattern: string,\n\tsettings?: { allowRelativePaths: boolean },\n): boolean => {\n\tif (url.startsWith(\"/\")) {\n\t\tif (settings?.allowRelativePaths) {\n\t\t\treturn (\n\t\t\t\turl.startsWith(\"/\") &&\n\t\t\t\t/^\\/(?!\\/|\\\\|%2f|%5c)[\\w\\-.\\+/@]*(?:\\?[\\w\\-.\\+/=&%@]*)?$/.test(url)\n\t\t\t);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// Check if pattern contains wildcard characters (*, **, or ?)\n\tconst hasWildcard = pattern.includes(\"*\") || pattern.includes(\"?\");\n\tif (hasWildcard) {\n\t\t// For protocol-specific wildcards, match the full origin\n\t\tif (pattern.includes(\"://\")) {\n\t\t\treturn wildcardMatch(pattern)(getOrigin(url) || url);\n\t\t}\n\t\tconst host = getHost(url);\n\t\tif (!host) {\n\t\t\treturn false;\n\t\t}\n\t\t// For host-only wildcards, match just the host\n\t\treturn wildcardMatch(pattern)(host);\n\t}\n\tconst protocol = getProtocol(url);\n\treturn protocol === \"http:\" || protocol === \"https:\" || !protocol\n\t\t? pattern === getOrigin(url)\n\t\t: url.startsWith(pattern);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;GAYA,MAAa,uBAAA,CACZ,KACA,SACA,aACa;IACb,IAAI,IAAI,UAAA,CAAW,IAAI,EAAE;QACxB,IAAI,UAAU,mBACb,CAAA,OACC,IAAI,UAAA,CAAW,IAAI,IACnB,0DAA0D,IAAA,CAAK,IAAI;QAIrE,OAAO;;IAKR,IADoB,QAAQ,QAAA,CAAS,IAAI,IAAI,QAAQ,QAAA,CAAS,IAAI,EACjD;QAEhB,IAAI,QAAQ,QAAA,CAAS,MAAM,CAC1B,CAAA,WAAO,2LAAA,EAAc,QAAQ,KAAC,kLAAA,EAAU,IAAI,IAAI,IAAI;QAErD,MAAM,WAAO,gLAAA,EAAQ,IAAI;QACzB,IAAI,CAAC,KACJ,CAAA,OAAO;QAGR,WAAO,2LAAA,EAAc,QAAQ,CAAC,KAAK;;IAEpC,MAAM,eAAW,oLAAA,EAAY,IAAI;IACjC,OAAO,aAAa,WAAW,aAAa,YAAY,CAAC,WACtD,gBAAY,kLAAA,EAAU,IAAI,GAC1B,IAAI,UAAA,CAAW,QAAQ"}},
    {"offset": {"line": 1768, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/middlewares/origin-check.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/middlewares/origin-check.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { createAuthMiddleware } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { deprecate, normalizePathname } from \"@better-auth/core/utils\";\nimport { APIError } from \"better-call\";\nimport { matchesOriginPattern } from \"../../auth/trusted-origins\";\n\n/**\n * Checks if CSRF should be skipped for backward compatibility.\n * Previously, disableOriginCheck also disabled CSRF checks.\n * This maintains that behavior when disableCSRFCheck isn't explicitly set.\n * Only triggers for skipOriginCheck === true, not for path arrays.\n */\nfunction shouldSkipCSRFForBackwardCompat(ctx: GenericEndpointContext): boolean {\n\treturn (\n\t\tctx.context.skipOriginCheck === true &&\n\t\tctx.context.options.advanced?.disableCSRFCheck === undefined\n\t);\n}\n\n/**\n * Logs deprecation warning for users relying on coupled behavior.\n * Only logs if user explicitly set disableOriginCheck (not test environment default).\n */\nconst logBackwardCompatWarning = deprecate(\n\tfunction logBackwardCompatWarning() {},\n\t\"disableOriginCheck: true currently also disables CSRF checks. \" +\n\t\t\"In a future version, disableOriginCheck will ONLY disable URL validation. \" +\n\t\t\"To keep CSRF disabled, add disableCSRFCheck: true to your config.\",\n);\n\n/**\n * A middleware to validate callbackURL and origin against trustedOrigins.\n * Also handles CSRF protection using Fetch Metadata for first-login scenarios.\n */\nexport const originCheckMiddleware = createAuthMiddleware(async (ctx) => {\n\t// Skip origin check for GET, OPTIONS, HEAD requests - we don't mutate state here.\n\tif (\n\t\tctx.request?.method === \"GET\" ||\n\t\tctx.request?.method === \"OPTIONS\" ||\n\t\tctx.request?.method === \"HEAD\" ||\n\t\t!ctx.request\n\t) {\n\t\treturn;\n\t}\n\tawait validateOrigin(ctx);\n\n\tif (ctx.context.skipOriginCheck) {\n\t\treturn;\n\t}\n\n\tconst { body, query } = ctx;\n\tconst callbackURL = body?.callbackURL || query?.callbackURL;\n\tconst redirectURL = body?.redirectTo;\n\tconst errorCallbackURL = body?.errorCallbackURL;\n\tconst newUserCallbackURL = body?.newUserCallbackURL;\n\n\tconst validateURL = (url: string | undefined, label: string) => {\n\t\tif (!url) {\n\t\t\treturn;\n\t\t}\n\t\tconst isTrustedOrigin = ctx.context.isTrustedOrigin(url, {\n\t\t\tallowRelativePaths: label !== \"origin\",\n\t\t});\n\n\t\tif (!isTrustedOrigin) {\n\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\tctx.context.logger.info(\n\t\t\t\t`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`,\n\t\t\t\t`Current list of trustedOrigins: ${ctx.context.trustedOrigins}`,\n\t\t\t);\n\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t}\n\t};\n\n\tcallbackURL && validateURL(callbackURL, \"callbackURL\");\n\tredirectURL && validateURL(redirectURL, \"redirectURL\");\n\terrorCallbackURL && validateURL(errorCallbackURL, \"errorCallbackURL\");\n\tnewUserCallbackURL && validateURL(newUserCallbackURL, \"newUserCallbackURL\");\n});\n\nexport const originCheck = (\n\tgetValue: (ctx: GenericEndpointContext) => string | string[],\n) =>\n\tcreateAuthMiddleware(async (ctx) => {\n\t\tif (!ctx.request) {\n\t\t\treturn;\n\t\t}\n\t\tif (ctx.context.skipOriginCheck) {\n\t\t\treturn;\n\t\t}\n\t\tconst callbackURL = getValue(ctx);\n\t\tconst validateURL = (url: string | undefined, label: string) => {\n\t\t\tif (!url) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isTrustedOrigin = ctx.context.isTrustedOrigin(url, {\n\t\t\t\tallowRelativePaths: label !== \"origin\",\n\t\t\t});\n\n\t\t\tif (!isTrustedOrigin) {\n\t\t\t\tctx.context.logger.error(`Invalid ${label}: ${url}`);\n\t\t\t\tctx.context.logger.info(\n\t\t\t\t\t`If it's a valid URL, please add ${url} to trustedOrigins in your auth config\\n`,\n\t\t\t\t\t`Current list of trustedOrigins: ${ctx.context.trustedOrigins}`,\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"FORBIDDEN\", { message: `Invalid ${label}` });\n\t\t\t}\n\t\t};\n\t\tconst callbacks = Array.isArray(callbackURL) ? callbackURL : [callbackURL];\n\t\tfor (const url of callbacks) {\n\t\t\tvalidateURL(url, \"callbackURL\");\n\t\t}\n\t});\n\n/**\n * Validates origin header against trusted origins.\n * @param ctx - The endpoint context\n * @param forceValidate - If true, always validate origin regardless of cookies/skip flags\n */\nasync function validateOrigin(\n\tctx: GenericEndpointContext,\n\tforceValidate = false,\n): Promise<void> {\n\tconst headers = ctx.request?.headers;\n\tif (!headers || !ctx.request) {\n\t\treturn;\n\t}\n\tconst originHeader = headers.get(\"origin\") || headers.get(\"referer\") || \"\";\n\tconst useCookies = headers.has(\"cookie\");\n\n\tif (ctx.context.skipCSRFCheck) {\n\t\treturn;\n\t}\n\n\tif (shouldSkipCSRFForBackwardCompat(ctx)) {\n\t\tctx.context.options.advanced?.disableOriginCheck === true &&\n\t\t\tlogBackwardCompatWarning();\n\t\treturn;\n\t}\n\n\tconst skipOriginCheck = ctx.context.skipOriginCheck;\n\tif (Array.isArray(skipOriginCheck)) {\n\t\ttry {\n\t\t\tconst basePath = new URL(ctx.context.baseURL).pathname;\n\t\t\tconst currentPath = normalizePathname(ctx.request.url, basePath);\n\t\t\tconst shouldSkipPath = skipOriginCheck.some((skipPath) =>\n\t\t\t\tcurrentPath.startsWith(skipPath),\n\t\t\t);\n\t\t\tif (shouldSkipPath) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch {\n\t\t\t// If parsing fails, don't skip - continue with validation\n\t\t}\n\t}\n\n\tconst shouldValidate = forceValidate || useCookies;\n\n\tif (!shouldValidate) {\n\t\treturn;\n\t}\n\n\tif (!originHeader || originHeader === \"null\") {\n\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\tmessage: BASE_ERROR_CODES.MISSING_OR_NULL_ORIGIN,\n\t\t});\n\t}\n\n\tconst trustedOrigins: string[] = Array.isArray(\n\t\tctx.context.options.trustedOrigins,\n\t)\n\t\t? ctx.context.trustedOrigins\n\t\t: [\n\t\t\t\t...ctx.context.trustedOrigins,\n\t\t\t\t...((await ctx.context.options.trustedOrigins?.(ctx.request))?.filter(\n\t\t\t\t\t(v): v is string => Boolean(v),\n\t\t\t\t) || []),\n\t\t\t];\n\n\tconst isTrustedOrigin = trustedOrigins.some((origin) =>\n\t\tmatchesOriginPattern(originHeader, origin),\n\t);\n\tif (!isTrustedOrigin) {\n\t\tctx.context.logger.error(`Invalid origin: ${originHeader}`);\n\t\tctx.context.logger.info(\n\t\t\t`If it's a valid URL, please add ${originHeader} to trustedOrigins in your auth config\\n`,\n\t\t\t`Current list of trustedOrigins: ${trustedOrigins}`,\n\t\t);\n\t\tthrow new APIError(\"FORBIDDEN\", { message: \"Invalid origin\" });\n\t}\n}\n\n/**\n * Middleware for CSRF protection using Fetch Metadata headers.\n * This prevents cross-site navigation login attacks while supporting progressive enhancement.\n */\nexport const formCsrfMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst request = ctx.request;\n\tif (!request) {\n\t\treturn;\n\t}\n\n\tawait validateFormCsrf(ctx);\n});\n\n/**\n * Validates CSRF protection for first-login scenarios using Fetch Metadata headers.\n * This prevents cross-site form submission attacks while supporting progressive enhancement.\n */\nasync function validateFormCsrf(ctx: GenericEndpointContext): Promise<void> {\n\tconst req = ctx.request;\n\tif (!req) {\n\t\treturn;\n\t}\n\n\tif (ctx.context.skipCSRFCheck) {\n\t\treturn;\n\t}\n\n\tif (shouldSkipCSRFForBackwardCompat(ctx)) {\n\t\treturn;\n\t}\n\n\tconst headers = req.headers;\n\tconst hasAnyCookies = headers.has(\"cookie\");\n\n\tif (hasAnyCookies) {\n\t\treturn await validateOrigin(ctx);\n\t}\n\n\tconst site = headers.get(\"Sec-Fetch-Site\");\n\tconst mode = headers.get(\"Sec-Fetch-Mode\");\n\tconst dest = headers.get(\"Sec-Fetch-Dest\");\n\n\tconst hasMetadata = Boolean(\n\t\t(site && site.trim()) || (mode && mode.trim()) || (dest && dest.trim()),\n\t);\n\n\tif (hasMetadata) {\n\t\t// Block cross-site navigation requests (classic CSRF attack pattern)\n\t\tif (site === \"cross-site\" && mode === \"navigate\") {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Blocked cross-site navigation login attempt (CSRF protection)\",\n\t\t\t\t{\n\t\t\t\t\tsecFetchSite: site,\n\t\t\t\t\tsecFetchMode: mode,\n\t\t\t\t\tsecFetchDest: dest,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.CROSS_SITE_NAVIGATION_LOGIN_BLOCKED,\n\t\t\t});\n\t\t}\n\n\t\treturn await validateOrigin(ctx, true);\n\t}\n\n\t// No cookies, no Fetch Metadata  fallback to old behavior (no validation)\n\treturn;\n}\n"],"names":["logBackwardCompatWarning","trustedOrigins: string[]"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;GAaA,SAAS,gCAAgC,GAAA,EAAsC;IAC9E,OACC,IAAI,OAAA,CAAQ,eAAA,KAAoB,QAChC,IAAI,OAAA,CAAQ,OAAA,CAAQ,QAAA,EAAU,qBAAqB,KAAA;;;;;GAQrD,MAAM,+BAA2B,kMAAA,EAChC,SAASA,6BAA2B,CAAA,GACpC,4MAGA;;;;GAMD,MAAa,4BAAwB,uMAAA,EAAqB,OAAO,QAAQ;IAExE,IACC,IAAI,OAAA,EAAS,WAAW,SACxB,IAAI,OAAA,EAAS,WAAW,aACxB,IAAI,OAAA,EAAS,WAAW,UACxB,CAAC,IAAI,OAAA,CAEL,CAAA;IAED,MAAM,eAAe,IAAI;IAEzB,IAAI,IAAI,OAAA,CAAQ,eAAA,CACf,CAAA;IAGD,MAAM,EAAE,IAAA,EAAM,KAAA,EAAA,GAAU;IACxB,MAAM,cAAc,MAAM,eAAe,OAAO;IAChD,MAAM,cAAc,MAAM;IAC1B,MAAM,mBAAmB,MAAM;IAC/B,MAAM,qBAAqB,MAAM;IAEjC,MAAM,cAAA,CAAe,KAAyB,UAAkB;QAC/D,IAAI,CAAC,IACJ,CAAA;QAMD,IAAI,CAJoB,IAAI,OAAA,CAAQ,eAAA,CAAgB,KAAK;YACxD,oBAAoB,UAAU;QAAA,CAC9B,CAAC,EAEoB;YACrB,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,CAAA,QAAA,EAAW,MAAM,EAAA,EAAI,KAAA,CAAM;YACpD,IAAI,OAAA,CAAQ,MAAA,CAAO,IAAA,CAClB,CAAA,gCAAA,EAAmC,IAAI,wCAAA,CAAA,EACvC,CAAA,gCAAA,EAAmC,IAAI,OAAA,CAAQ,cAAA,EAAA,CAC/C;YACD,MAAM,IAAI,0KAAA,CAAS,aAAa;gBAAE,SAAS,CAAA,QAAA,EAAW,OAAA;YAAA,CAAS,CAAC;;;IAIlE,eAAe,YAAY,aAAa,cAAc;IACtD,eAAe,YAAY,aAAa,cAAc;IACtD,oBAAoB,YAAY,kBAAkB,mBAAmB;IACrE,sBAAsB,YAAY,oBAAoB,qBAAqB;EAC1E;AAEF,MAAa,cAAA,CACZ,eAEA,uMAAA,EAAqB,OAAO,QAAQ;QACnC,IAAI,CAAC,IAAI,OAAA,CACR,CAAA;QAED,IAAI,IAAI,OAAA,CAAQ,eAAA,CACf,CAAA;QAED,MAAM,cAAc,SAAS,IAAI;QACjC,MAAM,cAAA,CAAe,KAAyB,UAAkB;YAC/D,IAAI,CAAC,IACJ,CAAA;YAMD,IAAI,CAJoB,IAAI,OAAA,CAAQ,eAAA,CAAgB,KAAK;gBACxD,oBAAoB,UAAU;YAAA,CAC9B,CAAC,EAEoB;gBACrB,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,CAAA,QAAA,EAAW,MAAM,EAAA,EAAI,KAAA,CAAM;gBACpD,IAAI,OAAA,CAAQ,MAAA,CAAO,IAAA,CAClB,CAAA,gCAAA,EAAmC,IAAI,wCAAA,CAAA,EACvC,CAAA,gCAAA,EAAmC,IAAI,OAAA,CAAQ,cAAA,EAAA,CAC/C;gBACD,MAAM,IAAI,0KAAA,CAAS,aAAa;oBAAE,SAAS,CAAA,QAAA,EAAW,OAAA;gBAAA,CAAS,CAAC;;;QAGlE,MAAM,YAAY,MAAM,OAAA,CAAQ,YAAY,GAAG,cAAc;YAAC;SAAY;QAC1E,KAAK,MAAM,OAAO,UACjB,YAAY,KAAK,cAAc;MAE/B;;;;;GAOH,eAAe,eACd,GAAA,EACA,gBAAgB,KAAA,EACA;IAChB,MAAM,UAAU,IAAI,OAAA,EAAS;IAC7B,IAAI,CAAC,WAAW,CAAC,IAAI,OAAA,CACpB,CAAA;IAED,MAAM,eAAe,QAAQ,GAAA,CAAI,SAAS,IAAI,QAAQ,GAAA,CAAI,UAAU,IAAI;IACxE,MAAM,aAAa,QAAQ,GAAA,CAAI,SAAS;IAExC,IAAI,IAAI,OAAA,CAAQ,aAAA,CACf,CAAA;IAGD,IAAI,gCAAgC,IAAI,EAAE;QACzC,IAAI,OAAA,CAAQ,OAAA,CAAQ,QAAA,EAAU,uBAAuB,QACpD,0BAA0B;QAC3B;;IAGD,MAAM,kBAAkB,IAAI,OAAA,CAAQ,eAAA;IACpC,IAAI,MAAM,OAAA,CAAQ,gBAAgB,CACjC,CAAA,IAAI;QACH,MAAM,WAAW,IAAI,IAAI,IAAI,OAAA,CAAQ,OAAA,CAAQ,CAAC,QAAA;QAC9C,MAAM,kBAAc,oMAAA,EAAkB,IAAI,OAAA,CAAQ,GAAA,EAAK,SAAS;QAIhE,IAHuB,gBAAgB,IAAA,CAAA,CAAM,WAC5C,YAAY,UAAA,CAAW,SAAS,CAChC,CAEA,CAAA;aAEM,CAAA;IAOT,IAAI,CAAA,CAFmB,iBAAiB,UAAA,EAGvC,CAAA;IAGD,IAAI,CAAC,gBAAgB,iBAAiB,OACrC,CAAA,MAAM,IAAI,0KAAA,CAAS,aAAa;QAC/B,SAAS,qMAAA,CAAiB,sBAAA;IAAA,CAC1B,CAAC;IAGH,MAAMC,iBAA2B,MAAM,OAAA,CACtC,IAAI,OAAA,CAAQ,OAAA,CAAQ,cAAA,CACpB,GACE,IAAI,OAAA,CAAQ,cAAA,GACZ,CACA;WAAG,IAAI,OAAA,CAAQ,cAAA,EACf;WAAA,CAAK,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,cAAA,GAAiB,IAAI,OAAA,CAAQ,GAAG,OAAA,CAC7D,IAAmB,QAAQ,EAAE,CAC9B,IAAI,EAAE;KACP;IAKH,IAAI,CAHoB,eAAe,IAAA,CAAA,CAAM,aAC5C,2MAAA,EAAqB,cAAc,OAAO,CAC1C,EACqB;QACrB,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,CAAA,gBAAA,EAAmB,cAAA,CAAe;QAC3D,IAAI,OAAA,CAAQ,MAAA,CAAO,IAAA,CAClB,CAAA,gCAAA,EAAmC,aAAa,wCAAA,CAAA,EAChD,CAAA,gCAAA,EAAmC,gBAAA,CACnC;QACD,MAAM,IAAI,0KAAA,CAAS,aAAa;YAAE,SAAS;QAAA,CAAkB,CAAC;;;;;;GAQhE,MAAa,yBAAqB,uMAAA,EAAqB,OAAO,QAAQ;IAErE,IAAI,CADY,IAAI,OAAA,CAEnB,CAAA;IAGD,MAAM,iBAAiB,IAAI;EAC1B;;;;GAMF,eAAe,iBAAiB,GAAA,EAA4C;IAC3E,MAAM,MAAM,IAAI,OAAA;IAChB,IAAI,CAAC,IACJ,CAAA;IAGD,IAAI,IAAI,OAAA,CAAQ,aAAA,CACf,CAAA;IAGD,IAAI,gCAAgC,IAAI,CACvC,CAAA;IAGD,MAAM,UAAU,IAAI,OAAA;IAGpB,IAFsB,QAAQ,GAAA,CAAI,SAAS,CAG1C,CAAA,OAAO,MAAM,eAAe,IAAI;IAGjC,MAAM,OAAO,QAAQ,GAAA,CAAI,iBAAiB;IAC1C,MAAM,OAAO,QAAQ,GAAA,CAAI,iBAAiB;IAC1C,MAAM,OAAO,QAAQ,GAAA,CAAI,iBAAiB;IAM1C,IAJoB,QAClB,QAAQ,KAAK,IAAA,EAAM,IAAM,QAAQ,KAAK,IAAA,EAAM,IAAM,QAAQ,KAAK,IAAA,EAAM,CACtE,EAEgB;QAEhB,IAAI,SAAS,gBAAgB,SAAS,YAAY;YACjD,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAClB,iEACA;gBACC,cAAc;gBACd,cAAc;gBACd,cAAc;aACd,CACD;YACD,MAAM,IAAI,0KAAA,CAAS,aAAa;gBAC/B,SAAS,qMAAA,CAAiB,mCAAA;YAAA,CAC1B,CAAC;;QAGH,OAAO,MAAM,eAAe,KAAK,KAAK"}},
    {"offset": {"line": 1929, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/api/middlewares/index.mjs"],"sourcesContent":["import { getOAuthState } from \"./oauth.mjs\";\nimport { formCsrfMiddleware, originCheck, originCheckMiddleware } from \"./origin-check.mjs\";\n\nexport {  };"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0]}},
    {"offset": {"line": 1939, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/rate-limiter/index.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/rate-limiter/index.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthRateLimitStorage,\n} from \"@better-auth/core\";\nimport {\n\tcreateRateLimitKey,\n\tnormalizePathname,\n\tsafeJSONParse,\n} from \"@better-auth/core/utils\";\nimport type { RateLimit } from \"../../types\";\nimport { getIp } from \"../../utils/get-request-ip\";\nimport { wildcardMatch } from \"../../utils/wildcard\";\n\ninterface MemoryRateLimitEntry {\n\tdata: RateLimit;\n\texpiresAt: number;\n}\n\nconst memory = new Map<string, MemoryRateLimitEntry>();\n\nfunction shouldRateLimit(\n\tmax: number,\n\twindow: number,\n\trateLimitData: RateLimit,\n) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1000;\n\tconst timeSinceLastRequest = now - rateLimitData.lastRequest;\n\treturn timeSinceLastRequest < windowInMs && rateLimitData.count >= max;\n}\n\nfunction rateLimitResponse(retryAfter: number) {\n\treturn new Response(\n\t\tJSON.stringify({\n\t\t\tmessage: \"Too many requests. Please try again later.\",\n\t\t}),\n\t\t{\n\t\t\tstatus: 429,\n\t\t\tstatusText: \"Too Many Requests\",\n\t\t\theaders: {\n\t\t\t\t\"X-Retry-After\": retryAfter.toString(),\n\t\t\t},\n\t\t},\n\t);\n}\n\nfunction getRetryAfter(lastRequest: number, window: number) {\n\tconst now = Date.now();\n\tconst windowInMs = window * 1000;\n\treturn Math.ceil((lastRequest + windowInMs - now) / 1000);\n}\n\nfunction createDatabaseStorageWrapper(\n\tctx: AuthContext,\n): BetterAuthRateLimitStorage {\n\tconst model = \"rateLimit\";\n\tconst db = ctx.adapter;\n\treturn {\n\t\tget: async (key: string) => {\n\t\t\tconst res = await db.findMany<RateLimit>({\n\t\t\t\tmodel,\n\t\t\t\twhere: [{ field: \"key\", value: key }],\n\t\t\t});\n\t\t\tconst data = res[0];\n\n\t\t\tif (typeof data?.lastRequest === \"bigint\") {\n\t\t\t\tdata.lastRequest = Number(data.lastRequest);\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\t\tset: async (\n\t\t\tkey: string,\n\t\t\tvalue: RateLimit,\n\t\t\t_update?: boolean | undefined,\n\t\t) => {\n\t\t\ttry {\n\t\t\t\tif (_update) {\n\t\t\t\t\tawait db.updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere: [{ field: \"key\", value: key }],\n\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\t\tlastRequest: value.lastRequest,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait db.create({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tcount: value.count,\n\t\t\t\t\t\t\tlastRequest: value.lastRequest,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tctx.logger.error(\"Error setting rate limit\", e);\n\t\t\t}\n\t\t},\n\t};\n}\n\nfunction getRateLimitStorage(\n\tctx: AuthContext,\n\trateLimitSettings: {\n\t\twindow: number;\n\t},\n): BetterAuthRateLimitStorage {\n\tif (ctx.options.rateLimit?.customStorage) {\n\t\treturn ctx.options.rateLimit.customStorage;\n\t}\n\tconst storage = ctx.rateLimit.storage;\n\tif (storage === \"secondary-storage\") {\n\t\treturn {\n\t\t\tget: async (key: string) => {\n\t\t\t\tconst data = await ctx.options.secondaryStorage?.get(key);\n\t\t\t\treturn data ? safeJSONParse<RateLimit>(data) : null;\n\t\t\t},\n\t\t\tset: async (\n\t\t\t\tkey: string,\n\t\t\t\tvalue: RateLimit,\n\t\t\t\t_update?: boolean | undefined,\n\t\t\t) => {\n\t\t\t\tconst ttl =\n\t\t\t\t\trateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;\n\t\t\t\tawait ctx.options.secondaryStorage?.set?.(\n\t\t\t\t\tkey,\n\t\t\t\t\tJSON.stringify(value),\n\t\t\t\t\tttl,\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t} else if (storage === \"memory\") {\n\t\treturn {\n\t\t\tasync get(key: string) {\n\t\t\t\tconst entry = memory.get(key);\n\t\t\t\tif (!entry) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Check if entry has expired\n\t\t\t\tif (Date.now() >= entry.expiresAt) {\n\t\t\t\t\tmemory.delete(key);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn entry.data;\n\t\t\t},\n\t\t\tasync set(key: string, value: RateLimit, _update?: boolean | undefined) {\n\t\t\t\tconst ttl =\n\t\t\t\t\trateLimitSettings?.window ?? ctx.options.rateLimit?.window ?? 10;\n\t\t\t\tconst expiresAt = Date.now() + ttl * 1000;\n\t\t\t\tmemory.set(key, {\n\t\t\t\t\tdata: value,\n\t\t\t\t\texpiresAt,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\treturn createDatabaseStorageWrapper(ctx);\n}\n\nexport async function onRequestRateLimit(req: Request, ctx: AuthContext) {\n\tif (!ctx.rateLimit.enabled) {\n\t\treturn;\n\t}\n\tconst basePath = new URL(ctx.baseURL).pathname;\n\tconst path = normalizePathname(req.url, basePath);\n\tlet currentWindow = ctx.rateLimit.window;\n\tlet currentMax = ctx.rateLimit.max;\n\tconst ip = getIp(req, ctx.options);\n\tif (!ip) {\n\t\treturn;\n\t}\n\tconst key = createRateLimitKey(ip, path);\n\tconst specialRules = getDefaultSpecialRules();\n\tconst specialRule = specialRules.find((rule) => rule.pathMatcher(path));\n\n\tif (specialRule) {\n\t\tcurrentWindow = specialRule.window;\n\t\tcurrentMax = specialRule.max;\n\t}\n\n\tfor (const plugin of ctx.options.plugins || []) {\n\t\tif (plugin.rateLimit) {\n\t\t\tconst matchedRule = plugin.rateLimit.find((rule) =>\n\t\t\t\trule.pathMatcher(path),\n\t\t\t);\n\t\t\tif (matchedRule) {\n\t\t\t\tcurrentWindow = matchedRule.window;\n\t\t\t\tcurrentMax = matchedRule.max;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx.rateLimit.customRules) {\n\t\tconst _path = Object.keys(ctx.rateLimit.customRules).find((p) => {\n\t\t\tif (p.includes(\"*\")) {\n\t\t\t\tconst isMatch = wildcardMatch(p)(path);\n\t\t\t\treturn isMatch;\n\t\t\t}\n\t\t\treturn p === path;\n\t\t});\n\t\tif (_path) {\n\t\t\tconst customRule = ctx.rateLimit.customRules[_path];\n\t\t\tconst resolved =\n\t\t\t\ttypeof customRule === \"function\"\n\t\t\t\t\t? await customRule(req, {\n\t\t\t\t\t\t\twindow: currentWindow,\n\t\t\t\t\t\t\tmax: currentMax,\n\t\t\t\t\t\t})\n\t\t\t\t\t: customRule;\n\t\t\tif (resolved) {\n\t\t\t\tcurrentWindow = resolved.window;\n\t\t\t\tcurrentMax = resolved.max;\n\t\t\t}\n\n\t\t\tif (resolved === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst storage = getRateLimitStorage(ctx, {\n\t\twindow: currentWindow,\n\t});\n\tconst data = await storage.get(key);\n\tconst now = Date.now();\n\n\tif (!data) {\n\t\tawait storage.set(key, {\n\t\t\tkey,\n\t\t\tcount: 1,\n\t\t\tlastRequest: now,\n\t\t});\n\t} else {\n\t\tconst timeSinceLastRequest = now - data.lastRequest;\n\n\t\tif (shouldRateLimit(currentMax, currentWindow, data)) {\n\t\t\tconst retryAfter = getRetryAfter(data.lastRequest, currentWindow);\n\t\t\treturn rateLimitResponse(retryAfter);\n\t\t} else if (timeSinceLastRequest > currentWindow * 1000) {\n\t\t\t// Reset the count if the window has passed since the last request\n\t\t\tawait storage.set(\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\t...data,\n\t\t\t\t\tcount: 1,\n\t\t\t\t\tlastRequest: now,\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t);\n\t\t} else {\n\t\t\tawait storage.set(\n\t\t\t\tkey,\n\t\t\t\t{\n\t\t\t\t\t...data,\n\t\t\t\t\tcount: data.count + 1,\n\t\t\t\t\tlastRequest: now,\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t);\n\t\t}\n\t}\n}\n\nfunction getDefaultSpecialRules() {\n\tconst specialRules = [\n\t\t{\n\t\t\tpathMatcher(path: string) {\n\t\t\t\treturn (\n\t\t\t\t\tpath.startsWith(\"/sign-in\") ||\n\t\t\t\t\tpath.startsWith(\"/sign-up\") ||\n\t\t\t\t\tpath.startsWith(\"/change-password\") ||\n\t\t\t\t\tpath.startsWith(\"/change-email\")\n\t\t\t\t);\n\t\t\t},\n\t\t\twindow: 10,\n\t\t\tmax: 3,\n\t\t},\n\t];\n\treturn specialRules;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/_virtual/rolldown_runtime.mjs"],"sourcesContent":["//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (all, symbols) => {\n\tlet target = {};\n\tfor (var name in all) {\n\t\t__defProp(target, name, {\n\t\t\tget: all[name],\n\t\t\tenumerable: true\n\t\t});\n\t}\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\treturn target;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") {\n\t\tfor (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\t\tkey = keys[i];\n\t\t\tif (!__hasOwnProp.call(to, key) && key !== except) {\n\t\t\t\t__defProp(to, key, {\n\t\t\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn to;\n};\nvar __reExport = (target, mod, secondTarget, symbols) => {\n\tif (symbols) {\n\t\t__defProp(target, Symbol.toStringTag, { value: \"Module\" });\n\t\tsecondTarget && __defProp(secondTarget, Symbol.toStringTag, { value: \"Module\" });\n\t}\n\t__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\");\n};\n\n//#endregion\nexport { __export, __reExport };"],"names":[],"mappings":";;;;;;AAAA,0BAA0B;AAC1B,IAAI,YAAY,OAAO,cAAc;AACrC,IAAI,mBAAmB,OAAO,wBAAwB;AACtD,IAAI,oBAAoB,OAAO,mBAAmB;AAClD,IAAI,eAAe,OAAO,SAAS,CAAC,cAAc;AAClD,IAAI,WAAW,CAAC,KAAK;IACpB,IAAI,SAAS,CAAC;IACd,IAAK,IAAI,QAAQ,IAAK;QACrB,UAAU,QAAQ,MAAM;YACvB,KAAK,GAAG,CAAC,KAAK;YACd,YAAY;QACb;IACD;IACA,IAAI,SAAS;QACZ,UAAU,QAAQ,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;IACzD;IACA,OAAO;AACR;AACA,IAAI,cAAc,CAAC,IAAI,MAAM,QAAQ;IACpC,IAAI,QAAQ,OAAO,SAAS,YAAY,OAAO,SAAS,YAAY;QACnE,IAAK,IAAI,OAAO,kBAAkB,OAAO,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,IAAI,GAAG,IAAK;YACjF,MAAM,IAAI,CAAC,EAAE;YACb,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,QAAQ,QAAQ,QAAQ;gBAClD,UAAU,IAAI,KAAK;oBAClB,KAAK,CAAC,CAAC,IAAM,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM;oBACjC,YAAY,CAAC,CAAC,OAAO,iBAAiB,MAAM,IAAI,KAAK,KAAK,UAAU;gBACrE;YACD;QACD;IACD;IACA,OAAO;AACR;AACA,IAAI,aAAa,CAAC,QAAQ,KAAK,cAAc;IAC5C,IAAI,SAAS;QACZ,UAAU,QAAQ,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;QACxD,gBAAgB,UAAU,cAAc,OAAO,WAAW,EAAE;YAAE,OAAO;QAAS;IAC/E;IACA,YAAY,QAAQ,KAAK,YAAY,gBAAgB,YAAY,cAAc,KAAK;AACrF","ignoreList":[0]}},
    {"offset": {"line": 2193, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/adapter-base.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/adapter-base.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport type { MemoryDB } from \"../adapters/memory-adapter\";\n\nexport async function getBaseAdapter(\n\toptions: BetterAuthOptions,\n\thandleDirectDatabase: (\n\t\toptions: BetterAuthOptions,\n\t) => Promise<DBAdapter<BetterAuthOptions>>,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\tlet adapter: DBAdapter<BetterAuthOptions>;\n\n\tif (!options.database) {\n\t\tconst tables = getAuthTables(options);\n\t\tconst memoryDB = Object.keys(tables).reduce<MemoryDB>((acc, key) => {\n\t\t\tacc[key] = [];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tconst { memoryAdapter } = await import(\"../adapters/memory-adapter\");\n\t\tadapter = memoryAdapter(memoryDB)(options);\n\t} else if (typeof options.database === \"function\") {\n\t\tadapter = options.database(options);\n\t} else {\n\t\tadapter = await handleDirectDatabase(options);\n\t}\n\n\t// patch for 1.3.x to ensure we have a transaction function in the adapter\n\tif (!adapter.transaction) {\n\t\tlogger.warn(\n\t\t\t\"Adapter does not correctly implement transaction function, patching it automatically. Please update your adapter implementation.\",\n\t\t);\n\t\tadapter.transaction = async (cb) => {\n\t\t\treturn cb(adapter);\n\t\t};\n\t}\n\n\treturn adapter;\n}\n"],"names":["adapter: DBAdapter<BetterAuthOptions>"],"mappings":";;;;;;;;;;;AAMA,eAAsB,eACrB,OAAA,EACA,oBAAA,EAGwC;IACxC,IAAIA;IAEJ,IAAI,CAAC,QAAQ,QAAA,EAAU;QACtB,MAAM,aAAS,uMAAA,EAAc,QAAQ;QACrC,MAAM,WAAW,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAkB,KAAK,QAAQ;YACnE,GAAA,CAAI,IAAA,GAAO,EAAE;YACb,OAAO;WACL,CAAA,CAAE,CAAC;QACN,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,UAAU,cAAc,SAAS,CAAC,QAAQ;eAChC,OAAO,QAAQ,QAAA,KAAa,WACtC,CAAA,UAAU,QAAQ,QAAA,CAAS,QAAQ;SAEnC,UAAU,MAAM,qBAAqB,QAAQ;IAI9C,IAAI,CAAC,QAAQ,WAAA,EAAa;QACzB,0LAAA,CAAO,IAAA,CACN,mIACA;QACD,QAAQ,WAAA,GAAc,OAAO,OAAO;YACnC,OAAO,GAAG,QAAQ;;;IAIpB,OAAO"}},
    {"offset": {"line": 2230, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/adapter-kysely.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/adapter-kysely.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport { getBaseAdapter } from \"./adapter-base\";\n\nexport async function getAdapter(\n\toptions: BetterAuthOptions,\n): Promise<DBAdapter<BetterAuthOptions>> {\n\treturn getBaseAdapter(options, async (opts) => {\n\t\tconst { createKyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\tconst { kysely, databaseType, transaction } =\n\t\t\tawait createKyselyAdapter(opts);\n\t\tif (!kysely) {\n\t\t\tthrow new BetterAuthError(\"Failed to initialize database adapter\");\n\t\t}\n\t\tconst { kyselyAdapter } = await import(\"../adapters/kysely-adapter\");\n\t\treturn kyselyAdapter(kysely, {\n\t\t\ttype: databaseType || \"sqlite\",\n\t\t\tdebugLogs:\n\t\t\t\topts.database && \"debugLogs\" in opts.database\n\t\t\t\t\t? opts.database.debugLogs\n\t\t\t\t\t: false,\n\t\t\ttransaction: transaction,\n\t\t})(opts);\n\t});\n}\n"],"names":[],"mappings":";;;;;;;;;AAKA,eAAsB,WACrB,OAAA,EACwC;IACxC,WAAO,gMAAA,EAAe,SAAS,OAAO,SAAS;QAC9C,MAAM,EAAE,mBAAA,EAAA,GAAwB,MAAM,OAAO;QAC7C,MAAM,EAAE,MAAA,EAAQ,YAAA,EAAc,WAAA,EAAA,GAC7B,MAAM,oBAAoB,KAAK;QAChC,IAAI,CAAC,OACJ,CAAA,MAAM,IAAI,oNAAA,CAAgB,wCAAwC;QAEnE,MAAM,EAAE,aAAA,EAAA,GAAkB,MAAM,OAAO;QACvC,OAAO,cAAc,QAAQ;YAC5B,MAAM,gBAAgB;YACtB,WACC,KAAK,QAAA,IAAY,eAAe,KAAK,QAAA,GAClC,KAAK,QAAA,CAAS,SAAA,GACd;YACS;SACb,CAAC,CAAC,KAAK;MACP"}},
    {"offset": {"line": 2258, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/field.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/field.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tDBFieldAttribute,\n\tDBFieldAttributeConfig,\n\tDBFieldType,\n} from \"@better-auth/core/db\";\n\nexport const createFieldAttribute = <\n\tT extends DBFieldType,\n\tC extends DBFieldAttributeConfig,\n>(\n\ttype: T,\n\tconfig?: C | undefined,\n) => {\n\treturn {\n\t\ttype,\n\t\t...config,\n\t} satisfies DBFieldAttribute<T>;\n};\n\nexport type InferValueType<T extends DBFieldType> = T extends \"string\"\n\t? string\n\t: T extends \"number\"\n\t\t? number\n\t\t: T extends \"boolean\"\n\t\t\t? boolean\n\t\t\t: T extends \"date\"\n\t\t\t\t? Date\n\t\t\t\t: T extends \"json\"\n\t\t\t\t\t? Record<string, any>\n\t\t\t\t\t: T extends `${infer U}[]`\n\t\t\t\t\t\t? U extends \"string\"\n\t\t\t\t\t\t\t? string[]\n\t\t\t\t\t\t\t: number[]\n\t\t\t\t\t\t: T extends Array<any>\n\t\t\t\t\t\t\t? T[number]\n\t\t\t\t\t\t\t: never;\n\nexport type InferFieldsOutput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: key]: InferFieldOutput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"returned\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key\n\t\t\t\t\t\t: never]?: InferFieldOutput<Field[key]> | null;\n\t\t\t}\n\t\t: {};\n\nexport type InferFieldsInput<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false ? never : key]?:\n\t\t\t\t\t| InferFieldInput<Field[key]>\n\t\t\t\t\t| undefined\n\t\t\t\t\t| null;\n\t\t\t}\n\t\t: {};\n\n/**\n * For client will add \"?\" on optional fields\n */\nexport type InferFieldsInputClient<Field> =\n\tField extends Record<infer Key, DBFieldAttribute>\n\t\t? {\n\t\t\t\t[key in Key as Field[key][\"required\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"defaultValue\"] extends string | number | boolean | Date\n\t\t\t\t\t\t? never\n\t\t\t\t\t\t: Field[key][\"input\"] extends false\n\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t: key]: InferFieldInput<Field[key]>;\n\t\t\t} & {\n\t\t\t\t[key in Key as Field[key][\"input\"] extends false\n\t\t\t\t\t? never\n\t\t\t\t\t: Field[key][\"required\"] extends false\n\t\t\t\t\t\t? key\n\t\t\t\t\t\t: Field[key][\"defaultValue\"] extends\n\t\t\t\t\t\t\t\t\t| string\n\t\t\t\t\t\t\t\t\t| number\n\t\t\t\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t\t\t\t| Date\n\t\t\t\t\t\t\t? key\n\t\t\t\t\t\t\t: never]?: InferFieldInput<Field[key]> | undefined | null;\n\t\t\t}\n\t\t: {};\n\ntype InferFieldOutput<T extends DBFieldAttribute> = T[\"returned\"] extends false\n\t? never\n\t: T[\"required\"] extends false\n\t\t? InferValueType<T[\"type\"]> | undefined | null\n\t\t: InferValueType<T[\"type\"]>;\n\n/**\n * Converts a Record<string, DBFieldAttribute> to an object type\n * with keys and value types inferred from DBFieldAttribute[\"type\"].\n */\nexport type FieldAttributeToObject<\n\tFields extends Record<string, DBFieldAttribute>,\n> = AddOptionalFields<\n\t{\n\t\t[K in keyof Fields]: InferValueType<Fields[K][\"type\"]>;\n\t},\n\tFields\n>;\n\ntype AddOptionalFields<\n\tT extends Record<string, any>,\n\tFields extends Record<keyof T, DBFieldAttribute>,\n> = {\n\t// Required fields: required === true\n\t[K in keyof T as Fields[K] extends { required: true } ? K : never]: T[K];\n} & {\n\t// Optional fields: required !== true\n\t[K in keyof T as Fields[K] extends { required: true } ? never : K]?: T[K];\n};\n\n/**\n * Infer the additional fields from the plugin options.\n * For example, you can infer the additional fields of the org plugin's organization schema like this:\n * ```ts\n * type AdditionalFields = InferAdditionalFieldsFromPluginOptions<\"organization\", OrganizationOptions>\n * ```\n *\n * @param isClientSide - When `true` (default), filters out `input: false` fields (clients can't send these).\n *   When `false`, includes all fields (for internal/server-side use).\n */\nexport type InferAdditionalFieldsFromPluginOptions<\n\tSchemaName extends string,\n\tOptions extends {\n\t\tschema?:\n\t\t\t| {\n\t\t\t\t\t[key in SchemaName]?: {\n\t\t\t\t\t\tadditionalFields?: Record<string, DBFieldAttribute>;\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| undefined;\n\t},\n\tisClientSide extends boolean = true,\n> = Options[\"schema\"] extends {\n\t[key in SchemaName]?: {\n\t\tadditionalFields: infer Field extends Record<string, DBFieldAttribute>;\n\t};\n}\n\t? isClientSide extends true\n\t\t? FieldAttributeToObject<RemoveFieldsWithInputFalse<Field>>\n\t\t: FieldAttributeToObject<Field>\n\t: {};\n\ntype RemoveFieldsWithInputFalse<T extends Record<string, DBFieldAttribute>> = {\n\t[K in keyof T as T[K][\"input\"] extends false ? never : K]: T[K];\n};\n\nexport type RemoveFieldsWithReturnedFalse<\n\tT extends Record<string, DBFieldAttribute>,\n> = {\n\t[K in keyof T as T[K][\"returned\"] extends false ? never : K]: T[K];\n};\n\ntype InferFieldInput<T extends DBFieldAttribute> = InferValueType<T[\"type\"]>;\n\nexport type PluginFieldAttribute = Omit<\n\tDBFieldAttribute,\n\t\"transform\" | \"defaultValue\" | \"hashValue\"\n>;\n\nexport type InferFieldsFromPlugins<\n\tOptions extends BetterAuthOptions,\n\tKey extends string,\n\tFormat extends \"output\" | \"input\",\n> = Options[\"plugins\"] extends []\n\t? {}\n\t: Options[\"plugins\"] extends Array<infer T>\n\t\t? T extends {\n\t\t\t\tschema: {\n\t\t\t\t\t[key in Key]: {\n\t\t\t\t\t\tfields: infer Field;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t\t? Format extends \"output\"\n\t\t\t\t? InferFieldsOutput<Field>\n\t\t\t\t: InferFieldsInput<Field>\n\t\t\t: {}\n\t\t: {};\n\nexport type InferFieldsFromOptions<\n\tOptions extends BetterAuthOptions,\n\tKey extends \"session\" | \"user\",\n\tFormat extends \"output\" | \"input\",\n> = Options[Key] extends {\n\tadditionalFields: infer Field;\n}\n\t? Format extends \"output\"\n\t\t? InferFieldsOutput<Field>\n\t\t: InferFieldsInput<Field>\n\t: {};\n"],"names":[],"mappings":";;;;;AAOA,MAAa,uBAAA,CAIZ,MACA,WACI;IACJ,OAAO;QACN;QACA,GAAG,MAAA;KACH"}},
    {"offset": {"line": 2275, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/field-converter.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/field-converter.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\n\nexport function convertToDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T,\n) {\n\tconst result: Record<string, any> = values.id\n\t\t? {\n\t\t\t\tid: values.id,\n\t\t\t}\n\t\t: {};\n\tfor (const key in fields) {\n\t\tconst field = fields[key]!;\n\t\tconst value = values[key];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult[field.fieldName || key] = value;\n\t}\n\treturn result as T;\n}\n\nexport function convertFromDB<T extends Record<string, any>>(\n\tfields: Record<string, DBFieldAttribute>,\n\tvalues: T | null,\n) {\n\tif (!values) {\n\t\treturn null;\n\t}\n\tconst result: Record<string, any> = {\n\t\tid: values.id,\n\t};\n\tfor (const [key, value] of Object.entries(fields)) {\n\t\tresult[key] = values[value.fieldName || key];\n\t}\n\treturn result as T;\n}\n"],"names":["result: Record<string, any>"],"mappings":";;;;;;;AAEA,SAAgB,YACf,MAAA,EACA,MAAA,EACC;IACD,MAAMA,SAA8B,OAAO,EAAA,GACxC;QACA,IAAI,OAAO,EAAA;IAAA,CACX,GACA,CAAA,CAAE;IACL,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,UAAU,KAAA,EACb,CAAA;QAED,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA,GAAO;;IAElC,OAAO;;AAGR,SAAgB,cACf,MAAA,EACA,MAAA,EACC;IACD,IAAI,CAAC,OACJ,CAAA,OAAO;IAER,MAAMA,SAA8B;QACnC,IAAI,OAAO,EAAA;IAAA,CACX;IACD,KAAK,MAAM,CAAC,KAAK,MAAA,IAAU,OAAO,OAAA,CAAQ,OAAO,CAChD,MAAA,CAAO,IAAA,GAAO,MAAA,CAAO,MAAM,SAAA,IAAa,IAAA;IAEzC,OAAO"}},
    {"offset": {"line": 2308, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/with-hooks.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/with-hooks.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n} from \"@better-auth/core/context\";\nimport type { BaseModelNames } from \"@better-auth/core/db\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\n\nexport function getWithHooks(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: BetterAuthOptions;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t},\n) {\n\tconst hooks = ctx.hooks;\n\tasync function createWithHooks<T extends Record<string, any>>(\n\t\tdata: T,\n\t\tmodel: BaseModelNames,\n\t\tcustomCreateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(actualData as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customCreated = customCreateFn\n\t\t\t? await customCreateFn.fn(actualData)\n\t\t\t: null;\n\t\tconst created =\n\t\t\t!customCreateFn || customCreateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).create<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: actualData as any,\n\t\t\t\t\t\tforceAllowId: true,\n\t\t\t\t\t})\n\t\t\t\t: customCreated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.create?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(created as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn created;\n\t}\n\n\tasync function updateWithHooks<T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).update<T>({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\tasync function updateManyWithHooks<_T extends Record<string, any>>(\n\t\tdata: any,\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomUpdateFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (data: Record<string, any>) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet actualData = data;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.before;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tconst result = await toRun(data as any, context);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst isObject = typeof result === \"object\" && \"data\" in result;\n\t\t\t\tif (isObject) {\n\t\t\t\t\tactualData = {\n\t\t\t\t\t\t...actualData,\n\t\t\t\t\t\t...result.data,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customUpdated = customUpdateFn\n\t\t\t? await customUpdateFn.fn(actualData)\n\t\t\t: null;\n\n\t\tconst updated =\n\t\t\t!customUpdateFn || customUpdateFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).updateMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tupdate: actualData,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customUpdated;\n\n\t\tfor (const hook of hooks || []) {\n\t\t\tconst toRun = hook[model]?.update?.after;\n\t\t\tif (toRun) {\n\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\tawait toRun(updated as any, context);\n\t\t\t}\n\t\t}\n\n\t\treturn updated;\n\t}\n\n\tasync function deleteWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entityToDelete: T | null = null;\n\n\t\ttry {\n\t\t\tconst entities = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tentityToDelete = entities[0] || null;\n\t\t} catch {\n\t\t\t// If we can't find the entity, we'll still proceed with deletion\n\t\t}\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entityToDelete as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).delete({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tif (entityToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entityToDelete as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\tasync function deleteManyWithHooks<T extends Record<string, any>>(\n\t\twhere: Where[],\n\t\tmodel: BaseModelNames,\n\t\tcustomDeleteFn?:\n\t\t\t| {\n\t\t\t\t\tfn: (where: Where[]) => void | Promise<any>;\n\t\t\t\t\texecuteMainFn?: boolean;\n\t\t\t  }\n\t\t\t| undefined,\n\t) {\n\t\tconst context = await getCurrentAuthContext().catch(() => null);\n\t\tlet entitiesToDelete: T[] = [];\n\n\t\ttry {\n\t\t\tentitiesToDelete = await (await getCurrentAdapter(adapter)).findMany<T>({\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t});\n\t\t} catch {\n\t\t\t// If we can't find the entities, we'll still proceed with deletion\n\t\t}\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.before;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tconst result = await toRun(entity as any, context);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst customDeleted = customDeleteFn\n\t\t\t? await customDeleteFn.fn(where)\n\t\t\t: null;\n\n\t\tconst deleted =\n\t\t\t!customDeleteFn || customDeleteFn.executeMainFn\n\t\t\t\t? await (await getCurrentAdapter(adapter)).deleteMany({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t})\n\t\t\t\t: customDeleted;\n\n\t\tfor (const entity of entitiesToDelete) {\n\t\t\tfor (const hook of hooks || []) {\n\t\t\t\tconst toRun = hook[model]?.delete?.after;\n\t\t\t\tif (toRun) {\n\t\t\t\t\t// @ts-expect-error context type mismatch\n\t\t\t\t\tawait toRun(entity as any, context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn deleted;\n\t}\n\n\treturn {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t};\n}\n"],"names":["entityToDelete: T | null","entitiesToDelete: T[]"],"mappings":"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"}},
    {"offset": {"line": 2464, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/internal-adapter.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/internal-adapter.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tInternalAdapter,\n} from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n\trunWithTransaction,\n} from \"@better-auth/core/context\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { generateId, safeJSONParse } from \"@better-auth/core/utils\";\nimport type { Account, Session, User, Verification } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { getIp } from \"../utils/get-request-ip\";\nimport {\n\tparseSessionInput,\n\tparseSessionOutput,\n\tparseUserOutput,\n} from \"./schema\";\nimport { getWithHooks } from \"./with-hooks\";\n\nexport const createInternalAdapter = (\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: Omit<BetterAuthOptions, \"logger\">;\n\t\tlogger: InternalLogger;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t\tgenerateId: AuthContext[\"generateId\"];\n\t},\n): InternalAdapter => {\n\tconst logger = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7; // 7 days\n\tconst {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t} = getWithHooks(adapter, ctx);\n\n\tasync function refreshUserSessions(user: User) {\n\t\tif (!secondaryStorage) return;\n\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\n\t\tconst now = Date.now();\n\t\tconst list =\n\t\t\tsafeJSONParse<{ token: string; expiresAt: number }[]>(listRaw) || [];\n\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\n\t\tawait Promise.all(\n\t\t\tvalidSessions.map(async ({ token }) => {\n\t\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\t\tif (!cached) return;\n\t\t\t\tconst parsed = safeJSONParse<{ session: Session; user: User }>(cached);\n\t\t\t\tif (!parsed) return;\n\n\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\tMath.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1000,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\ttoken,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tsession: parsed.session,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t}),\n\t\t\t\t\tMath.floor(sessionTTL),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\tcreateOAuthUser: async (\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">,\n\t\t\taccount: Omit<Account, \"userId\" | \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t...user,\n\t\t\t\t\t},\n\t\t\t\t\t\"user\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser!.id,\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t},\n\t\t\t\t\t\"account\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: createdAccount,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async <T>(\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\" | \"emailVerified\"> &\n\t\t\t\tPartial<User> &\n\t\t\t\tRecord<string, any>,\n\t\t) => {\n\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...user,\n\t\t\t\t\temail: user.email?.toLowerCase(),\n\t\t\t\t},\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\treturn createdUser as T & User;\n\t\t},\n\t\tcreateAccount: async <T extends Record<string, any>>(\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account> &\n\t\t\t\tT,\n\t\t) => {\n\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn createdAccount as T & Account;\n\t\t},\n\t\tlistSessions: async (userId: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t);\n\t\t\t\tif (!currentList) return [];\n\n\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tconst seenTokens = new Set<string>();\n\t\t\t\tconst sessions: Session[] = [];\n\n\t\t\t\tfor (const { token, expiresAt } of list) {\n\t\t\t\t\tif (expiresAt <= now || seenTokens.has(token)) continue;\n\t\t\t\t\tseenTokens.add(token);\n\n\t\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\t\tif (!data) continue;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst parsed = (\n\t\t\t\t\t\t\ttypeof data === \"string\" ? JSON.parse(data) : data\n\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (!parsed?.session) continue;\n\n\t\t\t\t\t\tsessions.push(\n\t\t\t\t\t\t\tparseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(parsed.session.expiresAt),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Session>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn sessions;\n\t\t},\n\t\tlistUsers: async (\n\t\t\tlimit?: number | undefined,\n\t\t\toffset?: number | undefined,\n\t\t\tsortBy?:\n\t\t\t\t| {\n\t\t\t\t\t\tfield: string;\n\t\t\t\t\t\tdirection: \"asc\" | \"desc\";\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\twhere?: Where[] | undefined,\n\t\t) => {\n\t\t\tconst users = await (await getCurrentAdapter(adapter)).findMany<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere,\n\t\t\t});\n\t\t\treturn users;\n\t\t},\n\t\tcountTotalUsers: async (where?: Where[] | undefined) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere,\n\t\t\t});\n\t\t\tif (typeof total === \"string\") {\n\t\t\t\treturn parseInt(total);\n\t\t\t}\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId: string) => {\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"session\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tcreateSession: async (\n\t\t\tuserId: string,\n\t\t\tdontRememberMe?: boolean | undefined,\n\t\t\toverride?: (Partial<Session> & Record<string, any>) | undefined,\n\t\t\toverrideAll?: boolean | undefined,\n\t\t) => {\n\t\t\tconst ctx = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx?.headers || ctx?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\t//we're parsing default values for session additional fields\n\t\t\tconst defaultAdditionalFields = parseSessionInput(\n\t\t\t\tctx?.context.options ?? options,\n\t\t\t\t{},\n\t\t\t);\n\t\t\tconst data: Omit<Session, \"id\"> = {\n\t\t\t\tipAddress:\n\t\t\t\t\tctx?.request || ctx?.headers\n\t\t\t\t\t\t? getIp(ctx?.request || ctx?.headers!, ctx?.context.options) || \"\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\t/**\n\t\t\t\t * If the user doesn't want to be remembered\n\t\t\t\t * set the session to expire in 1 day.\n\t\t\t\t * The cookie will be set to expire at the end of the session\n\t\t\t\t */\n\t\t\t\texpiresAt: dontRememberMe\n\t\t\t\t\t? getDate(60 * 60 * 24, \"sec\") // 1 day\n\t\t\t\t\t: getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...(overrideAll ? rest : {}),\n\t\t\t};\n\t\t\tconst res = await createWithHooks(\n\t\t\t\tdata,\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * store the session token for the user\n\t\t\t\t\t\t\t\t * so we can retrieve it later for listing sessions\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] = [];\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\t\t\t\tlist = list.filter(\n\t\t\t\t\t\t\t\t\t\t(session) =>\n\t\t\t\t\t\t\t\t\t\t\tsession.expiresAt > now && session.token !== data.token,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst sorted = [\n\t\t\t\t\t\t\t\t\t...list,\n\t\t\t\t\t\t\t\t\t{ token: data.token, expiresAt: data.expiresAt.getTime() },\n\t\t\t\t\t\t\t\t].sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\t\t\tconst furthestSessionExp =\n\t\t\t\t\t\t\t\t\tsorted.at(-1)?.expiresAt ?? data.expiresAt.getTime();\n\t\t\t\t\t\t\t\tconst furthestSessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (furthestSessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\tfurthestSessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst user = await adapter.findOne<User>({\n\t\t\t\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((data.expiresAt.getTime() - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tdata.token,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn sessionData;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn res as Session;\n\t\t},\n\t\tfindSession: async (\n\t\t\ttoken: string,\n\t\t): Promise<{\n\t\t\tsession: Session & Record<string, any>;\n\t\t\tuser: User & Record<string, any>;\n\t\t} | null> => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.options, {\n\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: token,\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\tconst parsedSession = parseSessionOutput(ctx.options, session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.options, user);\n\t\t\treturn {\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser,\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens: string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[] = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst s = (\n\t\t\t\t\t\t\t\ttypeof sessionStringified === \"string\"\n\t\t\t\t\t\t\t\t\t? JSON.parse(sessionStringified)\n\t\t\t\t\t\t\t\t\t: sessionStringified\n\t\t\t\t\t\t\t) as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (!s?.session) continue;\n\t\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsessions.push(session);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// Skip invalid/corrupt session data\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\t\toperator: \"in\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user!,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (\n\t\t\tsessionToken: string,\n\t\t\tsession: Partial<Session> & Record<string, any>,\n\t\t) => {\n\t\t\tconst updatedSession = await updateWithHooks<Session>(\n\t\t\t\tsession,\n\t\t\t\t[{ field: \"token\", value: sessionToken }],\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tasync fn(data) {\n\t\t\t\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\t\t\tif (!currentSession) {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst parsedSession = safeJSONParse<{\n\t\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\t}>(currentSession);\n\t\t\t\t\t\t\t\tif (!parsedSession) return null;\n\n\t\t\t\t\t\t\t\tconst mergedSession = {\n\t\t\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.expiresAt ?? parsedSession.session.expiresAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(parsedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.updatedAt ?? parsedSession.session.updatedAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst updatedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.options,\n\t\t\t\t\t\t\t\t\tmergedSession,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\t\t\tconst expiresMs = new Date(updatedSession.expiresAt).getTime();\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((expiresMs - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tsessionToken,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\t\t\t\t\tuser: parsedSession.user,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst listKey = `active-sessions-${updatedSession.userId}`;\n\t\t\t\t\t\t\t\t\tconst listRaw = await secondaryStorage.get(listKey);\n\t\t\t\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] = listRaw\n\t\t\t\t\t\t\t\t\t\t? safeJSONParse(listRaw) || []\n\t\t\t\t\t\t\t\t\t\t: [];\n\n\t\t\t\t\t\t\t\t\tconst filtered = list\n\t\t\t\t\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t\t\t\t\t(s) => s.token !== sessionToken && s.expiresAt > now,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.concat([{ token: sessionToken, expiresAt: expiresMs }]);\n\n\t\t\t\t\t\t\t\t\tconst sorted = filtered.sort(\n\t\t\t\t\t\t\t\t\t\t(a, b) => a.expiresAt - b.expiresAt,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\t\t\t\tif (furthestSessionExp && furthestSessionExp > now) {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t\tlistKey,\n\t\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.delete(listKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn updatedSession;\n\t\t},\n\t\tdeleteSession: async (token: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\t// remove the session from the active sessions list\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } =\n\t\t\t\t\t\tsafeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\n\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\tconst filtered = list.filter(\n\t\t\t\t\t\t\t(session) => session.expiresAt > now && session.token !== token,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst sorted = filtered.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tfiltered.length > 0 &&\n\t\t\t\t\t\t\tfurthestSessionExp &&\n\t\t\t\t\t\t\tfurthestSessionExp > Date.now()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\tJSON.stringify(filtered),\n\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait secondaryStorage.delete(token);\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"token\", value: token }],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccounts: async (userId: string) => {\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccount: async (accountId: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: accountId }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens: string | string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t\tconst sessions = activeSession\n\t\t\t\t\t\t? safeJSONParse<{ token: string }[]>(activeSession)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\t\tawait secondaryStorage.delete(session.token);\n\t\t\t\t\t}\n\t\t\t\t\tawait secondaryStorage.delete(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const sessionToken of userIdOrSessionTokens) {\n\t\t\t\t\t\tconst session = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\tif (session) {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(sessionToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindOAuthUser: async (\n\t\t\temail: string,\n\t\t\taccountId: string,\n\t\t\tproviderId: string,\n\t\t) => {\n\t\t\t// we need to find account first to avoid missing user if the email changed with the provider for the same account\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<\n\t\t\t\tAccount & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (account) {\n\t\t\t\tif (account.user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: account.user,\n\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tif (user) {\n\t\t\t\t\tconst accounts = await (\n\t\t\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t\t\t).findMany<Account>({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tlinkedAccount: null,\n\t\t\t\t\t\taccounts: accounts || [],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (\n\t\t\temail: string,\n\t\t\toptions?: { includeAccounts: boolean } | undefined,\n\t\t) => {\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tUser & { account: Account[] | undefined }\n\t\t\t>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\t...(options?.includeAccounts ? { account: true } : {}),\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? [],\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId: string) => {\n\t\t\tif (!userId) return null;\n\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn user;\n\t\t},\n\t\tlinkAccount: async (\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\tconst _account = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn _account;\n\t\t},\n\t\tupdateUser: async (\n\t\t\tuserId: string,\n\t\t\tdata: Partial<User> & Record<string, any>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (\n\t\t\temail: string,\n\t\t\tdata: Partial<User & Record<string, any>>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId: string, password: string) => {\n\t\t\tawait updateManyWithHooks(\n\t\t\t\t{\n\t\t\t\t\tpassword,\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindAccounts: async (userId: string) => {\n\t\t\tconst accounts = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn accounts;\n\t\t},\n\t\tfindAccount: async (accountId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByProviderId: async (accountId: string, providerId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByUserId: async (userId: string) => {\n\t\t\tconst account = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn account;\n\t\t},\n\t\tupdateAccount: async (id: string, data: Partial<Account>) => {\n\t\t\tconst account = await updateWithHooks<Account>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tcreateVerificationValue: async (\n\t\t\tdata: Omit<Verification, \"createdAt\" | \"id\" | \"updatedAt\"> &\n\t\t\t\tPartial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification as Verification;\n\t\t},\n\t\tfindVerificationValue: async (identifier: string) => {\n\t\t\tconst verification = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Verification>({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\t\tvalue: identifier,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\",\n\t\t\t\t},\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\t\t\tvalue: new Date(),\n\t\t\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"verification\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lastVerification = verification[0];\n\t\t\treturn lastVerification as Verification | null;\n\t\t},\n\t\tdeleteVerificationValue: async (id: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"identifier\", value: identifier }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tupdateVerificationValue: async (\n\t\t\tid: string,\n\t\t\tdata: Partial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await updateWithHooks<Verification>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification;\n\t\t},\n\t};\n};\n"],"names":["list: { token: string; expiresAt: number }[]","sessions: Session[]","ctx","data: Omit<Session, \"id\">","sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[]","sessions","session","options"],"mappings":"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"}},
    {"offset": {"line": 3138, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/to-zod.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/to-zod.ts"],"sourcesContent":["import type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport type { ZodType } from \"zod\";\nimport * as z from \"zod\";\n\nexport function toZodSchema<\n\tFields extends Record<string, DBFieldAttribute | never>,\n\tIsClientSide extends boolean,\n>({\n\tfields,\n\tisClientSide,\n}: {\n\tfields: Fields;\n\t/**\n\t * If true, then any fields that have `input: false` will be removed from the schema to prevent user input.\n\t */\n\tisClientSide: IsClientSide;\n}) {\n\tconst zodFields = Object.keys(fields).reduce((acc, key) => {\n\t\tconst field = fields[key];\n\t\tif (!field) {\n\t\t\treturn acc;\n\t\t}\n\t\tif (isClientSide && field.input === false) {\n\t\t\treturn acc;\n\t\t}\n\n\t\tlet schema: ZodType;\n\t\tif (field.type === \"json\") {\n\t\t\tschema = (z as any).json ? (z as any).json() : z.any();\n\t\t} else if (field.type === \"string[]\" || field.type === \"number[]\") {\n\t\t\tschema = z.array(field.type === \"string[]\" ? z.string() : z.number());\n\t\t} else if (Array.isArray(field.type)) {\n\t\t\tschema = z.any();\n\t\t} else {\n\t\t\tschema = z[field.type]();\n\t\t}\n\n\t\tif (field?.required === false) {\n\t\t\tschema = schema.optional();\n\t\t}\n\t\tif (!isClientSide && field?.returned === false) {\n\t\t\treturn acc;\n\t\t}\n\t\treturn {\n\t\t\t...acc,\n\t\t\t[key]: schema,\n\t\t};\n\t}, {});\n\tconst schema = z.object(zodFields);\n\treturn schema as z.ZodObject<\n\t\tRemoveNeverProps<{\n\t\t\t[key in keyof Fields]: FieldAttributeToSchema<Fields[key], IsClientSide>;\n\t\t}>,\n\t\tz.core.$strip\n\t>;\n}\n\nexport type FieldAttributeToSchema<\n\tField extends DBFieldAttribute | Record<string, never>,\n\t// if it's client side, then field attributes of `input` that are false should be removed\n\tisClientSide extends boolean = false,\n> = Field extends { type: any }\n\t? GetInput<isClientSide, Field, GetRequired<Field, GetType<Field>>>\n\t: Record<string, never>;\n\ntype GetType<F extends DBFieldAttribute> = F extends {\n\ttype: \"string\";\n}\n\t? z.ZodString\n\t: F extends { type: \"number\" }\n\t\t? z.ZodNumber\n\t\t: F extends { type: \"boolean\" }\n\t\t\t? z.ZodBoolean\n\t\t\t: F extends { type: \"date\" }\n\t\t\t\t? z.ZodDate\n\t\t\t\t: z.ZodAny;\n\ntype GetRequired<\n\tF extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = F extends {\n\trequired: true;\n}\n\t? Schema\n\t: z.ZodOptional<Schema>;\n\ntype GetInput<\n\tisClientSide extends boolean,\n\tField extends DBFieldAttribute,\n\tSchema extends z.core.SomeType,\n> = Field extends {\n\tinput: false;\n}\n\t? isClientSide extends true\n\t\t? never\n\t\t: Schema\n\t: Schema;\n\ntype RemoveNeverProps<T> = {\n\t[K in keyof T as [T[K]] extends [never] ? never : K]: T[K];\n};\n"],"names":["schema: ZodType"],"mappings":";;;;;;;AAIA,SAAgB,YAGd,EACD,MAAA,EACA,YAAA,EAAA,EAOE;IACF,MAAM,YAAY,OAAO,IAAA,CAAK,OAAO,CAAC,MAAA,CAAA,CAAQ,KAAK,QAAQ;QAC1D,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,IAAI,CAAC,MACJ,CAAA,OAAO;QAER,IAAI,gBAAgB,MAAM,KAAA,KAAU,MACnC,CAAA,OAAO;QAGR,IAAIA;QACJ,IAAI,MAAM,IAAA,KAAS,OAClB,CAAA,SAAU,2IAAU,IAAA,GAAQ,2IAAU,IAAA,EAAM,GAAG,2IAAE,GAAA,EAAK;iBAC5C,MAAM,IAAA,KAAS,cAAc,MAAM,IAAA,KAAS,WACtD,CAAA,SAAS,2IAAE,KAAA,CAAM,MAAM,IAAA,KAAS,aAAa,2IAAE,MAAA,EAAQ,GAAG,2IAAE,MAAA,EAAQ,CAAC;iBAC3D,MAAM,OAAA,CAAQ,MAAM,IAAA,CAAK,CACnC,CAAA,SAAS,2IAAE,GAAA,EAAK;aAEhB,SAAS,0IAAA,CAAE,MAAM,IAAA,CAAA,EAAO;QAGzB,IAAI,OAAO,aAAa,MACvB,CAAA,SAAS,OAAO,QAAA,EAAU;QAE3B,IAAI,CAAC,gBAAgB,OAAO,aAAa,MACxC,CAAA,OAAO;QAER,OAAO;YACN,GAAG,GAAA;aACF,IAAA,EAAM;SACP;OACC,CAAA,CAAE,CAAC;IAEN,OADe,2IAAE,MAAA,CAAO,UAAU"}},
    {"offset": {"line": 3170, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/get-schema.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/get-schema.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute } from \"@better-auth/core/db\";\nimport { getAuthTables } from \".\";\n\nexport function getSchema(config: BetterAuthOptions) {\n\tconst tables = getAuthTables(config);\n\tconst schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t> = {};\n\tfor (const key in tables) {\n\t\tconst table = tables[key]!;\n\t\tconst fields = table.fields;\n\t\tconst actualFields: Record<string, DBFieldAttribute> = {};\n\t\tObject.entries(fields).forEach(([key, field]) => {\n\t\t\tactualFields[field.fieldName || key] = field;\n\t\t\tif (field.references) {\n\t\t\t\tconst refTable = tables[field.references.model];\n\t\t\t\tif (refTable) {\n\t\t\t\t\tactualFields[field.fieldName || key]!.references = {\n\t\t\t\t\t\t...field.references,\n\t\t\t\t\t\tmodel: refTable.modelName,\n\t\t\t\t\t\tfield: field.references.field,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (schema[table.modelName]) {\n\t\t\tschema[table.modelName]!.fields = {\n\t\t\t\t...schema[table.modelName]!.fields,\n\t\t\t\t...actualFields,\n\t\t\t};\n\t\t\tcontinue;\n\t\t}\n\t\tschema[table.modelName] = {\n\t\t\tfields: actualFields,\n\t\t\torder: table.order || Infinity,\n\t\t};\n\t}\n\treturn schema;\n}\n"],"names":["schema: Record<\n\t\tstring,\n\t\t{\n\t\t\tfields: Record<string, DBFieldAttribute>;\n\t\t\torder: number;\n\t\t}\n\t>","actualFields: Record<string, DBFieldAttribute>","key"],"mappings":";;;;;;;AAIA,SAAgB,UAAU,MAAA,EAA2B;IACpD,MAAM,SAAA,CAAA,GAAA,kMAAA,CAAA,aAAA,EAAuB,OAAO;IACpC,MAAMA,SAMF,CAAA,CAAE;IACN,IAAK,MAAM,OAAO,OAAQ;QACzB,MAAM,QAAQ,MAAA,CAAO,IAAA;QACrB,MAAM,SAAS,MAAM,MAAA;QACrB,MAAMC,eAAiD,CAAA,CAAE;QACzD,OAAO,OAAA,CAAQ,OAAO,CAAC,OAAA,CAAA,CAAS,CAACC,OAAK,MAAA,KAAW;YAChD,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,GAAO;YACvC,IAAI,MAAM,UAAA,EAAY;gBACrB,MAAM,WAAW,MAAA,CAAO,MAAM,UAAA,CAAW,KAAA,CAAA;gBACzC,IAAI,SACH,CAAA,YAAA,CAAa,MAAM,SAAA,IAAaA,MAAAA,CAAM,UAAA,GAAa;oBAClD,GAAG,MAAM,UAAA;oBACT,OAAO,SAAS,SAAA;oBAChB,OAAO,MAAM,UAAA,CAAW,KAAA;iBACxB;;UAGF;QACF,IAAI,MAAA,CAAO,MAAM,SAAA,CAAA,EAAY;YAC5B,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA,GAAS;gBACjC,GAAG,MAAA,CAAO,MAAM,SAAA,CAAA,CAAY,MAAA;gBAC5B,GAAG,YAAA;aACH;YACD;;QAED,MAAA,CAAO,MAAM,SAAA,CAAA,GAAa;YACzB,QAAQ;YACR,OAAO,MAAM,KAAA,IAAS;SACtB;;IAEF,OAAO"}},
    {"offset": {"line": 3215, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/adapters/kysely-adapter/dialect.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/adapters/kysely-adapter/dialect.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { Dialect } from \"kysely\";\nimport {\n\tKysely,\n\tMssqlDialect,\n\tMysqlDialect,\n\tPostgresDialect,\n\tSqliteDialect,\n} from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\nexport function getKyselyDatabaseType(\n\tdb: BetterAuthOptions[\"database\"],\n): KyselyDatabaseType | null {\n\tif (!db) {\n\t\treturn null;\n\t}\n\tif (\"dialect\" in db) {\n\t\treturn getKyselyDatabaseType(db.dialect as Dialect);\n\t}\n\tif (\"createDriver\" in db) {\n\t\tif (db instanceof SqliteDialect) {\n\t\t\treturn \"sqlite\";\n\t\t}\n\t\tif (db instanceof MysqlDialect) {\n\t\t\treturn \"mysql\";\n\t\t}\n\t\tif (db instanceof PostgresDialect) {\n\t\t\treturn \"postgres\";\n\t\t}\n\t\tif (db instanceof MssqlDialect) {\n\t\t\treturn \"mssql\";\n\t\t}\n\t}\n\tif (\"aggregate\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\n\tif (\"getConnection\" in db) {\n\t\treturn \"mysql\";\n\t}\n\tif (\"connect\" in db) {\n\t\treturn \"postgres\";\n\t}\n\tif (\"fileControl\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\tif (\"open\" in db && \"close\" in db && \"prepare\" in db) {\n\t\treturn \"sqlite\";\n\t}\n\treturn null;\n}\n\nexport const createKyselyAdapter = async (config: BetterAuthOptions) => {\n\tconst db = config.database;\n\n\tif (!db) {\n\t\treturn {\n\t\t\tkysely: null,\n\t\t\tdatabaseType: null,\n\t\t\ttransaction: undefined,\n\t\t};\n\t}\n\n\tif (\"db\" in db) {\n\t\treturn {\n\t\t\tkysely: db.db,\n\t\t\tdatabaseType: db.type,\n\t\t\ttransaction: db.transaction,\n\t\t};\n\t}\n\n\tif (\"dialect\" in db) {\n\t\treturn {\n\t\t\tkysely: new Kysely<any>({ dialect: db.dialect }),\n\t\t\tdatabaseType: db.type,\n\t\t\ttransaction: db.transaction,\n\t\t};\n\t}\n\n\tlet dialect: Dialect | undefined = undefined;\n\n\tconst databaseType = getKyselyDatabaseType(db);\n\n\tif (\"createDriver\" in db) {\n\t\tdialect = db;\n\t}\n\n\tif (\"aggregate\" in db && !(\"createSession\" in db)) {\n\t\tdialect = new SqliteDialect({\n\t\t\tdatabase: db,\n\t\t});\n\t}\n\n\tif (\"getConnection\" in db) {\n\t\t// @ts-expect-error - mysql2/promise\n\t\tdialect = new MysqlDialect(db);\n\t}\n\n\tif (\"connect\" in db) {\n\t\tdialect = new PostgresDialect({\n\t\t\tpool: db,\n\t\t});\n\t}\n\n\tif (\"fileControl\" in db) {\n\t\tconst { BunSqliteDialect } = await import(\"./bun-sqlite-dialect\");\n\t\tdialect = new BunSqliteDialect({\n\t\t\tdatabase: db,\n\t\t});\n\t}\n\n\tif (\"createSession\" in db) {\n\t\tlet DatabaseSync: typeof import(\"node:sqlite\").DatabaseSync | undefined =\n\t\t\tundefined;\n\t\ttry {\n\t\t\tconst nodeSqlite: string = \"node:sqlite\";\n\t\t\t// Ignore both Vite and Webpack for dynamic import as they both try to pre-bundle 'node:sqlite' which might fail\n\t\t\t// It's okay because we are in a try-catch block\n\t\t\t({ DatabaseSync } = await import(\n\t\t\t\t/* @vite-ignore */\n\t\t\t\t/* webpackIgnore: true */\n\t\t\t\tnodeSqlite\n\t\t\t));\n\t\t} catch (error: unknown) {\n\t\t\tif (\n\t\t\t\terror !== null &&\n\t\t\t\ttypeof error === \"object\" &&\n\t\t\t\t\"code\" in error &&\n\t\t\t\terror.code !== \"ERR_UNKNOWN_BUILTIN_MODULE\"\n\t\t\t) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\tif (DatabaseSync && db instanceof DatabaseSync) {\n\t\t\tconst { NodeSqliteDialect } = await import(\"./node-sqlite-dialect\");\n\t\t\tdialect = new NodeSqliteDialect({\n\t\t\t\tdatabase: db,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {\n\t\tkysely: dialect ? new Kysely<any>({ dialect }) : null,\n\t\tdatabaseType,\n\t\ttransaction: undefined,\n\t};\n};\n"],"names":["dialect: Dialect | undefined","DatabaseSync: typeof import(\"node:sqlite\").DatabaseSync | undefined","nodeSqlite: string","error: unknown"],"mappings":";;;;;;;;;;;;;AAWA,SAAgB,sBACf,EAAA,EAC4B;IAC5B,IAAI,CAAC,GACJ,CAAA,OAAO;IAER,IAAI,aAAa,GAChB,CAAA,OAAO,sBAAsB,GAAG,OAAA,CAAmB;IAEpD,IAAI,kBAAkB,IAAI;QACzB,IAAI,cAAc,8MAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,2MAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,oNAAA,CACjB,CAAA,OAAO;QAER,IAAI,cAAc,2MAAA,CACjB,CAAA,OAAO;;IAGT,IAAI,eAAe,GAClB,CAAA,OAAO;IAGR,IAAI,mBAAmB,GACtB,CAAA,OAAO;IAER,IAAI,aAAa,GAChB,CAAA,OAAO;IAER,IAAI,iBAAiB,GACpB,CAAA,OAAO;IAER,IAAI,UAAU,MAAM,WAAW,MAAM,aAAa,GACjD,CAAA,OAAO;IAER,OAAO;;AAGR,MAAa,sBAAsB,OAAO,WAA8B;IACvE,MAAM,KAAK,OAAO,QAAA;IAElB,IAAI,CAAC,GACJ,CAAA,OAAO;QACN,QAAQ;QACR,cAAc;QACd,aAAa,KAAA;KACb;IAGF,IAAI,QAAQ,GACX,CAAA,OAAO;QACN,QAAQ,GAAG,EAAA;QACX,cAAc,GAAG,IAAA;QACjB,aAAa,GAAG,WAAA;KAChB;IAGF,IAAI,aAAa,GAChB,CAAA,OAAO;QACN,QAAQ,IAAI,uKAAA,CAAY;YAAE,SAAS,GAAG,OAAA;QAAA,CAAS,CAAC;QAChD,cAAc,GAAG,IAAA;QACjB,aAAa,GAAG,WAAA;KAChB;IAGF,IAAIA,UAA+B,KAAA;IAEnC,MAAM,eAAe,sBAAsB,GAAG;IAE9C,IAAI,kBAAkB,GACrB,CAAA,UAAU;IAGX,IAAI,eAAe,MAAM,CAAA,CAAE,mBAAmB,EAAA,EAC7C,CAAA,UAAU,IAAI,8MAAA,CAAc;QAC3B,UAAU;IAAA,CACV,CAAC;IAGH,IAAI,mBAAmB,GAEtB,CAAA,UAAU,IAAI,2MAAA,CAAa,GAAG;IAG/B,IAAI,aAAa,GAChB,CAAA,UAAU,IAAI,oNAAA,CAAgB;QAC7B,MAAM;IAAA,CACN,CAAC;IAGH,IAAI,iBAAiB,IAAI;QACxB,MAAM,EAAE,gBAAA,EAAA,GAAqB,MAAM,OAAO;QAC1C,UAAU,IAAI,iBAAiB;YAC9B,UAAU;QAAA,CACV,CAAC;;IAGH,IAAI,mBAAmB,IAAI;QAC1B,IAAIC,eACH,KAAA;QACD,IAAI;YACH,MAAMC,aAAqB;YAG3B,CAAC,EAAE,YAAA,EAAA,GAAiB,MAAM,MAAA,8CAGzB;iBAEOC,OAAgB;YACxB,IACC,UAAU,QACV,OAAO,UAAU,YACjB,UAAU,SACV,MAAM,IAAA,KAAS,6BAEf,CAAA,MAAM;;QAGR,IAAI,gBAAgB,cAAc,cAAc;YAC/C,MAAM,EAAE,iBAAA,EAAA,GAAsB,MAAM,OAAO;YAC3C,UAAU,IAAI,kBAAkB;gBAC/B,UAAU;YAAA,CACV,CAAC;;;IAIJ,OAAO;QACN,QAAQ,UAAU,IAAI,uKAAA,CAAY;YAAE;QAAA,CAAS,CAAC,GAAG;QACjD;QACA,aAAa,KAAA;KACb"}},
    {"offset": {"line": 3308, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/get-migration.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/get-migration.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type { DBFieldAttribute, DBFieldType } from \"@better-auth/core/db\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport {\n\tinitGetFieldName,\n\tinitGetModelName,\n} from \"@better-auth/core/db/adapter\";\nimport { createLogger } from \"@better-auth/core/env\";\nimport type {\n\tAlterTableBuilder,\n\tAlterTableColumnAlteringBuilder,\n\tColumnDataType,\n\tCreateIndexBuilder,\n\tCreateTableBuilder,\n\tKysely,\n\tRawBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport { createKyselyAdapter } from \"../adapters/kysely-adapter/dialect\";\nimport type { KyselyDatabaseType } from \"../adapters/kysely-adapter/types\";\nimport { getSchema } from \"./get-schema\";\n\nconst postgresMap = {\n\tstring: [\"character varying\", \"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"int4\",\n\t\t\"integer\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"numeric\",\n\t\t\"real\",\n\t\t\"double precision\",\n\t],\n\tboolean: [\"bool\", \"boolean\"],\n\tdate: [\"timestamptz\", \"timestamp\", \"date\"],\n\tjson: [\"json\", \"jsonb\"],\n};\nconst mysqlMap = {\n\tstring: [\"varchar\", \"text\", \"uuid\"],\n\tnumber: [\n\t\t\"integer\",\n\t\t\"int\",\n\t\t\"bigint\",\n\t\t\"smallint\",\n\t\t\"decimal\",\n\t\t\"float\",\n\t\t\"double\",\n\t],\n\tboolean: [\"boolean\", \"tinyint\"],\n\tdate: [\"timestamp\", \"datetime\", \"date\"],\n\tjson: [\"json\"],\n};\n\nconst sqliteMap = {\n\tstring: [\"TEXT\"],\n\tnumber: [\"INTEGER\", \"REAL\"],\n\tboolean: [\"INTEGER\", \"BOOLEAN\"], // 0 or 1\n\tdate: [\"DATE\", \"INTEGER\"],\n\tjson: [\"TEXT\"],\n};\n\nconst mssqlMap = {\n\tstring: [\"varchar\", \"nvarchar\", \"uniqueidentifier\"],\n\tnumber: [\"int\", \"bigint\", \"smallint\", \"decimal\", \"float\", \"double\"],\n\tboolean: [\"bit\", \"smallint\"],\n\tdate: [\"datetime2\", \"date\", \"datetime\"],\n\tjson: [\"varchar\", \"nvarchar\"],\n};\n\nconst map = {\n\tpostgres: postgresMap,\n\tmysql: mysqlMap,\n\tsqlite: sqliteMap,\n\tmssql: mssqlMap,\n};\n\nexport function matchType(\n\tcolumnDataType: string,\n\tfieldType: DBFieldType,\n\tdbType: KyselyDatabaseType,\n) {\n\tfunction normalize(type: string) {\n\t\treturn type.toLowerCase().split(\"(\")[0]!.trim();\n\t}\n\tif (fieldType === \"string[]\" || fieldType === \"number[]\") {\n\t\treturn columnDataType.toLowerCase().includes(\"json\");\n\t}\n\tconst types = map[dbType]!;\n\tconst expected = Array.isArray(fieldType)\n\t\t? types[\"string\"].map((t) => t.toLowerCase())\n\t\t: types[fieldType]!.map((t) => t.toLowerCase());\n\treturn expected.includes(normalize(columnDataType));\n}\n\n/**\n * Get the current PostgreSQL schema (search_path) for the database connection\n * Returns the first schema in the search_path, defaulting to 'public' if not found\n */\nasync function getPostgresSchema(db: Kysely<unknown>): Promise<string> {\n\ttry {\n\t\tconst result = await sql<{ search_path: string }>`SHOW search_path`.execute(\n\t\t\tdb,\n\t\t);\n\t\tif (result.rows[0]?.search_path) {\n\t\t\t// search_path can be a comma-separated list like \"$user, public\" or '\"$user\", public'\n\t\t\t// We want the first non-variable schema\n\t\t\tconst schemas = result.rows[0].search_path\n\t\t\t\t.split(\",\")\n\t\t\t\t.map((s) => s.trim())\n\t\t\t\t// Remove quotes and filter out variables like $user\n\t\t\t\t.map((s) => s.replace(/^[\"']|[\"']$/g, \"\"))\n\t\t\t\t.filter((s) => !s.startsWith(\"$\"));\n\t\t\treturn schemas[0] || \"public\";\n\t\t}\n\t} catch {\n\t\t// If query fails, fall back to public schema\n\t}\n\treturn \"public\";\n}\n\nexport async function getMigrations(config: BetterAuthOptions) {\n\tconst betterAuthSchema = getSchema(config);\n\tconst logger = createLogger(config.logger);\n\n\tlet { kysely: db, databaseType: dbType } = await createKyselyAdapter(config);\n\n\tif (!dbType) {\n\t\tlogger.warn(\n\t\t\t\"Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.\",\n\t\t);\n\t\tdbType = \"sqlite\";\n\t}\n\n\tif (!db) {\n\t\tlogger.error(\n\t\t\t\"Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n\n\t// For PostgreSQL, detect and log the current schema being used\n\tlet currentSchema = \"public\";\n\tif (dbType === \"postgres\") {\n\t\tcurrentSchema = await getPostgresSchema(db);\n\t\tlogger.debug(\n\t\t\t`PostgreSQL migration: Using schema '${currentSchema}' (from search_path)`,\n\t\t);\n\n\t\t// Verify the schema exists\n\t\ttry {\n\t\t\tconst schemaCheck = await sql<{ schema_name: string }>`\n\t\t\t\tSELECT schema_name \n\t\t\t\tFROM information_schema.schemata \n\t\t\t\tWHERE schema_name = ${currentSchema}\n\t\t\t`.execute(db);\n\n\t\t\tif (!schemaCheck.rows[0]) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Schema '${currentSchema}' does not exist. Tables will be inspected from available schemas. Consider creating the schema first or checking your database configuration.`,\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlogger.debug(\n\t\t\t\t`Could not verify schema existence: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tconst allTableMetadata = await db.introspection.getTables();\n\n\t// For PostgreSQL, filter tables to only those in the target schema\n\tlet tableMetadata = allTableMetadata;\n\tif (dbType === \"postgres\") {\n\t\t// Get tables with their schema information\n\t\ttry {\n\t\t\tconst tablesInSchema = await sql<{\n\t\t\t\ttable_name: string;\n\t\t\t}>`\n\t\t\t\tSELECT table_name \n\t\t\t\tFROM information_schema.tables \n\t\t\t\tWHERE table_schema = ${currentSchema}\n\t\t\t\tAND table_type = 'BASE TABLE'\n\t\t\t`.execute(db);\n\n\t\t\tconst tableNamesInSchema = new Set(\n\t\t\t\ttablesInSchema.rows.map((row) => row.table_name),\n\t\t\t);\n\n\t\t\t// Filter to only tables that exist in the target schema\n\t\t\ttableMetadata = allTableMetadata.filter(\n\t\t\t\t(table) =>\n\t\t\t\t\ttable.schema === currentSchema && tableNamesInSchema.has(table.name),\n\t\t\t);\n\n\t\t\tlogger.debug(\n\t\t\t\t`Found ${tableMetadata.length} table(s) in schema '${currentSchema}': ${tableMetadata.map((t) => t.name).join(\", \") || \"(none)\"}`,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.warn(\n\t\t\t\t`Could not filter tables by schema. Using all discovered tables. Error: ${error instanceof Error ? error.message : String(error)}`,\n\t\t\t);\n\t\t\t// Fall back to using all tables if schema filtering fails\n\t\t}\n\t}\n\tconst toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\tconst toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[] = [];\n\n\tfor (const [key, value] of Object.entries(betterAuthSchema)) {\n\t\tconst table = tableMetadata.find((t) => t.name === key);\n\t\tif (!table) {\n\t\t\tconst tIndex = toBeCreated.findIndex((t) => t.table === key);\n\t\t\tconst tableData = {\n\t\t\t\ttable: key,\n\t\t\t\tfields: value.fields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t};\n\n\t\t\tconst insertIndex = toBeCreated.findIndex(\n\t\t\t\t(t) => (t.order || Infinity) > tableData.order,\n\t\t\t);\n\n\t\t\tif (insertIndex === -1) {\n\t\t\t\tif (tIndex === -1) {\n\t\t\t\t\ttoBeCreated.push(tableData);\n\t\t\t\t} else {\n\t\t\t\t\ttoBeCreated[tIndex]!.fields = {\n\t\t\t\t\t\t...toBeCreated[tIndex]!.fields,\n\t\t\t\t\t\t...value.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoBeCreated.splice(insertIndex, 0, tableData);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tconst toBeAddedFields: Record<string, DBFieldAttribute> = {};\n\t\tfor (const [fieldName, field] of Object.entries(value.fields)) {\n\t\t\tconst column = table.columns.find((c) => c.name === fieldName);\n\t\t\tif (!column) {\n\t\t\t\ttoBeAddedFields[fieldName] = field;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (matchType(column.dataType, field.type, dbType)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(toBeAddedFields).length > 0) {\n\t\t\ttoBeAdded.push({\n\t\t\t\ttable: key,\n\t\t\t\tfields: toBeAddedFields,\n\t\t\t\torder: value.order || Infinity,\n\t\t\t});\n\t\t}\n\t}\n\n\tconst migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[] = [];\n\n\tconst useUUIDs = config.advanced?.database?.generateId === \"uuid\";\n\tconst useNumberId =\n\t\tconfig.advanced?.database?.useNumberId ||\n\t\tconfig.advanced?.database?.generateId === \"serial\";\n\n\tfunction getType(field: DBFieldAttribute, fieldName: string) {\n\t\tconst type = field.type;\n\t\tconst provider = dbType || \"sqlite\";\n\t\ttype StringOnlyUnion<T> = T extends string ? T : never;\n\t\tconst typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t> = {\n\t\t\tstring: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"text\",\n\t\t\t\tmysql: field.unique\n\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t: field.references\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: field.sortable\n\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t: field.index\n\t\t\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t\t\t: \"text\",\n\t\t\t\tmssql:\n\t\t\t\t\tfield.unique || field.sortable\n\t\t\t\t\t\t? \"varchar(255)\"\n\t\t\t\t\t\t: field.references\n\t\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t\t: // mssql deprecated `text`, and the alternative is `varchar(max)`.\n\t\t\t\t\t\t\t\t// Kysely type interface doesn't support `text`, so we set this to `varchar(8000)` as\n\t\t\t\t\t\t\t\t// that's the max length for `varchar`\n\t\t\t\t\t\t\t\t\"varchar(8000)\",\n\t\t\t},\n\t\t\tboolean: {\n\t\t\t\tsqlite: \"integer\",\n\t\t\t\tpostgres: \"boolean\",\n\t\t\t\tmysql: \"boolean\",\n\t\t\t\tmssql: \"smallint\",\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tsqlite: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tpostgres: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmysql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t\tmssql: field.bigint ? \"bigint\" : \"integer\",\n\t\t\t},\n\t\t\tdate: {\n\t\t\t\tsqlite: \"date\",\n\t\t\t\tpostgres: \"timestamptz\",\n\t\t\t\tmysql: \"timestamp(3)\",\n\t\t\t\tmssql: sql`datetime2(3)`,\n\t\t\t},\n\t\t\tjson: {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\tid: {\n\t\t\t\tpostgres: useNumberId\n\t\t\t\t\t? sql`integer GENERATED BY DEFAULT AS IDENTITY`\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"uuid\"\n\t\t\t\t\t\t: \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\tforeignKeyId: {\n\t\t\t\tpostgres: useNumberId ? \"integer\" : useUUIDs ? \"uuid\" : \"text\",\n\t\t\t\tmysql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\"\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tmssql: useNumberId\n\t\t\t\t\t? \"integer\"\n\t\t\t\t\t: useUUIDs\n\t\t\t\t\t\t? \"varchar(36)\" /* Should be using `UNIQUEIDENTIFIER` but Kysely doesn't support it */\n\t\t\t\t\t\t: \"varchar(36)\",\n\t\t\t\tsqlite: useNumberId ? \"integer\" : \"text\",\n\t\t\t},\n\t\t\t\"string[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t\t\"number[]\": {\n\t\t\t\tsqlite: \"text\",\n\t\t\t\tpostgres: \"jsonb\",\n\t\t\t\tmysql: \"json\",\n\t\t\t\tmssql: \"varchar(8000)\",\n\t\t\t},\n\t\t} as const;\n\t\tif (fieldName === \"id\" || field.references?.field === \"id\") {\n\t\t\tif (fieldName === \"id\") {\n\t\t\t\treturn typeMap.id[provider];\n\t\t\t}\n\t\t\treturn typeMap.foreignKeyId[provider];\n\t\t}\n\t\tif (Array.isArray(type)) {\n\t\t\treturn \"text\";\n\t\t}\n\t\tif (!(type in typeMap)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Unsupported field type '${String(type)}' for field '${fieldName}'. Allowed types are: string, number, boolean, date, string[], number[]. If you need to store structured data, store it as a JSON string (type: \"string\") or split it into primitive fields. See https://better-auth.com/docs/advanced/schema#additional-fields`,\n\t\t\t);\n\t\t}\n\t\treturn typeMap[type][provider];\n\t}\n\tconst getModelName = initGetModelName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\tconst getFieldName = initGetFieldName({\n\t\tschema: getAuthTables(config),\n\t\tusePlural: false,\n\t});\n\n\t// Helper function to safely resolve model and field names, falling back to\n\t// user-supplied strings for external tables not in the BetterAuth schema\n\tfunction getReferencePath(model: string, field: string): string {\n\t\ttry {\n\t\t\tconst modelName = getModelName(model);\n\t\t\tconst fieldName = getFieldName({ model, field });\n\t\t\treturn `${modelName}.${fieldName}`;\n\t\t} catch {\n\t\t\t// If resolution fails (external table), fall back to user-supplied references\n\t\t\treturn `${model}.${field}`;\n\t\t}\n\t}\n\n\tif (toBeAdded.length) {\n\t\tfor (const table of toBeAdded) {\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tconst builder = db.schema.alterTable(table.table);\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst index = db.schema\n\t\t\t\t\t\t.alterTable(table.table)\n\t\t\t\t\t\t.addIndex(`${table.table}_${fieldName}_idx`);\n\t\t\t\t\tmigrations.push(index);\n\t\t\t\t}\n\n\t\t\t\tconst built = builder.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\t\t\t\tmigrations.push(built);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst toBeIndexed: CreateIndexBuilder[] = [];\n\n\tif (config.advanced?.database?.useNumberId) {\n\t\tlogger.warn(\n\t\t\t\"`useNumberId` is deprecated. Please use `generateId` with `serial` instead.\",\n\t\t);\n\t}\n\n\tif (toBeCreated.length) {\n\t\tfor (const table of toBeCreated) {\n\t\t\tconst idType = getType({ type: useNumberId ? \"number\" : \"string\" }, \"id\");\n\t\t\tlet dbT = db.schema\n\t\t\t\t.createTable(table.table)\n\t\t\t\t.addColumn(\"id\", idType, (col) => {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\t// Identity column is already specified in the type via sql template tag\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"sqlite\") {\n\t\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t\t} else if (dbType === \"mssql\") {\n\t\t\t\t\t\t\treturn col.identity().primaryKey().notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.autoIncrement().primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\tif (useUUIDs) {\n\t\t\t\t\t\tif (dbType === \"postgres\") {\n\t\t\t\t\t\t\treturn col\n\t\t\t\t\t\t\t\t.primaryKey()\n\t\t\t\t\t\t\t\t.defaultTo(sql`pg_catalog.gen_random_uuid()`)\n\t\t\t\t\t\t\t\t.notNull();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t\t}\n\t\t\t\t\treturn col.primaryKey().notNull();\n\t\t\t\t});\n\n\t\t\tfor (const [fieldName, field] of Object.entries(table.fields)) {\n\t\t\t\tconst type = getType(field, fieldName);\n\t\t\t\tdbT = dbT.addColumn(fieldName, type, (col) => {\n\t\t\t\t\tcol = field.required !== false ? col.notNull() : col;\n\t\t\t\t\tif (field.references) {\n\t\t\t\t\t\tcol = col\n\t\t\t\t\t\t\t.references(\n\t\t\t\t\t\t\t\tgetReferencePath(\n\t\t\t\t\t\t\t\t\tfield.references.model,\n\t\t\t\t\t\t\t\t\tfield.references.field,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.onDelete(field.references.onDelete || \"cascade\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field.unique) {\n\t\t\t\t\t\tcol = col.unique();\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tfield.type === \"date\" &&\n\t\t\t\t\t\ttypeof field.defaultValue === \"function\" &&\n\t\t\t\t\t\t(dbType === \"postgres\" || dbType === \"mysql\" || dbType === \"mssql\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (dbType === \"mysql\") {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP(3)`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol = col.defaultTo(sql`CURRENT_TIMESTAMP`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn col;\n\t\t\t\t});\n\n\t\t\t\tif (field.index) {\n\t\t\t\t\tconst builder = db.schema\n\t\t\t\t\t\t.createIndex(\n\t\t\t\t\t\t\t`${table.table}_${fieldName}_${field.unique ? \"uidx\" : \"idx\"}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.on(table.table)\n\t\t\t\t\t\t.columns([fieldName]);\n\t\t\t\t\ttoBeIndexed.push(field.unique ? builder.unique() : builder);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmigrations.push(dbT);\n\t\t}\n\t}\n\n\t// instead of adding the index straight to `migrations`,\n\t// we do this at the end so that indexes are created after the table is created\n\tif (toBeIndexed.length) {\n\t\tfor (const index of toBeIndexed) {\n\t\t\tmigrations.push(index);\n\t\t}\n\t}\n\n\tasync function runMigrations() {\n\t\tfor (const migration of migrations) {\n\t\t\tawait migration.execute();\n\t\t}\n\t}\n\tasync function compileMigrations() {\n\t\tconst compiled = migrations.map((m) => m.compile().sql);\n\t\treturn compiled.join(\";\\n\\n\") + \";\";\n\t}\n\treturn { toBeCreated, toBeAdded, runMigrations, compileMigrations };\n}\n"],"names":["logger","toBeCreated: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAdded: {\n\t\ttable: string;\n\t\tfields: Record<string, DBFieldAttribute>;\n\t\torder: number;\n\t}[]","toBeAddedFields: Record<string, DBFieldAttribute>","migrations: (\n\t\t| AlterTableColumnAlteringBuilder\n\t\t| ReturnType<AlterTableBuilder[\"addIndex\"]>\n\t\t| CreateTableBuilder<string, string>\n\t\t| CreateIndexBuilder\n\t)[]","typeMap: Record<\n\t\t\tStringOnlyUnion<DBFieldType> | \"id\" | \"foreignKeyId\",\n\t\t\tRecord<KyselyDatabaseType, ColumnDataType | RawBuilder<unknown>>\n\t\t>","toBeIndexed: CreateIndexBuilder[]"],"mappings":"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"}},
    {"offset": {"line": 3697, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/db/index.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/db/index.ts"],"sourcesContent":["export * from \"@better-auth/core/db\";\nexport * from \"./adapter-base\";\nexport * from \"./adapter-kysely\";\nexport * from \"./field\";\nexport * from \"./field-converter\";\nexport * from \"./get-migration\";\nexport * from \"./get-schema\";\nexport * from \"./internal-adapter\";\nexport * from \"./schema\";\nexport * from \"./to-zod\";\nexport * from \"./with-hooks\";\n"],"names":[],"mappings":""}},
    {"offset": {"line": 3757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/session.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/session.ts"],"sourcesContent":["import type {\n\tBetterAuthOptions,\n\tGenericEndpointContext,\n} from \"@better-auth/core\";\nimport {\n\tcreateAuthEndpoint,\n\tcreateAuthMiddleware,\n} from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport { base64Url } from \"@better-auth/utils/base64\";\nimport { binary } from \"@better-auth/utils/binary\";\nimport { createHMAC } from \"@better-auth/utils/hmac\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport {\n\tdeleteSessionCookie,\n\texpireCookie,\n\tgetChunkedCookie,\n\tsetCookieCache,\n\tsetSessionCookie,\n} from \"../../cookies\";\nimport { getSessionQuerySchema } from \"../../cookies/session-store\";\nimport { symmetricDecodeJWT, verifyJWT } from \"../../crypto\";\nimport { parseSessionOutput, parseUserOutput } from \"../../db\";\nimport type { InferSession, InferUser, Session, User } from \"../../types\";\nimport type { Prettify } from \"../../types/helper\";\nimport { getDate } from \"../../utils/date\";\n\nexport const getSession = <Option extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/get-session\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\toperationId: \"getSession\",\n\t\t\tquery: getSessionQuerySchema,\n\t\t\trequireHeaders: true,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"getSession\",\n\t\t\t\t\tdescription: \"Get the current session\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/Session\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"session\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tctx,\n\t\t): Promise<{\n\t\t\tsession: InferSession<Option>;\n\t\t\tuser: InferUser<Option>;\n\t\t} | null> => {\n\t\t\ttry {\n\t\t\t\tconst sessionCookieToken = await ctx.getSignedCookie(\n\t\t\t\t\tctx.context.authCookies.sessionToken.name,\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t);\n\n\t\t\t\tif (!sessionCookieToken) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst sessionDataCookie = getChunkedCookie(\n\t\t\t\t\tctx,\n\t\t\t\t\tctx.context.authCookies.sessionData.name,\n\t\t\t\t);\n\n\t\t\t\tlet sessionDataPayload: {\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t};\n\t\t\t\t\texpiresAt: number;\n\t\t\t\t} | null = null;\n\n\t\t\t\tif (sessionDataCookie) {\n\t\t\t\t\tconst strategy =\n\t\t\t\t\t\tctx.context.options.session?.cookieCache?.strategy || \"compact\";\n\n\t\t\t\t\tif (strategy === \"jwe\") {\n\t\t\t\t\t\t// Decode JWE (encrypted)\n\t\t\t\t\t\tconst payload = await symmetricDecodeJWT<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\texp?: number;\n\t\t\t\t\t\t}>(sessionDataCookie, ctx.context.secret, \"better-auth-session\");\n\n\t\t\t\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t\t\t\tsessionDataPayload = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\t\t\t\tversion: payload.version,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1000 : Date.now(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (strategy === \"jwt\") {\n\t\t\t\t\t\t// Decode JWT (signed with HMAC, not encrypted)\n\t\t\t\t\t\tconst payload = await verifyJWT<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\texp?: number;\n\t\t\t\t\t\t}>(sessionDataCookie, ctx.context.secret);\n\n\t\t\t\t\t\tif (payload && payload.session && payload.user) {\n\t\t\t\t\t\t\tsessionDataPayload = {\n\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\tsession: payload.session,\n\t\t\t\t\t\t\t\t\tuser: payload.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: payload.updatedAt,\n\t\t\t\t\t\t\t\t\tversion: payload.version,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\texpiresAt: payload.exp ? payload.exp * 1000 : Date.now(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Decode compact format (or legacy base64-hmac)\n\t\t\t\t\t\tconst parsed = safeJSONParse<{\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsignature: string;\n\t\t\t\t\t\t\texpiresAt: number;\n\t\t\t\t\t\t}>(binary.decode(base64Url.decode(sessionDataCookie)));\n\n\t\t\t\t\t\tif (parsed) {\n\t\t\t\t\t\t\tconst isValid = await createHMAC(\n\t\t\t\t\t\t\t\t\"SHA-256\",\n\t\t\t\t\t\t\t\t\"base64urlnopad\",\n\t\t\t\t\t\t\t).verify(\n\t\t\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\t\t\texpiresAt: parsed.expiresAt,\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tparsed.signature,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\t\tsessionDataPayload = parsed;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dontRememberMe = await ctx.getSignedCookie(\n\t\t\t\t\tctx.context.authCookies.dontRememberToken.name,\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * If session data is present in the cookie, check if it should be used or refreshed\n\t\t\t\t */\n\t\t\t\tif (\n\t\t\t\t\tsessionDataPayload?.session &&\n\t\t\t\t\tctx.context.options.session?.cookieCache?.enabled &&\n\t\t\t\t\t!ctx.query?.disableCookieCache\n\t\t\t\t) {\n\t\t\t\t\tconst session = sessionDataPayload.session;\n\n\t\t\t\t\tconst versionConfig =\n\t\t\t\t\t\tctx.context.options.session?.cookieCache?.version;\n\t\t\t\t\tlet expectedVersion = \"1\";\n\t\t\t\t\tif (versionConfig) {\n\t\t\t\t\t\tif (typeof versionConfig === \"string\") {\n\t\t\t\t\t\t\texpectedVersion = versionConfig;\n\t\t\t\t\t\t} else if (typeof versionConfig === \"function\") {\n\t\t\t\t\t\t\tconst result = versionConfig(session.session, session.user);\n\t\t\t\t\t\t\texpectedVersion =\n\t\t\t\t\t\t\t\tresult instanceof Promise ? await result : result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cookieVersion = session.version || \"1\";\n\t\t\t\t\tif (cookieVersion !== expectedVersion) {\n\t\t\t\t\t\t// Version mismatch - invalidate the cookie cache\n\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst cachedSessionExpiresAt = new Date(\n\t\t\t\t\t\t\tsession.session.expiresAt as unknown as string | number | Date,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hasExpired =\n\t\t\t\t\t\t\tsessionDataPayload.expiresAt < Date.now() ||\n\t\t\t\t\t\t\tcachedSessionExpiresAt < new Date();\n\n\t\t\t\t\t\tif (hasExpired) {\n\t\t\t\t\t\t\t// When the session data cookie has expired, delete it;\n\t\t\t\t\t\t\t//  then we try to fetch from DB\n\t\t\t\t\t\t\texpireCookie(ctx, ctx.context.authCookies.sessionData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Check if the cookie cache needs to be refreshed based on refreshCache\n\t\t\t\t\t\t\tconst cookieRefreshCache =\n\t\t\t\t\t\t\t\tctx.context.sessionConfig.cookieRefreshCache;\n\n\t\t\t\t\t\t\tif (cookieRefreshCache === false) {\n\t\t\t\t\t\t\t\t// If refreshCache is disabled, return the session from cookie as-is\n\t\t\t\t\t\t\t\tctx.context.session = session;\n\t\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\t\t// Rehydrate date fields from JSON strings before parsing\n\t\t\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(session.session.expiresAt),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(session.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(session.session.updatedAt),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t\t...session.user,\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(session.user.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(session.user.updatedAt),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst timeUntilExpiry = sessionDataPayload.expiresAt - Date.now();\n\t\t\t\t\t\t\tconst updateAge = cookieRefreshCache.updateAge * 1000; // Convert to milliseconds\n\n\t\t\t\t\t\t\tif (timeUntilExpiry < updateAge) {\n\t\t\t\t\t\t\t\tconst cookieMaxAge =\n\t\t\t\t\t\t\t\t\tctx.context.options.session?.cookieCache?.maxAge || 60 * 5;\n\t\t\t\t\t\t\t\tconst newExpiresAt = getDate(cookieMaxAge, \"sec\");\n\t\t\t\t\t\t\t\tconst refreshedSession = {\n\t\t\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\t\t\texpiresAt: newExpiresAt,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Set the refreshed cookie cache\n\t\t\t\t\t\t\t\tawait setCookieCache(ctx, refreshedSession, false);\n\n\t\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\t\t// Rehydrate date fields from JSON strings before parsing\n\t\t\t\t\t\t\t\tconst parsedRefreshedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t...refreshedSession.session,\n\t\t\t\t\t\t\t\t\t\texpiresAt: new Date(refreshedSession.session.expiresAt),\n\t\t\t\t\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.session.updatedAt),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst parsedRefreshedUser = parseUserOutput(\n\t\t\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t...refreshedSession.user,\n\t\t\t\t\t\t\t\t\t\tcreatedAt: new Date(refreshedSession.user.createdAt),\n\t\t\t\t\t\t\t\t\t\tupdatedAt: new Date(refreshedSession.user.updatedAt),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tctx.context.session = {\n\t\t\t\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedRefreshedUser,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\t\tsession: parsedRefreshedSession,\n\t\t\t\t\t\t\t\t\tuser: parsedRefreshedUser,\n\t\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t...session.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(session.session.expiresAt),\n\t\t\t\t\t\t\t\tcreatedAt: new Date(session.session.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(session.session.updatedAt),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, {\n\t\t\t\t\t\t\t\t...session.user,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(session.user.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(session.user.updatedAt),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tctx.context.session = {\n\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst session =\n\t\t\t\t\tawait ctx.context.internalAdapter.findSession(sessionCookieToken);\n\t\t\t\tctx.context.session = session;\n\t\t\t\tif (!session || session.session.expiresAt < new Date()) {\n\t\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\t\tif (session) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * if session expired clean up the session\n\t\t\t\t\t\t */\n\t\t\t\t\t\tawait ctx.context.internalAdapter.deleteSession(\n\t\t\t\t\t\t\tsession.session.token,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json(null);\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * We don't need to update the session if the user doesn't want to be remembered\n\t\t\t\t * or if the session refresh is disabled\n\t\t\t\t */\n\t\t\t\tif (dontRememberMe || ctx.query?.disableRefresh) {\n\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\tconst parsedSession = parseSessionOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tsession.session,\n\t\t\t\t\t);\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t} as {\n\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst expiresIn = ctx.context.sessionConfig.expiresIn;\n\t\t\t\tconst updateAge = ctx.context.sessionConfig.updateAge;\n\t\t\t\t/**\n\t\t\t\t * Calculate last updated date to throttle write updates to database\n\t\t\t\t * Formula: ({expiry date} - sessionMaxAge) + sessionUpdateAge\n\t\t\t\t *\n\t\t\t\t * e.g. ({expiry date} - 30 days) + 1 hour\n\t\t\t\t *\n\t\t\t\t * inspired by: https://github.com/nextauthjs/next-auth/blob/main/packages/core/src/lib/actions/session.ts\n\t\t\t\t */\n\t\t\t\tconst sessionIsDueToBeUpdatedDate =\n\t\t\t\t\tsession.session.expiresAt.valueOf() -\n\t\t\t\t\texpiresIn * 1000 +\n\t\t\t\t\tupdateAge * 1000;\n\t\t\t\tconst shouldBeUpdated = sessionIsDueToBeUpdatedDate <= Date.now();\n\n\t\t\t\tif (\n\t\t\t\t\tshouldBeUpdated &&\n\t\t\t\t\t(!ctx.query?.disableRefresh ||\n\t\t\t\t\t\t!ctx.context.options.session?.disableSessionRefresh)\n\t\t\t\t) {\n\t\t\t\t\tconst updatedSession =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateSession(\n\t\t\t\t\t\t\tsession.session.token,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\texpiresAt: getDate(ctx.context.sessionConfig.expiresIn, \"sec\"),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\tif (!updatedSession) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Handle case where session update fails (e.g., concurrent deletion)\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdeleteSessionCookie(ctx);\n\t\t\t\t\t\treturn ctx.json(null, { status: 401 });\n\t\t\t\t\t}\n\t\t\t\t\tconst maxAge =\n\t\t\t\t\t\t(updatedSession.expiresAt.valueOf() - Date.now()) / 1000;\n\t\t\t\t\tawait setSessionCookie(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmaxAge,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\n\t\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\t\tconst parsedUpdatedSession = parseSessionOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tupdatedSession,\n\t\t\t\t\t);\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tsession: parsedUpdatedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t} as unknown as {\n\t\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setCookieCache(ctx, session, !!dontRememberMe);\n\t\t\t\t// Parse session and user to ensure additionalFields are included\n\t\t\t\tconst parsedSession = parseSessionOutput(\n\t\t\t\t\tctx.context.options,\n\t\t\t\t\tsession.session,\n\t\t\t\t);\n\t\t\t\tconst parsedUser = parseUserOutput(ctx.context.options, session.user);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\tuser: parsedUser,\n\t\t\t\t} as {\n\t\t\t\t\tsession: InferSession<Option>;\n\t\t\t\t\tuser: InferUser<Option>;\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\"INTERNAL_SERVER_ERROR\", error);\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_SESSION,\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t);\n\nexport const getSessionFromCtx = async <\n\tU extends Record<string, any> = Record<string, any>,\n\tS extends Record<string, any> = Record<string, any>,\n>(\n\tctx: GenericEndpointContext,\n\tconfig?:\n\t\t| {\n\t\t\t\tdisableCookieCache?: boolean;\n\t\t\t\tdisableRefresh?: boolean;\n\t\t  }\n\t\t| undefined,\n) => {\n\tif (ctx.context.session) {\n\t\treturn ctx.context.session as {\n\t\t\tsession: S & Session;\n\t\t\tuser: U & User;\n\t\t};\n\t}\n\n\tconst session = await getSession()({\n\t\t...ctx,\n\t\tasResponse: false,\n\t\theaders: ctx.headers!,\n\t\treturnHeaders: false,\n\t\treturnStatus: false,\n\t\tquery: {\n\t\t\t...config,\n\t\t\t...ctx.query,\n\t\t},\n\t}).catch((e) => {\n\t\treturn null;\n\t});\n\tctx.context.session = session;\n\treturn session as {\n\t\tsession: S & Session;\n\t\tuser: U & User;\n\t} | null;\n};\n\n/**\n * The middleware forces the endpoint to require a valid session.\n */\nexport const sessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n\n/**\n * This middleware forces the endpoint to require a valid session and ignores cookie cache.\n * This should be used for sensitive operations like password changes, account deletion, etc.\n * to ensure that revoked sessions cannot be used even if they're still cached in cookies.\n */\nexport const sensitiveSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx, { disableCookieCache: true });\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n\n/**\n * This middleware allows you to call the endpoint on the client if session is valid.\n * However, if called on the server, no session is required.\n */\nexport const requestOnlySessionMiddleware = createAuthMiddleware(\n\tasync (ctx) => {\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session?.session && (ctx.request || ctx.headers)) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t\t}\n\t\treturn { session };\n\t},\n);\n\n/**\n * This middleware forces the endpoint to require a valid session,\n * as well as making sure the session is fresh before proceeding.\n *\n * Session freshness check will be skipped if the session config's freshAge\n * is set to 0\n */\nexport const freshSessionMiddleware = createAuthMiddleware(async (ctx) => {\n\tconst session = await getSessionFromCtx(ctx);\n\tif (!session?.session) {\n\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t}\n\tif (ctx.context.sessionConfig.freshAge === 0) {\n\t\treturn {\n\t\t\tsession,\n\t\t};\n\t}\n\tconst freshAge = ctx.context.sessionConfig.freshAge;\n\tconst lastUpdated = new Date(\n\t\tsession.session.updatedAt || session.session.createdAt,\n\t).getTime();\n\tconst now = Date.now();\n\tconst isFresh = now - lastUpdated < freshAge * 1000;\n\tif (!isFresh) {\n\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\tmessage: \"Session is not fresh\",\n\t\t});\n\t}\n\treturn {\n\t\tsession,\n\t};\n});\n/**\n * user active sessions list\n */\nexport const listSessions = <Option extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/list-sessions\",\n\t\t{\n\t\t\tmethod: \"GET\",\n\t\t\toperationId: \"listUserSessions\",\n\t\t\tuse: [sessionMiddleware],\n\t\t\trequireHeaders: true,\n\t\t\tmetadata: {\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"listUserSessions\",\n\t\t\t\t\tdescription: \"List all active sessions for the user\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/Session\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\ttry {\n\t\t\t\tconst sessions = await ctx.context.internalAdapter.listSessions(\n\t\t\t\t\tctx.context.session.user.id,\n\t\t\t\t);\n\t\t\t\tconst activeSessions = sessions.filter((session) => {\n\t\t\t\t\treturn session.expiresAt > new Date();\n\t\t\t\t});\n\t\t\t\treturn ctx.json(\n\t\t\t\t\tactiveSessions.map((session) =>\n\t\t\t\t\t\tparseSessionOutput(ctx.context.options, session),\n\t\t\t\t\t) as unknown as Prettify<InferSession<Option>>[],\n\t\t\t\t);\n\t\t\t} catch (e: any) {\n\t\t\t\tctx.context.logger.error(e);\n\t\t\t\tthrow ctx.error(\"INTERNAL_SERVER_ERROR\");\n\t\t\t}\n\t\t},\n\t);\n\n/**\n * revoke a single session\n */\nexport const revokeSession = createAuthEndpoint(\n\t\"/revoke-session\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to revoke\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Revoke a single session\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The token to revoke\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"token\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the session was revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst token = ctx.body.token;\n\t\tconst session = await ctx.context.internalAdapter.findSession(token);\n\n\t\tif (session?.session.userId === ctx.context.session.user.id) {\n\t\t\ttry {\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(token);\n\t\t\t} catch (error) {\n\t\t\t\tctx.context.logger.error(\n\t\t\t\t\terror && typeof error === \"object\" && \"name\" in error\n\t\t\t\t\t\t? (error.name as string)\n\t\t\t\t\t\t: \"\",\n\t\t\t\t\terror,\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t\t\t}\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n/**\n * revoke all user sessions\n */\nexport const revokeSessions = createAuthEndpoint(\n\t\"/revoke-sessions\",\n\t{\n\t\tmethod: \"POST\",\n\t\tuse: [sensitiveSessionMiddleware],\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Revoke all sessions for the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if all sessions were revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\ttry {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(\n\t\t\t\tctx.context.session.user.id,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tctx.context.logger.error(\n\t\t\t\terror && typeof error === \"object\" && \"name\" in error\n\t\t\t\t\t? (error.name as string)\n\t\t\t\t\t: \"\",\n\t\t\t\terror,\n\t\t\t);\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\");\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const revokeOtherSessions = createAuthEndpoint(\n\t\"/revoke-other-sessions\",\n\t{\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Revoke all other sessions for the user except the current one\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if all other sessions were revoked successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst session = ctx.context.session;\n\t\tif (!session.user) {\n\t\t\tthrow new APIError(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst sessions = await ctx.context.internalAdapter.listSessions(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst activeSessions = sessions.filter((session) => {\n\t\t\treturn session.expiresAt > new Date();\n\t\t});\n\t\tconst otherSessions = activeSessions.filter(\n\t\t\t(session) => session.token !== ctx.context.session.session.token,\n\t\t);\n\t\tawait Promise.all(\n\t\t\totherSessions.map((session) =>\n\t\t\t\tctx.context.internalAdapter.deleteSession(session.token),\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n"],"names":["sessionDataPayload: {\n\t\t\t\t\tsession: {\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\tupdatedAt: number;\n\t\t\t\t\t\tversion?: string;\n\t\t\t\t\t};\n\t\t\t\t\texpiresAt: number;\n\t\t\t\t} | null","session","parsedSession","parsedUser","e: any"],"mappings":"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"}},
    {"offset": {"line": 4328, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/oauth2/utils.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/oauth2/utils.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { symmetricDecrypt, symmetricEncrypt } from \"../crypto\";\n\nexport function decryptOAuthToken(token: string, ctx: AuthContext) {\n\tif (!token) return token;\n\tif (ctx.options.account?.encryptOAuthTokens) {\n\t\treturn symmetricDecrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n\nexport function setTokenUtil(\n\ttoken: string | null | undefined,\n\tctx: AuthContext,\n) {\n\tif (ctx.options.account?.encryptOAuthTokens && token) {\n\t\treturn symmetricEncrypt({\n\t\t\tkey: ctx.secret,\n\t\t\tdata: token,\n\t\t});\n\t}\n\treturn token;\n}\n"],"names":[],"mappings":";;;;;;;;;AAGA,SAAgB,kBAAkB,KAAA,EAAe,GAAA,EAAkB;IAClE,IAAI,CAAC,MAAO,CAAA,OAAO;IACnB,IAAI,IAAI,OAAA,CAAQ,OAAA,EAAS,mBACxB,CAAA,WAAO,4MAAA,EAAiB;QACvB,KAAK,IAAI,MAAA;QACT,MAAM;KACN,CAAC;IAEH,OAAO;;AAGR,SAAgB,aACf,KAAA,EACA,GAAA,EACC;IACD,IAAI,IAAI,OAAA,CAAQ,OAAA,EAAS,sBAAsB,MAC9C,CAAA,WAAO,4MAAA,EAAiB;QACvB,KAAK,IAAI,MAAA;QACT,MAAM;KACN,CAAC;IAEH,OAAO"}},
    {"offset": {"line": 4358, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/account.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/account.ts"],"sourcesContent":["import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport type { Account } from \"@better-auth/core/db\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport type { OAuth2Tokens } from \"@better-auth/core/oauth2\";\nimport { SocialProviderListEnum } from \"@better-auth/core/social-providers\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport {\n\tgetAccountCookie,\n\tsetAccountCookie,\n} from \"../../cookies/session-store\";\nimport { parseAccountOutput } from \"../../db/schema\";\nimport { generateState } from \"../../oauth2/state\";\nimport { decryptOAuthToken, setTokenUtil } from \"../../oauth2/utils\";\nimport {\n\tfreshSessionMiddleware,\n\tgetSessionFromCtx,\n\tsessionMiddleware,\n} from \"./session\";\n\nexport const listUserAccounts = createAuthEndpoint(\n\t\"/list-accounts\",\n\t{\n\t\tmethod: \"GET\",\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"listUserAccounts\",\n\t\t\t\tdescription: \"List all accounts linked to the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tproviderId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\taccountId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuserId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tscopes: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\"providerId\",\n\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t\"accountId\",\n\t\t\t\t\t\t\t\t\t\t\t\"userId\",\n\t\t\t\t\t\t\t\t\t\t\t\"scopes\",\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst session = c.context.session;\n\t\tconst accounts = await c.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\treturn c.json(\n\t\t\taccounts.map((a) => {\n\t\t\t\tconst { scope, ...parsed } = parseAccountOutput(c.context.options, a);\n\t\t\t\treturn {\n\t\t\t\t\t...parsed,\n\t\t\t\t\tscopes: scope?.split(\",\") || [],\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\t},\n);\n\nexport const linkSocialAccount = createAuthEndpoint(\n\t\"/link-social\",\n\t{\n\t\tmethod: \"POST\",\n\t\trequireHeaders: true,\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * Callback URL to redirect to after the user has signed in.\n\t\t\t */\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after the user has signed in\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * OAuth2 provider to use\n\t\t\t */\n\t\t\tprovider: SocialProviderListEnum,\n\t\t\t/**\n\t\t\t * ID Token for direct authentication without redirect\n\t\t\t */\n\t\t\tidToken: z\n\t\t\t\t.object({\n\t\t\t\t\ttoken: z.string(),\n\t\t\t\t\tnonce: z.string().optional(),\n\t\t\t\t\taccessToken: z.string().optional(),\n\t\t\t\t\trefreshToken: z.string().optional(),\n\t\t\t\t\tscopes: z.array(z.string()).optional(),\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Whether to allow sign up for new users\n\t\t\t */\n\t\t\trequestSignUp: z.boolean().optional(),\n\t\t\t/**\n\t\t\t * Additional scopes to request when linking the account.\n\t\t\t * This is useful for requesting additional permissions when\n\t\t\t * linking a social account compared to the initial authentication.\n\t\t\t */\n\t\t\tscopes: z\n\t\t\t\t.array(z.string())\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Additional scopes to request from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The URL to redirect to if there is an error during the link process.\n\t\t\t */\n\t\t\terrorCallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The URL to redirect to if there is an error during the link process\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Disable automatic redirection to the provider\n\t\t\t *\n\t\t\t * This is useful if you want to handle the redirection\n\t\t\t * yourself like in a popup or a different tab.\n\t\t\t */\n\t\t\tdisableRedirect: z\n\t\t\t\t.boolean()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"Disable automatic redirection to the provider. Useful for handling the redirection yourself\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Any additional data to pass through the oauth flow.\n\t\t\t */\n\t\t\tadditionalData: z.record(z.string(), z.any()).optional(),\n\t\t}),\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Link a social account to the user\",\n\t\t\t\toperationId: \"linkSocialAccount\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"The authorization URL to redirect the user to\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the user should be redirected to the authorization URL\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"redirect\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst session = c.context.session;\n\n\t\tconst provider = c.context.socialProviders.find(\n\t\t\t(p) => p.id === c.body.provider,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Provider not found. Make sure to add the provider in your auth config\",\n\t\t\t\t{\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t},\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PROVIDER_NOT_FOUND,\n\t\t\t});\n\t\t}\n\n\t\t// Handle ID Token flow if provided\n\t\tif (c.body.idToken) {\n\t\t\tif (!provider.verifyIdToken) {\n\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\"Provider does not support id token verification\",\n\t\t\t\t\t{\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { token, nonce } = c.body.idToken;\n\t\t\tconst valid = await provider.verifyIdToken(token, nonce);\n\t\t\tif (!valid) {\n\t\t\t\tc.context.logger.error(\"Invalid id token\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst linkingUserInfo = await provider.getUserInfo({\n\t\t\t\tidToken: token,\n\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t});\n\n\t\t\tif (!linkingUserInfo || !linkingUserInfo?.user) {\n\t\t\t\tc.context.logger.error(\"Failed to get user info\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst linkingUserId = String(linkingUserInfo.user.id);\n\n\t\t\tif (!linkingUserInfo.user.email) {\n\t\t\t\tc.context.logger.error(\"User email not found\", {\n\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t});\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst existingAccounts = await c.context.internalAdapter.findAccounts(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\n\t\t\tconst hasBeenLinked = existingAccounts.find(\n\t\t\t\t(a) => a.providerId === provider.id && a.accountId === linkingUserId,\n\t\t\t);\n\n\t\t\tif (hasBeenLinked) {\n\t\t\t\treturn c.json({\n\t\t\t\t\turl: \"\", // this is for type inference\n\t\t\t\t\tstatus: true,\n\t\t\t\t\tredirect: false,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\n\t\t\tconst isTrustedProvider = trustedProviders?.includes(provider.id);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !linkingUserInfo.user.emailVerified) ||\n\t\t\t\tc.context.options.account?.accountLinking?.enabled === false\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Account not linked - linking not allowed\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tlinkingUserInfo.user.email !== session.user.email &&\n\t\t\t\tc.context.options.account?.accountLinking?.allowDifferentEmails !== true\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: \"Account not linked - different emails not allowed\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.createAccount({\n\t\t\t\t\tuserId: session.user.id,\n\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\taccountId: linkingUserId,\n\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\tidToken: token,\n\t\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t\t\tscope: c.body.idToken.scopes?.join(\",\"),\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\tthrow new APIError(\"EXPECTATION_FAILED\", {\n\t\t\t\t\tmessage: \"Account not linked - unable to create account\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tc.context.options.account?.accountLinking?.updateUserInfoOnLink === true\n\t\t\t) {\n\t\t\t\ttry {\n\t\t\t\t\tawait c.context.internalAdapter.updateUser(session.user.id, {\n\t\t\t\t\t\tname: linkingUserInfo.user?.name,\n\t\t\t\t\t\timage: linkingUserInfo.user?.image,\n\t\t\t\t\t});\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tconsole.warn(\"Could not update user - \" + e.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn c.json({\n\t\t\t\turl: \"\", // this is for type inference\n\t\t\t\tstatus: true,\n\t\t\t\tredirect: false,\n\t\t\t});\n\t\t}\n\n\t\t// Handle OAuth flow\n\t\tconst state = await generateState(\n\t\t\tc,\n\t\t\t{\n\t\t\t\tuserId: session.user.id,\n\t\t\t\temail: session.user.email,\n\t\t\t},\n\t\t\tc.body.additionalData,\n\t\t);\n\n\t\tconst url = await provider.createAuthorizationURL({\n\t\t\tstate: state.state,\n\t\t\tcodeVerifier: state.codeVerifier,\n\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\tscopes: c.body.scopes,\n\t\t});\n\n\t\tif (!c.body.disableRedirect) {\n\t\t\tc.setHeader(\"Location\", url.toString());\n\t\t}\n\n\t\treturn c.json({\n\t\t\turl: url.toString(),\n\t\t\tredirect: !c.body.disableRedirect,\n\t\t});\n\t},\n);\nexport const unlinkAccount = createAuthEndpoint(\n\t\"/unlink-account\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string(),\n\t\t\taccountId: z.string().optional(),\n\t\t}),\n\t\tuse: [freshSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Unlink an account\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId } = ctx.body;\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tctx.context.session.user.id,\n\t\t);\n\t\tif (\n\t\t\taccounts.length === 1 &&\n\t\t\t!ctx.context.options.account?.accountLinking?.allowUnlinkingAll\n\t\t) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_UNLINK_LAST_ACCOUNT,\n\t\t\t});\n\t\t}\n\t\tconst accountExist = accounts.find((account) =>\n\t\t\taccountId\n\t\t\t\t? account.accountId === accountId && account.providerId === providerId\n\t\t\t\t: account.providerId === providerId,\n\t\t);\n\t\tif (!accountExist) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.ACCOUNT_NOT_FOUND,\n\t\t\t});\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteAccount(accountExist.id);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const getAccessToken = createAuthEndpoint(\n\t\"/get-access-token\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string().meta({\n\t\t\t\tdescription: \"The provider ID for the OAuth provider\",\n\t\t\t}),\n\t\t\taccountId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The account ID associated with the refresh token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\tuserId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The user ID associated with the account\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Get a valid access token, doing a refresh if needed\",\n\t\t\t\tresponses: {\n\t\t\t\t\t200: {\n\t\t\t\t\t\tdescription: \"A Valid access token\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttokenType: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tidToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t400: {\n\t\t\t\t\t\tdescription: \"Invalid refresh token or provider configuration\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId, userId } = ctx.body || {};\n\t\tconst req = ctx.request;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (req && !session) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst resolvedUserId = session?.user?.id || userId;\n\t\tif (!resolvedUserId) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tif (!ctx.context.socialProviders.find((p) => p.id === providerId)) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} is not supported.`,\n\t\t\t});\n\t\t}\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tlet account: Account | undefined = undefined;\n\t\tif (\n\t\t\taccountData &&\n\t\t\tproviderId === accountData.providerId &&\n\t\t\t(!accountId || accountData.id === accountId)\n\t\t) {\n\t\t\taccount = accountData;\n\t\t} else {\n\t\t\tconst accounts =\n\t\t\t\tawait ctx.context.internalAdapter.findAccounts(resolvedUserId);\n\t\t\taccount = accounts.find((acc) =>\n\t\t\t\taccountId\n\t\t\t\t\t? acc.id === accountId && acc.providerId === providerId\n\t\t\t\t\t: acc.providerId === providerId,\n\t\t\t);\n\t\t}\n\n\t\tif (!account) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === providerId,\n\t\t);\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} not found.`,\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tlet newTokens: OAuth2Tokens | null = null;\n\t\t\tconst accessTokenExpired =\n\t\t\t\taccount.accessTokenExpiresAt &&\n\t\t\t\tnew Date(account.accessTokenExpiresAt).getTime() - Date.now() < 5_000;\n\t\t\tif (\n\t\t\t\taccount.refreshToken &&\n\t\t\t\taccessTokenExpired &&\n\t\t\t\tprovider.refreshAccessToken\n\t\t\t) {\n\t\t\t\tconst refreshToken = await decryptOAuthToken(\n\t\t\t\t\taccount.refreshToken,\n\t\t\t\t\tctx.context,\n\t\t\t\t);\n\t\t\t\tnewTokens = await provider.refreshAccessToken(refreshToken);\n\t\t\t\tconst updatedData = {\n\t\t\t\t\taccessToken: await setTokenUtil(newTokens.accessToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: newTokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshToken: await setTokenUtil(newTokens.refreshToken, ctx.context),\n\t\t\t\t\trefreshTokenExpiresAt: newTokens.refreshTokenExpiresAt,\n\t\t\t\t};\n\t\t\t\tlet updatedAccount: Record<string, any> | null = null;\n\t\t\t\tif (account.id) {\n\t\t\t\t\tupdatedAccount = await ctx.context.internalAdapter.updateAccount(\n\t\t\t\t\t\taccount.id,\n\t\t\t\t\t\tupdatedData,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\t\t\t\tawait setAccountCookie(ctx, {\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\t...(updatedAccount ?? updatedData),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst accessTokenExpiresAt = (() => {\n\t\t\t\tif (newTokens?.accessTokenExpiresAt) {\n\t\t\t\t\tif (typeof newTokens.accessTokenExpiresAt === \"string\") {\n\t\t\t\t\t\treturn new Date(newTokens.accessTokenExpiresAt);\n\t\t\t\t\t}\n\t\t\t\t\treturn newTokens.accessTokenExpiresAt;\n\t\t\t\t}\n\t\t\t\tif (account.accessTokenExpiresAt) {\n\t\t\t\t\tif (typeof account.accessTokenExpiresAt === \"string\") {\n\t\t\t\t\t\treturn new Date(account.accessTokenExpiresAt);\n\t\t\t\t\t}\n\t\t\t\t\treturn account.accessTokenExpiresAt;\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})();\n\n\t\t\tconst tokens = {\n\t\t\t\taccessToken:\n\t\t\t\t\tnewTokens?.accessToken ??\n\t\t\t\t\t(await decryptOAuthToken(account.accessToken ?? \"\", ctx.context)),\n\t\t\t\taccessTokenExpiresAt,\n\t\t\t\tscopes: account.scope?.split(\",\") ?? [],\n\t\t\t\tidToken: newTokens?.idToken ?? account.idToken ?? undefined,\n\t\t\t};\n\t\t\treturn ctx.json(tokens);\n\t\t} catch (error) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Failed to get a valid access token\",\n\t\t\t\tcause: error,\n\t\t\t});\n\t\t}\n\t},\n);\n\nexport const refreshToken = createAuthEndpoint(\n\t\"/refresh-token\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tproviderId: z.string().meta({\n\t\t\t\tdescription: \"The provider ID for the OAuth provider\",\n\t\t\t}),\n\t\t\taccountId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The account ID associated with the refresh token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\tuserId: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The user ID associated with the account\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Refresh the access token using a refresh token\",\n\t\t\t\tresponses: {\n\t\t\t\t\t200: {\n\t\t\t\t\t\tdescription: \"Access token refreshed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttokenType: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tidToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trefreshToken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trefreshTokenExpiresAt: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t400: {\n\t\t\t\t\t\tdescription: \"Invalid refresh token or provider configuration\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { providerId, accountId, userId } = ctx.body;\n\t\tconst req = ctx.request;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (req && !session) {\n\t\t\tthrow ctx.error(\"UNAUTHORIZED\");\n\t\t}\n\t\tconst resolvedUserId = session?.user?.id || userId;\n\t\tif (!resolvedUserId) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Either userId or session is required`,\n\t\t\t});\n\t\t}\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === providerId,\n\t\t);\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} not found.`,\n\t\t\t});\n\t\t}\n\t\tif (!provider.refreshAccessToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: `Provider ${providerId} does not support token refreshing.`,\n\t\t\t});\n\t\t}\n\n\t\t// Try to read refresh token from cookie first\n\t\tlet account: Account | undefined = undefined;\n\t\tconst accountData = await getAccountCookie(ctx);\n\t\tif (\n\t\t\taccountData &&\n\t\t\t(!providerId || providerId === accountData?.providerId)\n\t\t) {\n\t\t\taccount = accountData;\n\t\t} else {\n\t\t\tconst accounts =\n\t\t\t\tawait ctx.context.internalAdapter.findAccounts(resolvedUserId);\n\t\t\taccount = accounts.find((acc) =>\n\t\t\t\taccountId\n\t\t\t\t\t? acc.id === accountId && acc.providerId === providerId\n\t\t\t\t\t: acc.providerId === providerId,\n\t\t\t);\n\t\t}\n\n\t\tif (!account) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\n\t\tlet refreshToken: string | null | undefined = undefined;\n\t\tif (accountData && providerId === accountData.providerId) {\n\t\t\trefreshToken = accountData.refreshToken ?? undefined;\n\t\t} else {\n\t\t\trefreshToken = account.refreshToken ?? undefined;\n\t\t}\n\n\t\tif (!refreshToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Refresh token not found\",\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tconst decryptedRefreshToken = await decryptOAuthToken(\n\t\t\t\trefreshToken,\n\t\t\t\tctx.context,\n\t\t\t);\n\t\t\tconst tokens: OAuth2Tokens = await provider.refreshAccessToken(\n\t\t\t\tdecryptedRefreshToken,\n\t\t\t);\n\n\t\t\tif (account.id) {\n\t\t\t\tconst updateData = {\n\t\t\t\t\t...(account || {}),\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\t\t\tidToken: tokens.idToken || account.idToken,\n\t\t\t\t};\n\t\t\t\tawait ctx.context.internalAdapter.updateAccount(account.id, updateData);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\taccountData &&\n\t\t\t\tproviderId === accountData.providerId &&\n\t\t\t\tctx.context.options.account?.storeAccountCookie\n\t\t\t) {\n\t\t\t\tconst updateData = {\n\t\t\t\t\t...accountData,\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, ctx.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),\n\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\tscope: tokens.scopes?.join(\",\") || accountData.scope,\n\t\t\t\t\tidToken: tokens.idToken || accountData.idToken,\n\t\t\t\t};\n\t\t\t\tawait setAccountCookie(ctx, updateData);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\taccessToken: tokens.accessToken,\n\t\t\t\trefreshToken: tokens.refreshToken,\n\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\tscope: tokens.scopes?.join(\",\") || account.scope,\n\t\t\t\tidToken: tokens.idToken || account.idToken,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: account.accountId,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Failed to refresh access token\",\n\t\t\t\tcause: error,\n\t\t\t});\n\t\t}\n\t},\n);\n\nconst accountInfoQuerySchema = z.optional(\n\tz.object({\n\t\taccountId: z\n\t\t\t.string()\n\t\t\t.meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The provider given account id for which to get the account info\",\n\t\t\t})\n\t\t\t.optional(),\n\t}),\n);\n\nexport const accountInfo = createAuthEndpoint(\n\t\"/account-info\",\n\t{\n\t\tmethod: \"GET\",\n\t\tuse: [sessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Get the account info provided by the provider\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequired: [\"id\", \"emailVerified\"],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {},\n\t\t\t\t\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\", \"data\"],\n\t\t\t\t\t\t\t\t\tadditionalProperties: false,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tquery: accountInfoQuerySchema,\n\t},\n\tasync (ctx) => {\n\t\tconst providedAccountId = ctx.query?.accountId;\n\t\tlet account: Account | undefined = undefined;\n\t\tif (!providedAccountId) {\n\t\t\tif (ctx.context.options.account?.storeAccountCookie) {\n\t\t\t\tconst accountData = await getAccountCookie(ctx);\n\t\t\t\tif (accountData) {\n\t\t\t\t\taccount = accountData;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst accountData =\n\t\t\t\tawait ctx.context.internalAdapter.findAccount(providedAccountId);\n\t\t\tif (accountData) {\n\t\t\t\taccount = accountData;\n\t\t\t}\n\t\t}\n\n\t\tif (!account || account.userId !== ctx.context.session.user.id) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Account not found\",\n\t\t\t});\n\t\t}\n\n\t\tconst provider = ctx.context.socialProviders.find(\n\t\t\t(p) => p.id === account.providerId,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: `Provider account provider is ${account.providerId} but it is not configured`,\n\t\t\t});\n\t\t}\n\t\tconst tokens = await getAccessToken({\n\t\t\t...ctx,\n\t\t\tmethod: \"POST\",\n\t\t\tbody: {\n\t\t\t\taccountId: account.id,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t},\n\t\t\treturnHeaders: false,\n\t\t\treturnStatus: false,\n\t\t});\n\t\tif (!tokens.accessToken) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Access token not found\",\n\t\t\t});\n\t\t}\n\t\tconst info = await provider.getUserInfo({\n\t\t\t...tokens,\n\t\t\taccessToken: tokens.accessToken as string,\n\t\t});\n\t\treturn ctx.json(info);\n\t},\n);\n"],"names":["e: any","account: Account | undefined","newTokens: OAuth2Tokens | null","refreshToken","updatedAccount: Record<string, any> | null","refreshToken: string | null | undefined","tokens: OAuth2Tokens"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,MAAa,uBAAmB,qMAAA,EAC/B,kBACA;IACC,QAAQ;IACR,KAAK;QAAC,sMAAA;KAAkB;IACxB,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,OAAO;oCACN,MAAM;oCACN,YAAY;wCACX,IAAI;4CACH,MAAM;wCAAA,CACN;wCACD,YAAY;4CACX,MAAM;wCAAA,CACN;wCACD,WAAW;4CACV,MAAM;4CACN,QAAQ;yCACR;wCACD,WAAW;4CACV,MAAM;4CACN,QAAQ;yCACR;wCACD,WAAW;4CACV,MAAM;wCAAA,CACN;wCACD,QAAQ;4CACP,MAAM;wCAAA,CACN;wCACD,QAAQ;4CACP,MAAM;4CACN,OAAO;gDACN,MAAM;4CAAA,CACN;yCACD;qCACD;oCACD,UAAU;wCACT;wCACA;wCACA;wCACA;wCACA;wCACA;wCACA;qCACA;iCACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,MAAM;IACZ,MAAM,UAAU,EAAE,OAAA,CAAQ,OAAA;IAC1B,MAAM,WAAW,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAChD,QAAQ,IAAA,CAAK,EAAA,CACb;IACD,OAAO,EAAE,IAAA,CACR,SAAS,GAAA,CAAA,CAAK,MAAM;QACnB,MAAM,EAAE,KAAA,EAAO,GAAG,QAAA,OAAW,2LAAA,EAAmB,EAAE,OAAA,CAAQ,OAAA,EAAS,EAAE;QACrE,OAAO;YACN,GAAG,MAAA;YACH,QAAQ,OAAO,MAAM,IAAI,IAAI,EAAE;SAC/B;MACA,CACF;EAEF;AAED,MAAa,wBAAoB,qMAAA,EAChC,gBACA;IACC,QAAQ;IACR,gBAAgB;IAChB,MAAM,EAAE,qKAAA,CAAO;QAId,aAAa,EACX,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;QAIZ,UAAU,yOAAA;QAIV,SAAS,EACP,qKAAA,CAAO;YACP,OAAO,EAAE,qKAAA,EAAQ;YACjB,OAAO,EAAE,qKAAA,EAAQ,CAAC,QAAA,EAAU;YAC5B,aAAa,EAAE,qKAAA,EAAQ,CAAC,QAAA,EAAU;YAClC,cAAc,EAAE,qKAAA,EAAQ,CAAC,QAAA,EAAU;YACnC,QAAQ,EAAE,oKAAA,CAAM,EAAE,qKAAA,EAAQ,CAAC,CAAC,QAAA,EAAU;SACtC,CAAC,CACD,QAAA,EAAU;QAIZ,eAAe,EAAE,sKAAA,EAAS,CAAC,QAAA,EAAU;QAMrC,QAAQ,EACN,oKAAA,CAAM,EAAE,qKAAA,EAAQ,CAAC,CACjB,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;QAIZ,kBAAkB,EAChB,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aACC;QAAA,CACD,CAAC,CACD,QAAA,EAAU;QAOZ,iBAAiB,EACf,sKAAA,EAAS,CACT,IAAA,CAAK;YACL,aACC;QAAA,CACD,CAAC,CACD,QAAA,EAAU;QAIZ,gBAAgB,EAAE,qKAAA,CAAO,EAAE,qKAAA,EAAQ,EAAE,EAAE,kKAAA,EAAK,CAAC,CAAC,QAAA,EAAU;KACxD,CAAC;IACF,KAAK;QAAC,sMAAA;KAAkB;IACxB,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,KAAK;wCACJ,MAAM;wCACN,aACC;qCACD;oCACD,UAAU;wCACT,MAAM;wCACN,aACC;qCACD;oCACD,QAAQ;wCACP,MAAM;oCAAA,CACN;iCACD;gCACD,UAAU;oCAAC;iCAAW;6BACtB;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,MAAM;IACZ,MAAM,UAAU,EAAE,OAAA,CAAQ,OAAA;IAE1B,MAAM,WAAW,EAAE,OAAA,CAAQ,eAAA,CAAgB,IAAA,CAAA,CACzC,IAAM,EAAE,EAAA,KAAO,EAAE,IAAA,CAAK,QAAA,CACvB;IAED,IAAI,CAAC,UAAU;QACd,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAChB,yEACA;YACC,UAAU,EAAE,IAAA,CAAK,QAAA;QAAA,CACjB,CACD;QACD,MAAM,IAAI,0KAAA,CAAS,aAAa;YAC/B,SAAS,qMAAA,CAAiB,kBAAA;QAAA,CAC1B,CAAC;;IAIH,IAAI,EAAE,IAAA,CAAK,OAAA,EAAS;QACnB,IAAI,CAAC,SAAS,aAAA,EAAe;YAC5B,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAChB,mDACA;gBACC,UAAU,EAAE,IAAA,CAAK,QAAA;YAAA,CACjB,CACD;YACD,MAAM,IAAI,0KAAA,CAAS,aAAa;gBAC/B,SAAS,qMAAA,CAAiB,sBAAA;YAAA,CAC1B,CAAC;;QAGH,MAAM,EAAE,KAAA,EAAO,KAAA,EAAA,GAAU,EAAE,IAAA,CAAK,OAAA;QAEhC,IAAI,CADU,MAAM,SAAS,aAAA,CAAc,OAAO,MAAM,EAC5C;YACX,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,oBAAoB;gBAC1C,UAAU,EAAE,IAAA,CAAK,QAAA;YAAA,CACjB,CAAC;YACF,MAAM,IAAI,0KAAA,CAAS,gBAAgB;gBAClC,SAAS,qMAAA,CAAiB,aAAA;YAAA,CAC1B,CAAC;;QAGH,MAAM,kBAAkB,MAAM,SAAS,WAAA,CAAY;YAClD,SAAS;YACT,aAAa,EAAE,IAAA,CAAK,OAAA,CAAQ,WAAA;YAC5B,cAAc,EAAE,IAAA,CAAK,OAAA,CAAQ,YAAA;SAC7B,CAAC;QAEF,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,MAAM;YAC/C,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,2BAA2B;gBACjD,UAAU,EAAE,IAAA,CAAK,QAAA;YAAA,CACjB,CAAC;YACF,MAAM,IAAI,0KAAA,CAAS,gBAAgB;gBAClC,SAAS,qMAAA,CAAiB,uBAAA;YAAA,CAC1B,CAAC;;QAGH,MAAM,gBAAgB,OAAO,gBAAgB,IAAA,CAAK,EAAA,CAAG;QAErD,IAAI,CAAC,gBAAgB,IAAA,CAAK,KAAA,EAAO;YAChC,EAAE,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,wBAAwB;gBAC9C,UAAU,EAAE,IAAA,CAAK,QAAA;YAAA,CACjB,CAAC;YACF,MAAM,IAAI,0KAAA,CAAS,gBAAgB;gBAClC,SAAS,qMAAA,CAAiB,oBAAA;YAAA,CAC1B,CAAC;;QAWH,IAAA,CARyB,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,YAAA,CACxD,QAAQ,IAAA,CAAK,EAAA,CACb,EAEsC,IAAA,CAAA,CACrC,IAAM,EAAE,UAAA,KAAe,SAAS,EAAA,IAAM,EAAE,SAAA,KAAc,cACvD,CAGA,CAAA,OAAO,EAAE,IAAA,CAAK;YACb,KAAK;YACL,QAAQ;YACR,UAAU;SACV,CAAC;QAOH,IACE,CAJD,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,gBAAgB,kBAEA,SAAS,SAAS,EAAA,CAAG,IAEzC,CAAC,gBAAgB,IAAA,CAAK,aAAA,IAC7C,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,gBAAgB,YAAY,MAEvD,CAAA,MAAM,IAAI,0KAAA,CAAS,gBAAgB;YAClC,SAAS;QAAA,CACT,CAAC;QAGH,IACC,gBAAgB,IAAA,CAAK,KAAA,KAAU,QAAQ,IAAA,CAAK,KAAA,IAC5C,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,gBAAgB,yBAAyB,KAEpE,CAAA,MAAM,IAAI,0KAAA,CAAS,gBAAgB;YAClC,SAAS;QAAA,CACT,CAAC;QAGH,IAAI;YACH,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAAc;gBAC7C,QAAQ,QAAQ,IAAA,CAAK,EAAA;gBACrB,YAAY,SAAS,EAAA;gBACrB,WAAW;gBACX,aAAa,EAAE,IAAA,CAAK,OAAA,CAAQ,WAAA;gBAC5B,SAAS;gBACT,cAAc,EAAE,IAAA,CAAK,OAAA,CAAQ,YAAA;gBAC7B,OAAO,EAAE,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,KAAK,IAAI;aACvC,CAAC;iBACK;YACP,MAAM,IAAI,0KAAA,CAAS,sBAAsB;gBACxC,SAAS;YAAA,CACT,CAAC;;QAGH,IACC,EAAE,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,gBAAgB,yBAAyB,KAEpE,CAAA,IAAI;YACH,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,UAAA,CAAW,QAAQ,IAAA,CAAK,EAAA,EAAI;gBAC3D,MAAM,gBAAgB,IAAA,EAAM;gBAC5B,OAAO,gBAAgB,IAAA,EAAM;aAC7B,CAAC;iBACMA,GAAQ;YAChB,QAAQ,IAAA,CAAK,6BAA6B,EAAE,QAAA,EAAU,CAAC;;QAIzD,OAAO,EAAE,IAAA,CAAK;YACb,KAAK;YACL,QAAQ;YACR,UAAU;SACV,CAAC;;IAIH,MAAM,QAAQ,UAAM,yLAAA,EACnB,GACA;QACC,QAAQ,QAAQ,IAAA,CAAK,EAAA;QACrB,OAAO,QAAQ,IAAA,CAAK,KAAA;KACpB,EACD,EAAE,IAAA,CAAK,cAAA,CACP;IAED,MAAM,MAAM,MAAM,SAAS,sBAAA,CAAuB;QACjD,OAAO,MAAM,KAAA;QACb,cAAc,MAAM,YAAA;QACpB,aAAa,GAAG,EAAE,OAAA,CAAQ,OAAA,CAAQ,UAAA,EAAY,SAAS,EAAA,EAAA;QACvD,QAAQ,EAAE,IAAA,CAAK,MAAA;KACf,CAAC;IAEF,IAAI,CAAC,EAAE,IAAA,CAAK,eAAA,CACX,CAAA,EAAE,SAAA,CAAU,YAAY,IAAI,QAAA,EAAU,CAAC;IAGxC,OAAO,EAAE,IAAA,CAAK;QACb,KAAK,IAAI,QAAA,EAAU;QACnB,UAAU,CAAC,EAAE,IAAA,CAAK,eAAA;KAClB,CAAC;EAEH;AACD,MAAa,oBAAgB,qMAAA,EAC5B,mBACA;IACC,QAAQ;IACR,MAAM,EAAE,qKAAA,CAAO;QACd,YAAY,EAAE,qKAAA,EAAQ;QACtB,WAAW,EAAE,qKAAA,EAAQ,CAAC,QAAA,EAAU;KAChC,CAAC;IACF,KAAK;QAAC,2MAAA;KAAuB;IAC7B,UAAU;QACT,SAAS;YACR,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,QAAQ;wCACP,MAAM;oCAAA,CACN;gCAAA,CACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,EAAE,UAAA,EAAY,SAAA,EAAA,GAAc,IAAI,IAAA;IACtC,MAAM,WAAW,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAClD,IAAI,OAAA,CAAQ,OAAA,CAAQ,IAAA,CAAK,EAAA,CACzB;IACD,IACC,SAAS,MAAA,KAAW,KACpB,CAAC,IAAI,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,gBAAgB,kBAE9C,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,6BAAA;IAAA,CAC1B,CAAC;IAEH,MAAM,eAAe,SAAS,IAAA,CAAA,CAAM,UACnC,YACG,QAAQ,SAAA,KAAc,aAAa,QAAQ,UAAA,KAAe,aAC1D,QAAQ,UAAA,KAAe,WAC1B;IACD,IAAI,CAAC,aACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,iBAAA;IAAA,CAC1B,CAAC;IAEH,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAAc,aAAa,EAAA,CAAG;IAChE,OAAO,IAAI,IAAA,CAAK;QACf,QAAQ;IAAA,CACR,CAAC;EAEH;AAED,MAAa,qBAAiB,qMAAA,EAC7B,qBACA;IACC,QAAQ;IACR,MAAM,EAAE,qKAAA,CAAO;QACd,YAAY,EAAE,qKAAA,EAAQ,CAAC,IAAA,CAAK;YAC3B,aAAa;QAAA,CACb,CAAC;QACF,WAAW,EACT,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;QACZ,QAAQ,EACN,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;KACZ,CAAC;IACF,UAAU;QACT,SAAS;YACR,aAAa;YACb,WAAW;gBACV,KAAK;oBACJ,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,WAAW;wCACV,MAAM;oCAAA,CACN;oCACD,SAAS;wCACR,MAAM;oCAAA,CACN;oCACD,aAAa;wCACZ,MAAM;oCAAA,CACN;oCACD,sBAAsB;wCACrB,MAAM;wCACN,QAAQ;qCACR;iCACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;gBACD,KAAK;oBACJ,aAAa;gBAAA,CACb;aACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,EAAE,UAAA,EAAY,SAAA,EAAW,MAAA,EAAA,GAAW,IAAI,IAAA,IAAQ,CAAA,CAAE;IACxD,MAAM,MAAM,IAAI,OAAA;IAChB,MAAM,UAAU,UAAM,sMAAA,EAAkB,IAAI;IAC5C,IAAI,OAAO,CAAC,QACX,CAAA,MAAM,IAAI,KAAA,CAAM,eAAe;IAEhC,MAAM,iBAAiB,SAAS,MAAM,MAAM;IAC5C,IAAI,CAAC,eACJ,CAAA,MAAM,IAAI,KAAA,CAAM,eAAe;IAEhC,IAAI,CAAC,IAAI,OAAA,CAAQ,eAAA,CAAgB,IAAA,CAAA,CAAM,IAAM,EAAE,EAAA,KAAO,WAAW,CAChE,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,CAAA,SAAA,EAAY,WAAW,kBAAA,CAAA;IAAA,CAChC,CAAC;IAEH,MAAM,cAAc,UAAM,wMAAA,EAAiB,IAAI;IAC/C,IAAIC,UAA+B,KAAA;IACnC,IACC,eACA,eAAe,YAAY,UAAA,IAAA,CAC1B,CAAC,aAAa,YAAY,EAAA,KAAO,SAAA,EAElC,CAAA,UAAU;SAIV,UAAA,CADC,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,eAAe,EAC5C,IAAA,CAAA,CAAM,MACxB,YACG,IAAI,EAAA,KAAO,aAAa,IAAI,UAAA,KAAe,aAC3C,IAAI,UAAA,KAAe,WACtB;IAGF,IAAI,CAAC,QACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAEH,MAAM,WAAW,IAAI,OAAA,CAAQ,eAAA,CAAgB,IAAA,CAAA,CAC3C,IAAM,EAAE,EAAA,KAAO,WAChB;IACD,IAAI,CAAC,SACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,CAAA,SAAA,EAAY,WAAW,WAAA,CAAA;IAAA,CAChC,CAAC;IAGH,IAAI;QACH,IAAIC,YAAiC;QACrC,MAAM,qBACL,QAAQ,oBAAA,IACR,IAAI,KAAK,QAAQ,oBAAA,CAAqB,CAAC,OAAA,EAAS,GAAG,KAAK,GAAA,EAAK,GAAG;QACjE,IACC,QAAQ,YAAA,IACR,sBACA,SAAS,kBAAA,EACR;YACD,MAAMC,iBAAe,UAAM,6LAAA,EAC1B,QAAQ,YAAA,EACR,IAAI,OAAA,CACJ;YACD,YAAY,MAAM,SAAS,kBAAA,CAAmBA,eAAa;YAC3D,MAAM,cAAc;gBACnB,aAAa,UAAM,wLAAA,EAAa,UAAU,WAAA,EAAa,IAAI,OAAA,CAAQ;gBACnE,sBAAsB,UAAU,oBAAA;gBAChC,cAAc,UAAM,wLAAA,EAAa,UAAU,YAAA,EAAc,IAAI,OAAA,CAAQ;gBACrE,uBAAuB,UAAU,qBAAA;aACjC;YACD,IAAIC,iBAA6C;YACjD,IAAI,QAAQ,EAAA,CACX,CAAA,iBAAiB,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAClD,QAAQ,EAAA,EACR,YACA;YAEF,IAAI,IAAI,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,mBAChC,CAAA,UAAM,wMAAA,EAAiB,KAAK;gBAC3B,GAAG,OAAA;gBACH,GAAI,kBAAkB,WAAA;aACtB,CAAC;;QAIJ,MAAM,uBAAA,CAAA,MAA8B;YACnC,IAAI,WAAW,sBAAsB;gBACpC,IAAI,OAAO,UAAU,oBAAA,KAAyB,SAC7C,CAAA,OAAO,IAAI,KAAK,UAAU,oBAAA,CAAqB;gBAEhD,OAAO,UAAU,oBAAA;;YAElB,IAAI,QAAQ,oBAAA,EAAsB;gBACjC,IAAI,OAAO,QAAQ,oBAAA,KAAyB,SAC3C,CAAA,OAAO,IAAI,KAAK,QAAQ,oBAAA,CAAqB;gBAE9C,OAAO,QAAQ,oBAAA;;YAGb;QAEJ,MAAM,SAAS;YACd,aACC,WAAW,eACV,UAAM,6LAAA,EAAkB,QAAQ,WAAA,IAAe,IAAI,IAAI,OAAA,CAAQ;YACjE;YACA,QAAQ,QAAQ,KAAA,EAAO,MAAM,IAAI,IAAI,EAAE;YACvC,SAAS,WAAW,WAAW,QAAQ,OAAA,IAAW,KAAA;SAClD;QACD,OAAO,IAAI,IAAA,CAAK,OAAO;aACf,OAAO;QACf,MAAM,IAAI,0KAAA,CAAS,eAAe;YACjC,SAAS;YACT,OAAO;SACP,CAAC;;EAGJ;AAED,MAAa,mBAAe,qMAAA,EAC3B,kBACA;IACC,QAAQ;IACR,MAAM,EAAE,qKAAA,CAAO;QACd,YAAY,EAAE,qKAAA,EAAQ,CAAC,IAAA,CAAK;YAC3B,aAAa;QAAA,CACb,CAAC;QACF,WAAW,EACT,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;QACZ,QAAQ,EACN,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;KACZ,CAAC;IACF,UAAU;QACT,SAAS;YACR,aAAa;YACb,WAAW;gBACV,KAAK;oBACJ,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,WAAW;wCACV,MAAM;oCAAA,CACN;oCACD,SAAS;wCACR,MAAM;oCAAA,CACN;oCACD,aAAa;wCACZ,MAAM;oCAAA,CACN;oCACD,cAAc;wCACb,MAAM;oCAAA,CACN;oCACD,sBAAsB;wCACrB,MAAM;wCACN,QAAQ;qCACR;oCACD,uBAAuB;wCACtB,MAAM;wCACN,QAAQ;qCACR;iCACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;gBACD,KAAK;oBACJ,aAAa;gBAAA,CACb;aACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,EAAE,UAAA,EAAY,SAAA,EAAW,MAAA,EAAA,GAAW,IAAI,IAAA;IAC9C,MAAM,MAAM,IAAI,OAAA;IAChB,MAAM,UAAU,UAAM,sMAAA,EAAkB,IAAI;IAC5C,IAAI,OAAO,CAAC,QACX,CAAA,MAAM,IAAI,KAAA,CAAM,eAAe;IAEhC,MAAM,iBAAiB,SAAS,MAAM,MAAM;IAC5C,IAAI,CAAC,eACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,CAAA,oCAAA,CAAA;IAAA,CACT,CAAC;IAEH,MAAM,WAAW,IAAI,OAAA,CAAQ,eAAA,CAAgB,IAAA,CAAA,CAC3C,IAAM,EAAE,EAAA,KAAO,WAChB;IACD,IAAI,CAAC,SACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,CAAA,SAAA,EAAY,WAAW,WAAA,CAAA;IAAA,CAChC,CAAC;IAEH,IAAI,CAAC,SAAS,kBAAA,CACb,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,CAAA,SAAA,EAAY,WAAW,mCAAA,CAAA;IAAA,CAChC,CAAC;IAIH,IAAIH,UAA+B,KAAA;IACnC,MAAM,cAAc,UAAM,wMAAA,EAAiB,IAAI;IAC/C,IACC,eAAA,CACC,CAAC,cAAc,eAAe,aAAa,UAAA,EAE5C,CAAA,UAAU;SAIV,UAAA,CADC,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,eAAe,EAC5C,IAAA,CAAA,CAAM,MACxB,YACG,IAAI,EAAA,KAAO,aAAa,IAAI,UAAA,KAAe,aAC3C,IAAI,UAAA,KAAe,WACtB;IAGF,IAAI,CAAC,QACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAGH,IAAII,iBAA0C,KAAA;IAC9C,IAAI,eAAe,eAAe,YAAY,UAAA,CAC7C,CAAA,iBAAe,YAAY,YAAA,IAAgB,KAAA;SAE3C,iBAAe,QAAQ,YAAA,IAAgB,KAAA;IAGxC,IAAI,CAACF,eACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAGH,IAAI;QACH,MAAM,wBAAwB,UAAM,6LAAA,EACnCA,gBACA,IAAI,OAAA,CACJ;QACD,MAAMG,SAAuB,MAAM,SAAS,kBAAA,CAC3C,sBACA;QAED,IAAI,QAAQ,EAAA,EAAI;YACf,MAAM,aAAa;gBAClB,GAAI,WAAW,CAAA,CAAE;gBACjB,aAAa,UAAM,wLAAA,EAAa,OAAO,WAAA,EAAa,IAAI,OAAA,CAAQ;gBAChE,cAAc,UAAM,wLAAA,EAAa,OAAO,YAAA,EAAc,IAAI,OAAA,CAAQ;gBAClE,sBAAsB,OAAO,oBAAA;gBAC7B,uBAAuB,OAAO,qBAAA;gBAC9B,OAAO,OAAO,MAAA,EAAQ,KAAK,IAAI,IAAI,QAAQ,KAAA;gBAC3C,SAAS,OAAO,OAAA,IAAW,QAAQ,OAAA;aACnC;YACD,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAAc,QAAQ,EAAA,EAAI,WAAW;;QAGxE,IACC,eACA,eAAe,YAAY,UAAA,IAC3B,IAAI,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,mBAW7B,CAAA,UAAM,wMAAA,EAAiB,KATJ;YAClB,GAAG,WAAA;YACH,aAAa,UAAM,wLAAA,EAAa,OAAO,WAAA,EAAa,IAAI,OAAA,CAAQ;YAChE,cAAc,UAAM,wLAAA,EAAa,OAAO,YAAA,EAAc,IAAI,OAAA,CAAQ;YAClE,sBAAsB,OAAO,oBAAA;YAC7B,uBAAuB,OAAO,qBAAA;YAC9B,OAAO,OAAO,MAAA,EAAQ,KAAK,IAAI,IAAI,YAAY,KAAA;YAC/C,SAAS,OAAO,OAAA,IAAW,YAAY,OAAA;SACvC,CACsC;QAExC,OAAO,IAAI,IAAA,CAAK;YACf,aAAa,OAAO,WAAA;YACpB,cAAc,OAAO,YAAA;YACrB,sBAAsB,OAAO,oBAAA;YAC7B,uBAAuB,OAAO,qBAAA;YAC9B,OAAO,OAAO,MAAA,EAAQ,KAAK,IAAI,IAAI,QAAQ,KAAA;YAC3C,SAAS,OAAO,OAAA,IAAW,QAAQ,OAAA;YACnC,YAAY,QAAQ,UAAA;YACpB,WAAW,QAAQ,SAAA;SACnB,CAAC;aACM,OAAO;QACf,MAAM,IAAI,0KAAA,CAAS,eAAe;YACjC,SAAS;YACT,OAAO;SACP,CAAC;;EAGJ;AAED,MAAM,yBAAyB,EAAE,uKAAA,CAChC,EAAE,qKAAA,CAAO;IACR,WAAW,EACT,qKAAA,EAAQ,CACR,IAAA,CAAK;QACL,aACC;IAAA,CACD,CAAC,CACD,QAAA,EAAU;AAAA,CACZ,CAAC,CACF;AAED,MAAa,kBAAc,qMAAA,EAC1B,iBACA;IACC,QAAQ;IACR,KAAK;QAAC,sMAAA;KAAkB;IACxB,UAAU;QACT,SAAS;YACR,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,MAAM;wCACL,MAAM;wCACN,YAAY;4CACX,IAAI;gDACH,MAAM;4CAAA,CACN;4CACD,MAAM;gDACL,MAAM;4CAAA,CACN;4CACD,OAAO;gDACN,MAAM;4CAAA,CACN;4CACD,OAAO;gDACN,MAAM;4CAAA,CACN;4CACD,eAAe;gDACd,MAAM;4CAAA,CACN;yCACD;wCACD,UAAU;4CAAC;4CAAM;yCAAgB;qCACjC;oCACD,MAAM;wCACL,MAAM;wCACN,YAAY,CAAA,CAAE;wCACd,sBAAsB;qCACtB;iCACD;gCACD,UAAU;oCAAC;oCAAQ;iCAAO;gCAC1B,sBAAsB;6BACtB;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;IACD,OAAO;CACP,EACD,OAAO,QAAQ;IACd,MAAM,oBAAoB,IAAI,KAAA,EAAO;IACrC,IAAIL,UAA+B,KAAA;IACnC,IAAI,CAAC,mBACJ;YAAI,IAAI,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,oBAAoB;YACpD,MAAM,cAAc,UAAM,wMAAA,EAAiB,IAAI;YAC/C,IAAI,YACH,CAAA,UAAU;;WAGN;QACN,MAAM,cACL,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,WAAA,CAAY,kBAAkB;QACjE,IAAI,YACH,CAAA,UAAU;;IAIZ,IAAI,CAAC,WAAW,QAAQ,MAAA,KAAW,IAAI,OAAA,CAAQ,OAAA,CAAQ,IAAA,CAAK,EAAA,CAC3D,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAGH,MAAM,WAAW,IAAI,OAAA,CAAQ,eAAA,CAAgB,IAAA,CAAA,CAC3C,IAAM,EAAE,EAAA,KAAO,QAAQ,UAAA,CACxB;IAED,IAAI,CAAC,SACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,yBAAyB;QAC3C,SAAS,CAAA,6BAAA,EAAgC,QAAQ,UAAA,CAAW,yBAAA,CAAA;IAAA,CAC5D,CAAC;IAEH,MAAM,SAAS,MAAM,eAAe;QACnC,GAAG,GAAA;QACH,QAAQ;QACR,MAAM;YACL,WAAW,QAAQ,EAAA;YACnB,YAAY,QAAQ,UAAA;SACpB;QACD,eAAe;QACf,cAAc;KACd,CAAC;IACF,IAAI,CAAC,OAAO,WAAA,CACX,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAEH,MAAM,OAAO,MAAM,SAAS,WAAA,CAAY;QACvC,GAAG,MAAA;QACH,aAAa,OAAO,WAAA;KACpB,CAAC;IACF,OAAO,IAAI,IAAA,CAAK,KAAK;EAEtB"}},
    {"offset": {"line": 5031, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/email-verification.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/email-verification.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport type { JWTPayload, JWTVerifyResult } from \"jose\";\nimport { jwtVerify } from \"jose\";\nimport { JWTExpired } from \"jose/errors\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { signJWT } from \"../../crypto/jwt\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport type { User } from \"../../types\";\nimport { originCheck } from \"../middlewares\";\nimport { getSessionFromCtx } from \"./session\";\n\nexport async function createEmailVerificationToken(\n\tsecret: string,\n\temail: string,\n\t/**\n\t * The email to update from\n\t */\n\tupdateTo?: string | undefined,\n\t/**\n\t * The time in seconds for the token to expire\n\t */\n\texpiresIn: number = 3600,\n\t/**\n\t * Extra payload to include in the token\n\t */\n\textraPayload?: Record<string, any>,\n) {\n\tconst token = await signJWT(\n\t\t{\n\t\t\temail: email.toLowerCase(),\n\t\t\tupdateTo,\n\t\t\t...extraPayload,\n\t\t},\n\t\tsecret,\n\t\texpiresIn,\n\t);\n\treturn token;\n}\n\n/**\n * A function to send a verification email to the user\n */\nexport async function sendVerificationEmailFn(\n\tctx: GenericEndpointContext,\n\tuser: User,\n) {\n\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t});\n\t}\n\tconst token = await createEmailVerificationToken(\n\t\tctx.context.secret,\n\t\tuser.email,\n\t\tundefined,\n\t\tctx.context.options.emailVerification?.expiresIn,\n\t);\n\tconst callbackURL = ctx.body.callbackURL\n\t\t? encodeURIComponent(ctx.body.callbackURL)\n\t\t: encodeURIComponent(\"/\");\n\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\tawait ctx.context.runInBackgroundOrAwait(\n\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t{\n\t\t\t\tuser: user,\n\t\t\t\turl,\n\t\t\t\ttoken,\n\t\t\t},\n\t\t\tctx.request,\n\t\t),\n\t);\n}\nexport const sendVerificationEmail = createAuthEndpoint(\n\t\"/send-verification-email\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"sendVerificationEmail\",\n\t\tbody: z.object({\n\t\t\temail: z.email().meta({\n\t\t\t\tdescription: \"The email to send the verification email to\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to use for email verification callback\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"sendVerificationEmail\",\n\t\t\t\tdescription: \"Send a verification email to the user\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The email to send the verification email to\",\n\t\t\t\t\t\t\t\t\t\texample: \"user@example.com\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The URL to use for email verification callback\",\n\t\t\t\t\t\t\t\t\t\texample: \"https://example.com/callback\",\n\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\trequired: [\"email\"],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the email was sent successfully\",\n\t\t\t\t\t\t\t\t\t\t\texample: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"400\": {\n\t\t\t\t\t\tdescription: \"Bad Request\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Error message\",\n\t\t\t\t\t\t\t\t\t\t\texample: \"Verification email isn't enabled\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t\t});\n\t\t}\n\t\tconst { email } = ctx.body;\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session) {\n\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\tif (!user) {\n\t\t\t\tawait createEmailVerificationToken(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\temail,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\t//we're returning true to avoid leaking information about the user\n\t\t\t\treturn ctx.json({\n\t\t\t\t\tstatus: true,\n\t\t\t\t});\n\t\t\t}\n\t\t\tawait sendVerificationEmailFn(ctx, user.user);\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\t\tif (session?.user.email !== email) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_MISMATCH,\n\t\t\t});\n\t\t}\n\t\tif (session?.user.emailVerified) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_ALREADY_VERIFIED,\n\t\t\t});\n\t\t}\n\t\tawait sendVerificationEmailFn(ctx, session.user);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const verifyEmail = createAuthEndpoint(\n\t\"/verify-email\",\n\t{\n\t\tmethod: \"GET\",\n\t\toperationId: \"verifyEmail\",\n\t\tquery: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to verify the email\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Verify the email of the user\",\n\t\t\t\tparameters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"token\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\tdescription: \"The token to verify the email\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"callbackURL\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t\t\trequired: false,\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"Indicates if the email was verified successfully\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\", \"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tfunction redirectOnError(error: string) {\n\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\tif (ctx.query.callbackURL.includes(\"?\")) {\n\t\t\t\t\tthrow ctx.redirect(`${ctx.query.callbackURL}&error=${error}`);\n\t\t\t\t}\n\t\t\t\tthrow ctx.redirect(`${ctx.query.callbackURL}?error=${error}`);\n\t\t\t}\n\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\tmessage: error,\n\t\t\t});\n\t\t}\n\t\tconst { token } = ctx.query;\n\t\tlet jwt: JWTVerifyResult<JWTPayload>;\n\t\ttry {\n\t\t\tjwt = await jwtVerify(\n\t\t\t\ttoken,\n\t\t\t\tnew TextEncoder().encode(ctx.context.secret),\n\t\t\t\t{\n\t\t\t\t\talgorithms: [\"HS256\"],\n\t\t\t\t},\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tif (e instanceof JWTExpired) {\n\t\t\t\treturn redirectOnError(\"token_expired\");\n\t\t\t}\n\t\t\treturn redirectOnError(\"invalid_token\");\n\t\t}\n\t\tconst schema = z.object({\n\t\t\temail: z.email(),\n\t\t\tupdateTo: z.string().optional(),\n\t\t\trequestType: z.string().optional(),\n\t\t});\n\t\tconst parsed = schema.parse(jwt.payload);\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(\n\t\t\tparsed.email,\n\t\t);\n\t\tif (!user) {\n\t\t\treturn redirectOnError(\"user_not_found\");\n\t\t}\n\t\tif (parsed.updateTo) {\n\t\t\tconst session = await getSessionFromCtx(ctx);\n\t\t\tif (session && session.user.email !== parsed.email) {\n\t\t\t\treturn redirectOnError(\"unauthorized\");\n\t\t\t}\n\t\t\tswitch (parsed.requestType) {\n\t\t\t\t/**\n\t\t\t\t * User clicks confirmation -> sends verification to new email\n\t\t\t\t */\n\t\t\t\tcase \"change-email-confirmation\": {\n\t\t\t\t\tconst newToken = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tparsed.email,\n\t\t\t\t\t\tparsed.updateTo,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t\t{ requestType: \"change-email-verification\" },\n\t\t\t\t\t);\n\t\t\t\t\tconst updateCallbackURL = ctx.query.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.query.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`;\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: { ...user.user, email: parsed.updateTo },\n\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\ttoken: newToken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({ status: true });\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * User clicks verification -> updates email\n\t\t\t\t */\n\t\t\t\tcase \"change-email-verification\": {\n\t\t\t\t\tlet activeSession = session;\n\t\t\t\t\tif (!activeSession) {\n\t\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\t\t\tuser.user.id,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!newSession) {\n\t\t\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tactiveSession = {\n\t\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.context.options.emailVerification?.onEmailVerification) {\n\t\t\t\t\t\tawait ctx.context.options.emailVerification.onEmailVerification(\n\t\t\t\t\t\t\tuser.user,\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst updatedUser =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\t});\n\t\t\t\t\tif (ctx.context.options.emailVerification?.afterEmailVerification) {\n\t\t\t\t\t\tawait ctx.context.options.emailVerification.afterEmailVerification(\n\t\t\t\t\t\t\tupdatedUser,\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: activeSession.session,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t...activeSession.user,\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tuser: parseUserOutput(ctx.context.options, updatedUser),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * Legacy flow\n\t\t\t\t *\n\t\t\t\t * - skips two-step verification\n\t\t\t\t * - updates email immediately\n\t\t\t\t */\n\t\t\t\tdefault: {\n\t\t\t\t\tlet activeSession = session;\n\t\t\t\t\tif (!activeSession) {\n\t\t\t\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\t\t\tuser.user.id,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!newSession) {\n\t\t\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tactiveSession = {\n\t\t\t\t\t\t\tsession: newSession,\n\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tconst updatedUser =\n\t\t\t\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(parsed.email, {\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t});\n\t\t\t\t\tconst newToken = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tparsed.updateTo,\n\t\t\t\t\t);\n\t\t\t\t\tconst updateCallbackURL = ctx.query.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.query.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: updatedUser,\n\t\t\t\t\t\t\t\t\turl: `${ctx.context.baseURL}/verify-email?token=${newToken}&callbackURL=${updateCallbackURL}`,\n\t\t\t\t\t\t\t\t\ttoken: newToken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\t\tsession: activeSession.session,\n\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t...activeSession.user,\n\t\t\t\t\t\t\temail: parsed.updateTo,\n\t\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tuser: parseUserOutput(ctx.context.options, updatedUser),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (user.user.emailVerified) {\n\t\t\tif (ctx.query.callbackURL) {\n\t\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t\tuser: null,\n\t\t\t});\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.beforeEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.beforeEmailVerification(\n\t\t\t\tuser.user,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.onEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.onEmailVerification(\n\t\t\t\tuser.user,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tconst updatedUser = await ctx.context.internalAdapter.updateUserByEmail(\n\t\t\tparsed.email,\n\t\t\t{\n\t\t\t\temailVerified: true,\n\t\t\t},\n\t\t);\n\t\tif (ctx.context.options.emailVerification?.afterEmailVerification) {\n\t\t\tawait ctx.context.options.emailVerification.afterEmailVerification(\n\t\t\t\tupdatedUser,\n\t\t\t\tctx.request,\n\t\t\t);\n\t\t}\n\t\tif (ctx.context.options.emailVerification?.autoSignInAfterVerification) {\n\t\t\tconst currentSession = await getSessionFromCtx(ctx);\n\t\t\tif (!currentSession || currentSession.user.email !== parsed.email) {\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\tuser.user.id,\n\t\t\t\t);\n\t\t\t\tif (!session) {\n\t\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\t\tmessage: \"Failed to create session\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...user.user,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\t\tsession: currentSession.session,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...currentSession.user,\n\t\t\t\t\t\temailVerified: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.query.callbackURL) {\n\t\t\tthrow ctx.redirect(ctx.query.callbackURL);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tuser: null,\n\t\t});\n\t},\n);\n"],"names":["jwt: JWTVerifyResult<JWTPayload>","updatedUser"],"mappings":"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"}},
    {"offset": {"line": 5442, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/oauth2/link-account.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/oauth2/link-account.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { isDevelopment, logger } from \"@better-auth/core/env\";\nimport { APIError, createEmailVerificationToken } from \"../api\";\nimport { setAccountCookie } from \"../cookies/session-store\";\nimport type { Account, User } from \"../types\";\nimport { setTokenUtil } from \"./utils\";\n\nexport async function handleOAuthUserInfo(\n\tc: GenericEndpointContext,\n\topts: {\n\t\tuserInfo: Omit<User, \"createdAt\" | \"updatedAt\">;\n\t\taccount: Omit<Account, \"id\" | \"userId\" | \"createdAt\" | \"updatedAt\">;\n\t\tcallbackURL?: string | undefined;\n\t\tdisableSignUp?: boolean | undefined;\n\t\toverrideUserInfo?: boolean | undefined;\n\t\tisTrustedProvider?: boolean | undefined;\n\t},\n) {\n\tconst { userInfo, account, callbackURL, disableSignUp, overrideUserInfo } =\n\t\topts;\n\tconst dbUser = await c.context.internalAdapter\n\t\t.findOAuthUser(\n\t\t\tuserInfo.email.toLowerCase(),\n\t\t\taccount.accountId,\n\t\t\taccount.providerId,\n\t\t)\n\t\t.catch((e) => {\n\t\t\tlogger.error(\n\t\t\t\t\"Better auth was unable to query your database.\\nError: \",\n\t\t\t\te,\n\t\t\t);\n\t\t\tconst errorURL =\n\t\t\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\t\t\tthrow c.redirect(`${errorURL}?error=internal_server_error`);\n\t\t});\n\tlet user = dbUser?.user;\n\tconst isRegister = !user;\n\n\tif (dbUser) {\n\t\tconst linkedAccount =\n\t\t\tdbUser.linkedAccount ??\n\t\t\tdbUser.accounts.find(\n\t\t\t\t(acc) =>\n\t\t\t\t\tacc.providerId === account.providerId &&\n\t\t\t\t\tacc.accountId === account.accountId,\n\t\t\t);\n\t\tif (!linkedAccount) {\n\t\t\tconst accountLinking = c.context.options.account?.accountLinking;\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\t\t\tconst isTrustedProvider =\n\t\t\t\topts.isTrustedProvider ||\n\t\t\t\ttrustedProviders?.includes(account.providerId);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !userInfo.emailVerified) ||\n\t\t\t\taccountLinking?.enabled === false ||\n\t\t\t\taccountLinking?.disableImplicitLinking === true\n\t\t\t) {\n\t\t\t\tif (isDevelopment()) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`User already exist but account isn't linked to ${account.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\terror: \"account not linked\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait c.context.internalAdapter.linkAccount({\n\t\t\t\t\tproviderId: account.providerId,\n\t\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t\t\tuserId: dbUser.user.id,\n\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\tscope: account.scope,\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Unable to link account\", e);\n\t\t\t\treturn {\n\t\t\t\t\terror: \"unable to link account\",\n\t\t\t\t\tdata: null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst freshTokens =\n\t\t\t\tc.context.options.account?.updateAccountOnSignIn !== false\n\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries({\n\t\t\t\t\t\t\t\tidToken: account.idToken,\n\t\t\t\t\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\t\t\t\t\trefreshToken: await setTokenUtil(\n\t\t\t\t\t\t\t\t\taccount.refreshToken,\n\t\t\t\t\t\t\t\t\tc.context,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\t\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\t\t\t\t\tscope: account.scope,\n\t\t\t\t\t\t\t}).filter(([_, value]) => value !== undefined),\n\t\t\t\t\t\t)\n\t\t\t\t\t: {};\n\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, {\n\t\t\t\t\t...linkedAccount,\n\t\t\t\t\t...freshTokens,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (Object.keys(freshTokens).length > 0) {\n\t\t\t\tawait c.context.internalAdapter.updateAccount(\n\t\t\t\t\tlinkedAccount.id,\n\t\t\t\t\tfreshTokens,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.emailVerified &&\n\t\t\t\t!dbUser.user.emailVerified &&\n\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t) {\n\t\t\t\tawait c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t\temailVerified: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (overrideUserInfo) {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\t// update user info from the provider if overrideUserInfo is true\n\t\t\tuser = await c.context.internalAdapter.updateUser(dbUser.user.id, {\n\t\t\t\t...restUserInfo,\n\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\temailVerified:\n\t\t\t\t\tuserInfo.email.toLowerCase() === dbUser.user.email\n\t\t\t\t\t\t? dbUser.user.emailVerified || userInfo.emailVerified\n\t\t\t\t\t\t: userInfo.emailVerified,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tif (disableSignUp) {\n\t\t\treturn {\n\t\t\t\terror: \"signup disabled\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t\ttry {\n\t\t\tconst { id: _, ...restUserInfo } = userInfo;\n\t\t\tconst accountData = {\n\t\t\t\taccessToken: await setTokenUtil(account.accessToken, c.context),\n\t\t\t\trefreshToken: await setTokenUtil(account.refreshToken, c.context),\n\t\t\t\tidToken: account.idToken,\n\t\t\t\taccessTokenExpiresAt: account.accessTokenExpiresAt,\n\t\t\t\trefreshTokenExpiresAt: account.refreshTokenExpiresAt,\n\t\t\t\tscope: account.scope,\n\t\t\t\tproviderId: account.providerId,\n\t\t\t\taccountId: userInfo.id.toString(),\n\t\t\t};\n\t\t\tconst { user: createdUser, account: createdAccount } =\n\t\t\t\tawait c.context.internalAdapter.createOAuthUser(\n\t\t\t\t\t{\n\t\t\t\t\t\t...restUserInfo,\n\t\t\t\t\t\temail: userInfo.email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t\taccountData,\n\t\t\t\t);\n\t\t\tuser = createdUser;\n\t\t\tif (c.context.options.account?.storeAccountCookie) {\n\t\t\t\tawait setAccountCookie(c, createdAccount);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!userInfo.emailVerified &&\n\t\t\t\tuser &&\n\t\t\t\tc.context.options.emailVerification?.sendOnSignUp &&\n\t\t\t\tc.context.options.emailVerification?.sendVerificationEmail\n\t\t\t) {\n\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\tc.context.secret,\n\t\t\t\t\tuser.email,\n\t\t\t\t\tundefined,\n\t\t\t\t\tc.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\tconst url = `${c.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\tawait c.context.runInBackgroundOrAwait(\n\t\t\t\t\tc.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tc.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t} catch (e: any) {\n\t\t\tlogger.error(e);\n\t\t\tif (e instanceof APIError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: e.message,\n\t\t\t\t\tdata: null,\n\t\t\t\t\tisRegister: false,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\terror: \"unable to create user\",\n\t\t\t\tdata: null,\n\t\t\t\tisRegister: false,\n\t\t\t};\n\t\t}\n\t}\n\tif (!user) {\n\t\treturn {\n\t\t\terror: \"unable to create user\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\tconst session = await c.context.internalAdapter.createSession(user.id);\n\tif (!session) {\n\t\treturn {\n\t\t\terror: \"unable to create session\",\n\t\t\tdata: null,\n\t\t\tisRegister: false,\n\t\t};\n\t}\n\n\treturn {\n\t\tdata: {\n\t\t\tsession,\n\t\t\tuser,\n\t\t},\n\t\terror: null,\n\t\tisRegister,\n\t};\n}\n"],"names":["e: any"],"mappings":"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"}},
    {"offset": {"line": 5602, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/callback.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/callback.ts"],"sourcesContent":["import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport type { OAuth2Tokens } from \"@better-auth/core/oauth2\";\nimport { safeJSONParse } from \"@better-auth/core/utils\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { handleOAuthUserInfo } from \"../../oauth2/link-account\";\nimport { parseState } from \"../../oauth2/state\";\nimport { setTokenUtil } from \"../../oauth2/utils\";\nimport { HIDE_METADATA } from \"../../utils/hide-metadata\";\n\nconst schema = z.object({\n\tcode: z.string().optional(),\n\terror: z.string().optional(),\n\tdevice_id: z.string().optional(),\n\terror_description: z.string().optional(),\n\tstate: z.string().optional(),\n\tuser: z.string().optional(),\n});\n\nexport const callbackOAuth = createAuthEndpoint(\n\t\"/callback/:id\",\n\t{\n\t\tmethod: [\"GET\", \"POST\"],\n\t\toperationId: \"handleOAuthCallback\",\n\t\tbody: schema.optional(),\n\t\tquery: schema.optional(),\n\t\tmetadata: {\n\t\t\t...HIDE_METADATA,\n\t\t\tallowedMediaTypes: [\n\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\"application/json\",\n\t\t\t],\n\t\t},\n\t},\n\tasync (c) => {\n\t\tlet queryOrBody: z.infer<typeof schema>;\n\t\tconst defaultErrorURL =\n\t\t\tc.context.options.onAPIError?.errorURL || `${c.context.baseURL}/error`;\n\n\t\t// Handle POST requests by redirecting to GET to ensure cookies are sent\n\t\tif (c.method === \"POST\") {\n\t\t\tconst postData = c.body ? schema.parse(c.body) : {};\n\t\t\tconst queryData = c.query ? schema.parse(c.query) : {};\n\n\t\t\tconst mergedData = schema.parse({ ...postData, ...queryData });\n\t\t\tconst params = new URLSearchParams();\n\n\t\t\tfor (const [key, value] of Object.entries(mergedData)) {\n\t\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\t\tparams.set(key, String(value));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst redirectURL = `${c.context.baseURL}/callback/${c.params.id}?${params.toString()}`;\n\t\t\tthrow c.redirect(redirectURL);\n\t\t}\n\n\t\ttry {\n\t\t\tif (c.method === \"GET\") {\n\t\t\t\tqueryOrBody = schema.parse(c.query);\n\t\t\t} else if (c.method === \"POST\") {\n\t\t\t\tqueryOrBody = schema.parse(c.body);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unsupported method\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tc.context.logger.error(\"INVALID_CALLBACK_REQUEST\", e);\n\t\t\tthrow c.redirect(`${defaultErrorURL}?error=invalid_callback_request`);\n\t\t}\n\n\t\tconst {\n\t\t\tcode,\n\t\t\terror,\n\t\t\tstate,\n\t\t\terror_description,\n\t\t\tdevice_id,\n\t\t\tuser: userData,\n\t\t} = queryOrBody;\n\n\t\tif (!state) {\n\t\t\tc.context.logger.error(\"State not found\", error);\n\t\t\tconst sep = defaultErrorURL.includes(\"?\") ? \"&\" : \"?\";\n\t\t\tconst url = `${defaultErrorURL}${sep}state=state_not_found`;\n\t\t\tthrow c.redirect(url);\n\t\t}\n\n\t\tconst {\n\t\t\tcodeVerifier,\n\t\t\tcallbackURL,\n\t\t\tlink,\n\t\t\terrorURL,\n\t\t\tnewUserURL,\n\t\t\trequestSignUp,\n\t\t} = await parseState(c);\n\n\t\tfunction redirectOnError(error: string, description?: string | undefined) {\n\t\t\tconst baseURL = errorURL ?? defaultErrorURL;\n\n\t\t\tconst params = new URLSearchParams({ error });\n\t\t\tif (description) params.set(\"error_description\", description);\n\n\t\t\tconst sep = baseURL.includes(\"?\") ? \"&\" : \"?\";\n\t\t\tconst url = `${baseURL}${sep}${params.toString()}`;\n\n\t\t\tthrow c.redirect(url);\n\t\t}\n\n\t\tif (error) {\n\t\t\tredirectOnError(error, error_description);\n\t\t}\n\n\t\tif (!code) {\n\t\t\tc.context.logger.error(\"Code not found\");\n\t\t\tthrow redirectOnError(\"no_code\");\n\t\t}\n\t\tconst provider = c.context.socialProviders.find(\n\t\t\t(p) => p.id === c.params.id,\n\t\t);\n\n\t\tif (!provider) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Oauth provider with id\",\n\t\t\t\tc.params.id,\n\t\t\t\t\"not found\",\n\t\t\t);\n\t\t\tthrow redirectOnError(\"oauth_provider_not_found\");\n\t\t}\n\n\t\tlet tokens: OAuth2Tokens | null;\n\t\ttry {\n\t\t\ttokens = await provider.validateAuthorizationCode({\n\t\t\t\tcode: code,\n\t\t\t\tcodeVerifier,\n\t\t\t\tdeviceId: device_id,\n\t\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tc.context.logger.error(\"\", e);\n\t\t\tthrow redirectOnError(\"invalid_code\");\n\t\t}\n\t\tif (!tokens) {\n\t\t\tthrow redirectOnError(\"invalid_code\");\n\t\t}\n\t\tconst parsedUserData = userData\n\t\t\t? safeJSONParse<{\n\t\t\t\t\tname?: {\n\t\t\t\t\t\tfirstName?: string;\n\t\t\t\t\t\tlastName?: string;\n\t\t\t\t\t};\n\t\t\t\t\temail?: string;\n\t\t\t\t}>(userData)\n\t\t\t: null;\n\n\t\tconst userInfo = await provider\n\t\t\t.getUserInfo({\n\t\t\t\t...tokens,\n\t\t\t\t/**\n\t\t\t\t * The user object from the provider\n\t\t\t\t * This is only available for some providers like Apple\n\t\t\t\t */\n\t\t\t\tuser: parsedUserData ?? undefined,\n\t\t\t})\n\t\t\t.then((res) => res?.user);\n\n\t\tif (!userInfo) {\n\t\t\tc.context.logger.error(\"Unable to get user info\");\n\t\t\treturn redirectOnError(\"unable_to_get_user_info\");\n\t\t}\n\n\t\tif (!callbackURL) {\n\t\t\tc.context.logger.error(\"No callback URL found\");\n\t\t\tthrow redirectOnError(\"no_callback_url\");\n\t\t}\n\n\t\tif (link) {\n\t\t\tconst trustedProviders =\n\t\t\t\tc.context.options.account?.accountLinking?.trustedProviders;\n\t\t\tconst isTrustedProvider = trustedProviders?.includes(provider.id);\n\t\t\tif (\n\t\t\t\t(!isTrustedProvider && !userInfo.emailVerified) ||\n\t\t\t\tc.context.options.account?.accountLinking?.enabled === false\n\t\t\t) {\n\t\t\t\tc.context.logger.error(\"Unable to link account - untrusted provider\");\n\t\t\t\treturn redirectOnError(\"unable_to_link_account\");\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tuserInfo.email !== link.email &&\n\t\t\t\tc.context.options.account?.accountLinking?.allowDifferentEmails !== true\n\t\t\t) {\n\t\t\t\treturn redirectOnError(\"email_doesn't_match\");\n\t\t\t}\n\n\t\t\tconst existingAccount = await c.context.internalAdapter.findAccount(\n\t\t\t\tString(userInfo.id),\n\t\t\t);\n\n\t\t\tif (existingAccount) {\n\t\t\t\tif (existingAccount.userId.toString() !== link.userId.toString()) {\n\t\t\t\t\treturn redirectOnError(\"account_already_linked_to_different_user\");\n\t\t\t\t}\n\t\t\t\tconst updateData = Object.fromEntries(\n\t\t\t\t\tObject.entries({\n\t\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\t\t\t\tidToken: tokens.idToken,\n\t\t\t\t\t\taccessTokenExpiresAt: tokens.accessTokenExpiresAt,\n\t\t\t\t\t\trefreshTokenExpiresAt: tokens.refreshTokenExpiresAt,\n\t\t\t\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t\t\t\t}).filter(([_, value]) => value !== undefined),\n\t\t\t\t);\n\t\t\t\tawait c.context.internalAdapter.updateAccount(\n\t\t\t\t\texistingAccount.id,\n\t\t\t\t\tupdateData,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst newAccount = await c.context.internalAdapter.createAccount({\n\t\t\t\t\tuserId: link.userId,\n\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\taccountId: String(userInfo.id),\n\t\t\t\t\t...tokens,\n\t\t\t\t\taccessToken: await setTokenUtil(tokens.accessToken, c.context),\n\t\t\t\t\trefreshToken: await setTokenUtil(tokens.refreshToken, c.context),\n\t\t\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t\t\t});\n\t\t\t\tif (!newAccount) {\n\t\t\t\t\treturn redirectOnError(\"unable_to_link_account\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet toRedirectTo: string;\n\t\t\ttry {\n\t\t\t\tconst url = callbackURL;\n\t\t\t\ttoRedirectTo = url.toString();\n\t\t\t} catch {\n\t\t\t\ttoRedirectTo = callbackURL;\n\t\t\t}\n\t\t\tthrow c.redirect(toRedirectTo);\n\t\t}\n\n\t\tif (!userInfo.email) {\n\t\t\tc.context.logger.error(\n\t\t\t\t\"Provider did not return email. This could be due to misconfiguration in the provider settings.\",\n\t\t\t);\n\t\t\treturn redirectOnError(\"email_not_found\");\n\t\t}\n\t\tconst accountData = {\n\t\t\tproviderId: provider.id,\n\t\t\taccountId: String(userInfo.id),\n\t\t\t...tokens,\n\t\t\tscope: tokens.scopes?.join(\",\"),\n\t\t};\n\t\tconst result = await handleOAuthUserInfo(c, {\n\t\t\tuserInfo: {\n\t\t\t\t...userInfo,\n\t\t\t\tid: String(userInfo.id),\n\t\t\t\temail: userInfo.email,\n\t\t\t\tname: userInfo.name || userInfo.email,\n\t\t\t},\n\t\t\taccount: accountData,\n\t\t\tcallbackURL,\n\t\t\tdisableSignUp:\n\t\t\t\t(provider.disableImplicitSignUp && !requestSignUp) ||\n\t\t\t\tprovider.options?.disableSignUp,\n\t\t\toverrideUserInfo: provider.options?.overrideUserInfoOnSignIn,\n\t\t});\n\t\tif (result.error) {\n\t\t\tc.context.logger.error(result.error.split(\" \").join(\"_\"));\n\t\t\treturn redirectOnError(result.error.split(\" \").join(\"_\"));\n\t\t}\n\t\tconst { session, user } = result.data!;\n\t\tawait setSessionCookie(c, {\n\t\t\tsession,\n\t\t\tuser,\n\t\t});\n\n\t\tlet toRedirectTo: string;\n\t\ttry {\n\t\t\tconst url = result.isRegister ? newUserURL || callbackURL : callbackURL;\n\t\t\ttoRedirectTo = url.toString();\n\t\t} catch {\n\t\t\ttoRedirectTo = result.isRegister\n\t\t\t\t? newUserURL || callbackURL\n\t\t\t\t: callbackURL;\n\t\t}\n\t\tthrow c.redirect(toRedirectTo);\n\t},\n);\n"],"names":["queryOrBody: z.infer<typeof schema>","tokens: OAuth2Tokens | null","toRedirectTo: string","toRedirectTo"],"mappings":"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"}},
    {"offset": {"line": 5802, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/error.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/error.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { isProduction } from \"@better-auth/core/env\";\nimport { HIDE_METADATA } from \"../../utils/hide-metadata\";\n\nfunction sanitize(input: string): string {\n\t// Replace & last to avoid double-encoding existing HTML entities\n\t// Match & only when it's not already part of an HTML entity\n\treturn input\n\t\t.replace(/</g, \"&lt;\")\n\t\t.replace(/>/g, \"&gt;\")\n\t\t.replace(/\"/g, \"&quot;\")\n\t\t.replace(/'/g, \"&#39;\")\n\t\t.replace(/&(?!amp;|lt;|gt;|quot;|#39;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, \"&amp;\");\n}\n\nconst html = (\n\toptions: BetterAuthOptions,\n\tcode: string = \"Unknown\",\n\tdescription: string | null = null,\n) => {\n\tconst custom = options.onAPIError?.customizeDefaultErrorPage;\n\treturn `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Error</title>\n    <style>\n      * {\n        box-sizing: border-box;\n      }\n      body {\n        font-family: ${custom?.font?.defaultFamily || \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif\"};\n        background: ${custom?.colors?.background || \"var(--background)\"};\n        color: var(--foreground);\n        margin: 0;\n      }\n      :root,\n      :host {\n        --spacing: 0.25rem;\n        --container-md: 28rem;\n        --text-sm: ${custom?.size?.textSm || \"0.875rem\"};\n        --text-sm--line-height: calc(1.25 / 0.875);\n        --text-2xl: ${custom?.size?.text2xl || \"1.5rem\"};\n        --text-2xl--line-height: calc(2 / 1.5);\n        --text-4xl: ${custom?.size?.text4xl || \"2.25rem\"};\n        --text-4xl--line-height: calc(2.5 / 2.25);\n        --text-6xl: ${custom?.size?.text6xl || \"3rem\"};\n        --text-6xl--line-height: 1;\n        --font-weight-medium: 500;\n        --font-weight-semibold: 600;\n        --font-weight-bold: 700;\n        --default-transition-duration: 150ms;\n        --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n        --radius: ${custom?.size?.radiusSm || \"0.625rem\"};\n        --default-mono-font-family: ${custom?.font?.monoFamily || \"var(--font-geist-mono)\"};\n        --primary: ${custom?.colors?.primary || \"black\"};\n        --primary-foreground: ${custom?.colors?.primaryForeground || \"white\"};\n        --background: ${custom?.colors?.background || \"white\"};\n        --foreground: ${custom?.colors?.foreground || \"oklch(0.271 0 0)\"};\n        --border: ${custom?.colors?.border || \"oklch(0.89 0 0)\"};\n        --destructive: ${custom?.colors?.destructive || \"oklch(0.55 0.15 25.723)\"};\n        --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.545 0 0)\"};\n        --corner-border: ${custom?.colors?.cornerBorder || \"#404040\"};\n      }\n\n      button, .btn {\n        cursor: pointer;\n        background: none;\n        border: none;\n        color: inherit;\n        font: inherit;\n        transition: all var(--default-transition-duration)\n          var(--default-transition-timing-function);\n      }\n      button:hover, .btn:hover {\n        opacity: 0.8;\n      }\n\n      @media (prefers-color-scheme: dark) {\n        :root,\n        :host {\n          --primary: ${custom?.colors?.primary || \"white\"};\n          --primary-foreground: ${custom?.colors?.primaryForeground || \"black\"};\n          --background: ${custom?.colors?.background || \"oklch(0.15 0 0)\"};\n          --foreground: ${custom?.colors?.foreground || \"oklch(0.98 0 0)\"};\n          --border: ${custom?.colors?.border || \"oklch(0.27 0 0)\"};\n          --destructive: ${custom?.colors?.destructive || \"oklch(0.65 0.15 25.723)\"};\n          --muted-foreground: ${custom?.colors?.mutedForeground || \"oklch(0.65 0 0)\"};\n          --corner-border: ${custom?.colors?.cornerBorder || \"#a0a0a0\"};\n        }\n      }\n      @media (max-width: 640px) {\n        :root, :host {\n          --text-6xl: 2.5rem;\n          --text-2xl: 1.25rem;\n          --text-sm: 0.8125rem;\n        }\n      }\n      @media (max-width: 480px) {\n        :root, :host {\n          --text-6xl: 2rem;\n          --text-2xl: 1.125rem;\n        }\n      }\n    </style>\n  </head>\n  <body style=\"width: 100vw; min-height: 100vh; overflow-x: hidden; overflow-y: auto;\">\n    <div\n        style=\"\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            gap: 1.5rem;\n            position: relative;\n            width: 100%;\n            min-height: 100vh;\n            padding: 1rem;\n        \"\n        >\n${\n\tcustom?.disableBackgroundGrid\n\t\t? \"\"\n\t\t: `\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          background-image: linear-gradient(to right, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px),\n            linear-gradient(to bottom, ${custom?.colors?.gridColor || \"var(--border)\"} 1px, transparent 1px);\n          background-size: 40px 40px;\n          opacity: 0.6;\n          pointer-events: none;\n          width: 100vw;\n          height: 100vh;\n        \"\n      ></div>\n      <div\n        style=\"\n          position: absolute;\n          inset: 0;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          background: ${custom?.colors?.background || \"var(--background)\"};\n          mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          -webkit-mask-image: radial-gradient(ellipse at center, transparent 20%, black);\n          pointer-events: none;\n        \"\n      ></div>\n`\n}\n\n<div\n  style=\"\n    position: relative;\n    z-index: 10;\n    border: 2px solid var(--border);\n    background: ${custom?.colors?.cardBackground || \"var(--background)\"};\n    padding: 1.5rem;\n    max-width: 42rem;\n    width: 100%;\n  \"\n>\n    ${\n\t\t\tcustom?.disableCornerDecorations\n\t\t\t\t? \"\"\n\t\t\t\t: `\n        <!-- Corner decorations -->\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            top: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-top: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>\n  \n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            left: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-left: 4px solid var(--corner-border);\n          \"\n        ></div>\n        <div\n          style=\"\n            position: absolute;\n            bottom: -2px;\n            right: -2px;\n            width: 2rem;\n            height: 2rem;\n            border-bottom: 4px solid var(--corner-border);\n            border-right: 4px solid var(--corner-border);\n          \"\n        ></div>`\n\t\t}\n\n        <div style=\"text-align: center; margin-bottom: 1.5rem;\">\n          <div style=\"margin-bottom: 1.5rem;\">\n            <div\n              style=\"\n                display: inline-block;\n                border: 2px solid ${custom?.disableTitleBorder ? \"transparent\" : custom?.colors?.titleBorder || \"var(--destructive)\"};\n                padding: 0.375rem 1rem;\n              \"\n            >\n              <h1\n                style=\"\n                  font-size: var(--text-6xl);\n                  font-weight: var(--font-weight-semibold);\n                  color: ${custom?.colors?.titleColor || \"var(--foreground)\"};\n                  letter-spacing: -0.02em;\n                  margin: 0;\n                \"\n              >\n                ERROR\n              </h1>\n            </div>\n            <div\n              style=\"\n                height: 2px;\n                background-color: var(--border);\n                width: calc(100% + 3rem);\n                margin-left: -1.5rem;\n                margin-top: 1.5rem;\n              \"\n            ></div>\n          </div>\n\n          <h2\n            style=\"\n              font-size: var(--text-2xl);\n              font-weight: var(--font-weight-semibold);\n              color: var(--foreground);\n              margin: 0 0 1rem;\n            \"\n          >\n            Something went wrong\n          </h2>\n\n          <div\n            style=\"\n                display: inline-flex;\n                align-items: center;\n                gap: 0.5rem;\n                border: 2px solid var(--border);\n                background-color: var(--muted);\n                padding: 0.375rem 0.75rem;\n                margin: 0 0 1rem;\n                flex-wrap: wrap;\n                justify-content: center;\n            \"\n            >\n            <span\n                style=\"\n                font-size: 0.75rem;\n                color: var(--muted-foreground);\n                font-weight: var(--font-weight-semibold);\n                \"\n            >\n                CODE:\n            </span>\n            <span\n                style=\"\n                font-size: var(--text-sm);\n                font-family: var(--default-mono-font-family, monospace);\n                color: var(--foreground);\n                word-break: break-all;\n                \"\n            >\n                ${sanitize(code)}\n            </span>\n            </div>\n\n          <p\n            style=\"\n              color: var(--muted-foreground);\n              max-width: 28rem;\n              margin: 0 auto;\n              font-size: var(--text-sm);\n              line-height: 1.5;\n              text-wrap: pretty;\n            \"\n          >\n            ${\n\t\t\t\t\t\t\t!description\n\t\t\t\t\t\t\t\t? \"We encountered an unexpected error. Please try again or return to the home page. If you're a developer, you can find more information about the error \" +\n\t\t\t\t\t\t\t\t\t`<a href='https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}' target='_blank' rel=\"noopener noreferrer\" style='color: var(--foreground); text-decoration: underline;'>here</a>.`\n\t\t\t\t\t\t\t\t: description\n\t\t\t\t\t\t}\n          </p>\n        </div>\n\n        <div\n          style=\"\n            display: flex;\n            gap: 0.75rem;\n            margin-top: 1.5rem;\n            justify-content: center;\n            flex-wrap: wrap;\n          \"\n        >\n          <a\n            href=\"/\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: var(--primary);\n                color: var(--primary-foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Go Home\n            </div>\n          </a>\n          <a\n            href=\"https://better-auth.com/docs/reference/errors/${encodeURIComponent(code)}?askai=${encodeURIComponent(`What does the error code ${code} mean?`)}\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            style=\"\n              text-decoration: none;\n            \"\n          >\n            <div\n              style=\"\n                border: 2px solid var(--border);\n                background: transparent;\n                color: var(--foreground);\n                padding: 0.5rem 1rem;\n                border-radius: 0;\n                white-space: nowrap;\n              \"\n              class=\"btn\"\n            >\n              Ask AI\n            </div>\n          </a>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>`;\n};\n\nexport const error = createAuthEndpoint(\n\t\"/error\",\n\t{\n\t\tmethod: \"GET\",\n\t\tmetadata: {\n\t\t\t...HIDE_METADATA,\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Displays an error page\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"text/html\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\tdescription: \"The HTML content of the error page\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (c) => {\n\t\tconst url = new URL(c.request?.url || \"\");\n\t\tconst unsanitizedCode = url.searchParams.get(\"error\") || \"UNKNOWN\";\n\t\tconst unsanitizedDescription =\n\t\t\turl.searchParams.get(\"error_description\") || null;\n\n\t\tconst isValid = /^[\\'A-Za-z0-9_-]+$/.test(unsanitizedCode || \"\");\n\t\tconst safeCode = isValid ? unsanitizedCode : \"UNKNOWN\";\n\t\tconst safeDescription = unsanitizedDescription\n\t\t\t? sanitize(unsanitizedDescription)\n\t\t\t: null;\n\n\t\tconst queryParams = new URLSearchParams();\n\t\tqueryParams.set(\"error\", safeCode);\n\t\tif (unsanitizedDescription) {\n\t\t\tqueryParams.set(\"error_description\", unsanitizedDescription);\n\t\t}\n\n\t\tconst options = c.context.options;\n\t\tconst errorURL = options.onAPIError?.errorURL;\n\n\t\tif (errorURL) {\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 302,\n\t\t\t\theaders: {\n\t\t\t\t\tLocation: `${errorURL}${errorURL.includes(\"?\") ? \"&\" : \"?\"}${queryParams.toString()}`,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (isProduction && !options.onAPIError?.customizeDefaultErrorPage) {\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 302,\n\t\t\t\theaders: {\n\t\t\t\t\tLocation: `/?${queryParams.toString()}`,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\treturn new Response(html(c.context.options, safeCode, safeDescription), {\n\t\t\theaders: {\n\t\t\t\t\"Content-Type\": \"text/html\",\n\t\t\t},\n\t\t});\n\t},\n);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6211, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/ok.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/ok.ts"],"sourcesContent":["import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { HIDE_METADATA } from \"../../utils/hide-metadata\";\n\nexport const ok = createAuthEndpoint(\n\t\"/ok\",\n\t{\n\t\tmethod: \"GET\",\n\t\tmetadata: {\n\t\t\t...HIDE_METADATA,\n\t\t\topenapi: {\n\t\t\t\tdescription: \"Check if the API is working\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"API is working\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tok: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the API is working\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"ok\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\treturn ctx.json({\n\t\t\tok: true,\n\t\t});\n\t},\n);\n"],"names":[],"mappings":";;;;;;;;;AAGA,MAAa,SAAK,qMAAA,EACjB,OACA;IACC,QAAQ;IACR,UAAU;QACT,GAAG,mMAAA;QACH,SAAS;YACR,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,IAAI;wCACH,MAAM;wCACN,aAAa;qCACb;gCAAA,CACD;gCACD,UAAU;oCAAC;iCAAK;6BAChB;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;KACD;CACD,EACD,OAAO,QAAQ;IACd,OAAO,IAAI,IAAA,CAAK;QACf,IAAI;IAAA,CACJ,CAAC;EAEH"}},
    {"offset": {"line": 6260, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/password.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/password.ts"],"sourcesContent":["import type { GenericEndpointContext } from \"@better-auth/core\";\nimport { APIError } from \"better-call\";\n\nexport async function validatePassword(\n\tctx: GenericEndpointContext,\n\tdata: {\n\t\tpassword: string;\n\t\tuserId: string;\n\t},\n) {\n\tconst accounts = await ctx.context.internalAdapter.findAccounts(data.userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword) {\n\t\treturn false;\n\t}\n\tconst compare = await ctx.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: data.password,\n\t});\n\treturn compare;\n}\n\nexport async function checkPassword(userId: string, c: GenericEndpointContext) {\n\tconst accounts = await c.context.internalAdapter.findAccounts(userId);\n\tconst credentialAccount = accounts?.find(\n\t\t(account) => account.providerId === \"credential\",\n\t);\n\tconst currentPassword = credentialAccount?.password;\n\tif (!credentialAccount || !currentPassword || !c.body.password) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"No password credential found\",\n\t\t});\n\t}\n\tconst compare = await c.context.password.verify({\n\t\thash: currentPassword,\n\t\tpassword: c.body.password,\n\t});\n\tif (!compare) {\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"Invalid password\",\n\t\t});\n\t}\n\treturn true;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAGA,eAAsB,iBACrB,GAAA,EACA,IAAA,EAIC;IAED,MAAM,oBAAA,CADW,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,KAAK,MAAA,CAAO,GACxC,KAAA,CAClC,UAAY,QAAQ,UAAA,KAAe,aACpC;IACD,MAAM,kBAAkB,mBAAmB;IAC3C,IAAI,CAAC,qBAAqB,CAAC,gBAC1B,CAAA,OAAO;IAMR,OAJgB,MAAM,IAAI,OAAA,CAAQ,QAAA,CAAS,MAAA,CAAO;QACjD,MAAM;QACN,UAAU,KAAK,QAAA;KACf,CAAC;;AAIH,eAAsB,cAAc,MAAA,EAAgB,CAAA,EAA2B;IAE9E,MAAM,oBAAA,CADW,MAAM,EAAE,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,OAAO,GACjC,KAAA,CAClC,UAAY,QAAQ,UAAA,KAAe,aACpC;IACD,MAAM,kBAAkB,mBAAmB;IAC3C,IAAI,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,EAAE,IAAA,CAAK,QAAA,CACrD,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAMH,IAAI,CAJY,MAAM,EAAE,OAAA,CAAQ,QAAA,CAAS,MAAA,CAAO;QAC/C,MAAM;QACN,UAAU,EAAE,IAAA,CAAK,QAAA;KACjB,CAAC,CAED,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS;IAAA,CACT,CAAC;IAEH,OAAO"}},
    {"offset": {"line": 6299, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/password.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/password.ts"],"sourcesContent":["import type { AuthContext } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { generateId } from \"../../utils\";\nimport { getDate } from \"../../utils/date\";\nimport { validatePassword } from \"../../utils/password\";\nimport { originCheck } from \"../middlewares\";\nimport { sensitiveSessionMiddleware } from \"./session\";\n\nfunction redirectError(\n\tctx: AuthContext,\n\tcallbackURL: string | undefined,\n\tquery?: Record<string, string> | undefined,\n): string {\n\tconst url = callbackURL\n\t\t? new URL(callbackURL, ctx.baseURL)\n\t\t: new URL(`${ctx.baseURL}/error`);\n\tif (query)\n\t\tObject.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\n\nfunction redirectCallback(\n\tctx: AuthContext,\n\tcallbackURL: string,\n\tquery?: Record<string, string> | undefined,\n): string {\n\tconst url = new URL(callbackURL, ctx.baseURL);\n\tif (query)\n\t\tObject.entries(query).forEach(([k, v]) => url.searchParams.set(k, v));\n\treturn url.href;\n}\n\nexport const requestPasswordReset = createAuthEndpoint(\n\t\"/request-password-reset\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The email address of the user to send a password reset email to.\n\t\t\t */\n\t\t\temail: z.email().meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The email address of the user to send a password reset email to\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The URL to redirect the user to reset their password.\n\t\t\t * If the token isn't valid or expired, it'll be redirected with a query parameter `?\n\t\t\t * error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?\n\t\t\t * token=VALID_TOKEN\n\t\t\t */\n\t\t\tredirectTo: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"requestPasswordReset\",\n\t\t\t\tdescription: \"Send a password reset email to the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.emailAndPassword?.sendResetPassword) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!\",\n\t\t\t);\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Reset password isn't enabled\",\n\t\t\t});\n\t\t}\n\t\tconst { email, redirectTo } = ctx.body;\n\n\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, {\n\t\t\tincludeAccounts: true,\n\t\t});\n\t\tif (!user) {\n\t\t\t/**\n\t\t\t * We simulate the verification token generation and the database lookup\n\t\t\t * to mitigate timing attacks.\n\t\t\t */\n\t\t\tgenerateId(24);\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(\n\t\t\t\t\"dummy-verification-token\",\n\t\t\t);\n\t\t\tctx.context.logger.error(\"Reset Password: User not found\", { email });\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t\tmessage:\n\t\t\t\t\t\"If this email exists in our system, check your email for the reset link\",\n\t\t\t});\n\t\t}\n\t\tconst defaultExpiresIn = 60 * 60 * 1;\n\t\tconst expiresAt = getDate(\n\t\t\tctx.context.options.emailAndPassword.resetPasswordTokenExpiresIn ||\n\t\t\t\tdefaultExpiresIn,\n\t\t\t\"sec\",\n\t\t);\n\t\tconst verificationToken = generateId(24);\n\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\tvalue: user.user.id,\n\t\t\tidentifier: `reset-password:${verificationToken}`,\n\t\t\texpiresAt,\n\t\t});\n\t\tconst callbackURL = redirectTo ? encodeURIComponent(redirectTo) : \"\";\n\t\tconst url = `${ctx.context.baseURL}/reset-password/${verificationToken}?callbackURL=${callbackURL}`;\n\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\tctx.context.options.emailAndPassword.sendResetPassword(\n\t\t\t\t{\n\t\t\t\t\tuser: user.user,\n\t\t\t\t\turl,\n\t\t\t\t\ttoken: verificationToken,\n\t\t\t\t},\n\t\t\t\tctx.request,\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t\tmessage:\n\t\t\t\t\"If this email exists in our system, check your email for the reset link\",\n\t\t});\n\t},\n);\n\nexport const requestPasswordResetCallback = createAuthEndpoint(\n\t\"/reset-password/:token\",\n\t{\n\t\tmethod: \"GET\",\n\t\toperationId: \"forgetPasswordCallback\",\n\t\tquery: z.object({\n\t\t\tcallbackURL: z.string().meta({\n\t\t\t\tdescription: \"The URL to redirect the user to reset their password\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"resetPasswordCallback\",\n\t\t\t\tdescription: \"Redirects the user to the callback URL with the token\",\n\t\t\t\tparameters: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"token\",\n\t\t\t\t\t\tin: \"path\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"The token to reset the password\",\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"callbackURL\",\n\t\t\t\t\t\tin: \"query\",\n\t\t\t\t\t\trequired: true,\n\t\t\t\t\t\tdescription: \"The URL to redirect the user to reset their password\",\n\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { token } = ctx.params;\n\t\tconst { callbackURL } = ctx.query;\n\t\tif (!token || !callbackURL) {\n\t\t\tthrow ctx.redirect(\n\t\t\t\tredirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }),\n\t\t\t);\n\t\t}\n\t\tconst verification =\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(\n\t\t\t\t`reset-password:${token}`,\n\t\t\t);\n\t\tif (!verification || verification.expiresAt < new Date()) {\n\t\t\tthrow ctx.redirect(\n\t\t\t\tredirectError(ctx.context, callbackURL, { error: \"INVALID_TOKEN\" }),\n\t\t\t);\n\t\t}\n\n\t\tthrow ctx.redirect(redirectCallback(ctx.context, callbackURL, { token }));\n\t},\n);\n\nexport const resetPassword = createAuthEndpoint(\n\t\"/reset-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"resetPassword\",\n\t\tquery: z\n\t\t\t.object({\n\t\t\t\ttoken: z.string().optional(),\n\t\t\t})\n\t\t\t.optional(),\n\t\tbody: z.object({\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set\",\n\t\t\t}),\n\t\t\ttoken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The token to reset the password\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"resetPassword\",\n\t\t\t\tdescription: \"Reset the password for a user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst token = ctx.body.token || ctx.query?.token;\n\t\tif (!token) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\n\t\tconst { newPassword } = ctx.body;\n\n\t\tconst minLength = ctx.context.password?.config.minPasswordLength;\n\t\tconst maxLength = ctx.context.password?.config.maxPasswordLength;\n\t\tif (newPassword.length < minLength) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\t\tif (newPassword.length > maxLength) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst id = `reset-password:${token}`;\n\n\t\tconst verification =\n\t\t\tawait ctx.context.internalAdapter.findVerificationValue(id);\n\t\tif (!verification || verification.expiresAt < new Date()) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tconst userId = verification.value;\n\t\tconst hashedPassword = await ctx.context.password.hash(newPassword);\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(userId);\n\t\tconst account = accounts.find((ac) => ac.providerId === \"credential\");\n\t\tif (!account) {\n\t\t\tawait ctx.context.internalAdapter.createAccount({\n\t\t\t\tuserId,\n\t\t\t\tproviderId: \"credential\",\n\t\t\t\tpassword: hashedPassword,\n\t\t\t\taccountId: userId,\n\t\t\t});\n\t\t} else {\n\t\t\tawait ctx.context.internalAdapter.updatePassword(userId, hashedPassword);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteVerificationValue(verification.id);\n\n\t\tif (ctx.context.options.emailAndPassword?.onPasswordReset) {\n\t\t\tconst user = await ctx.context.internalAdapter.findUserById(userId);\n\t\t\tif (user) {\n\t\t\t\tawait ctx.context.options.emailAndPassword.onPasswordReset(\n\t\t\t\t\t{\n\t\t\t\t\t\tuser,\n\t\t\t\t\t},\n\t\t\t\t\tctx.request,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(userId);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n\nexport const verifyPassword = createAuthEndpoint(\n\t\"/verify-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The password to verify\n\t\t\t */\n\t\t\tpassword: z.string().meta({\n\t\t\t\tdescription: \"The password to verify\",\n\t\t\t}),\n\t\t}),\n\t\tmetadata: {\n\t\t\tscope: \"server\",\n\t\t\topenapi: {\n\t\t\t\toperationId: \"verifyPassword\",\n\t\t\t\tdescription: \"Verify the current user's password\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tuse: [sensitiveSessionMiddleware],\n\t},\n\tasync (ctx) => {\n\t\tconst { password } = ctx.body;\n\t\tconst session = ctx.context.session;\n\n\t\tconst isValid = await validatePassword(ctx, {\n\t\t\tpassword,\n\t\t\tuserId: session.user.id,\n\t\t});\n\n\t\tif (!isValid) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t});\n\t\t}\n\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA,SAAS,cACR,GAAA,EACA,WAAA,EACA,KAAA,EACS;IACT,MAAM,MAAM,cACT,IAAI,IAAI,aAAa,IAAI,OAAA,CAAQ,GACjC,IAAI,IAAI,GAAG,IAAI,OAAA,CAAQ,MAAA,CAAA,CAAQ;IAClC,IAAI,MACH,CAAA,OAAO,OAAA,CAAQ,MAAM,CAAC,OAAA,CAAA,CAAS,CAAC,GAAG,EAAA,GAAO,IAAI,YAAA,CAAa,GAAA,CAAI,GAAG,EAAE,CAAC;IACtE,OAAO,IAAI,IAAA;;AAGZ,SAAS,iBACR,GAAA,EACA,WAAA,EACA,KAAA,EACS;IACT,MAAM,MAAM,IAAI,IAAI,aAAa,IAAI,OAAA,CAAQ;IAC7C,IAAI,MACH,CAAA,OAAO,OAAA,CAAQ,MAAM,CAAC,OAAA,CAAA,CAAS,CAAC,GAAG,EAAA,GAAO,IAAI,YAAA,CAAa,GAAA,CAAI,GAAG,EAAE,CAAC;IACtE,OAAO,IAAI,IAAA;;AAGZ,MAAa,2BAAuB,qMAAA,EACnC,2BACA;IACC,QAAQ;IACR,MAAM,EAAE,qKAAA,CAAO;QAId,OAAO,EAAE,oKAAA,EAAO,CAAC,IAAA,CAAK;YACrB,aACC;QAAA,CACD,CAAC;QAOF,YAAY,EACV,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aACC;QAAA,CACD,CAAC,CACD,QAAA,EAAU;KACZ,CAAC;IACF,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,QAAQ;wCACP,MAAM;oCAAA,CACN;oCACD,SAAS;wCACR,MAAM;oCAAA,CACN;iCACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,IAAI,CAAC,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,EAAkB,mBAAmB;QAC7D,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAClB,+GACA;QACD,MAAM,IAAI,0KAAA,CAAS,eAAe;YACjC,SAAS;QAAA,CACT,CAAC;;IAEH,MAAM,EAAE,KAAA,EAAO,UAAA,EAAA,GAAe,IAAI,IAAA;IAElC,MAAM,OAAO,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,eAAA,CAAgB,OAAO;QACrE,iBAAiB;IAAA,CACjB,CAAC;IACF,IAAI,CAAC,MAAM;;;;KAKV,IAAA,4LAAA,EAAW,GAAG;QACd,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,qBAAA,CACjC,2BACA;QACD,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,kCAAkC;YAAE;QAAA,CAAO,CAAC;QACrE,OAAO,IAAI,IAAA,CAAK;YACf,QAAQ;YACR,SACC;SACD,CAAC;;IAGH,MAAM,gBAAY,iLAAA,EACjB,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,CAAiB,2BAAA,IAFb,OAAU,GAIlC,MACA;IACD,MAAM,wBAAoB,4LAAA,EAAW,GAAG;IACxC,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,uBAAA,CAAwB;QACzD,OAAO,KAAK,IAAA,CAAK,EAAA;QACjB,YAAY,CAAA,eAAA,EAAkB,mBAAA;QAC9B;KACA,CAAC;IACF,MAAM,cAAc,aAAa,mBAAmB,WAAW,GAAG;IAClE,MAAM,MAAM,GAAG,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,EAAkB,kBAAkB,aAAA,EAAe,aAAA;IACtF,MAAM,IAAI,OAAA,CAAQ,sBAAA,CACjB,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,CAAiB,iBAAA,CACpC;QACC,MAAM,KAAK,IAAA;QACX;QACA,OAAO;KACP,EACD,IAAI,OAAA,CACJ,CACD;IACD,OAAO,IAAI,IAAA,CAAK;QACf,QAAQ;QACR,SACC;KACD,CAAC;EAEH;AAED,MAAa,mCAA+B,qMAAA,EAC3C,0BACA;IACC,QAAQ;IACR,aAAa;IACb,OAAO,EAAE,qKAAA,CAAO;QACf,aAAa,EAAE,qKAAA,EAAQ,CAAC,IAAA,CAAK;YAC5B,aAAa;QAAA,CACb,CAAC;IAAA,CACF,CAAC;IACF,KAAK;YAAC,6MAAA,EAAA,CAAa,MAAQ,IAAI,KAAA,CAAM,WAAA,CAAY;KAAC;IAClD,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,YAAY;gBACX;oBACC,MAAM;oBACN,IAAI;oBACJ,UAAU;oBACV,aAAa;oBACb,QAAQ;wBACP,MAAM;oBAAA,CACN;iBACD;gBACD;oBACC,MAAM;oBACN,IAAI;oBACJ,UAAU;oBACV,aAAa;oBACb,QAAQ;wBACP,MAAM;oBAAA,CACN;iBACD;aACD;YACD,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,OAAO;wCACN,MAAM;oCAAA,CACN;gCAAA,CACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,EAAE,KAAA,EAAA,GAAU,IAAI,MAAA;IACtB,MAAM,EAAE,WAAA,EAAA,GAAgB,IAAI,KAAA;IAC5B,IAAI,CAAC,SAAS,CAAC,YACd,CAAA,MAAM,IAAI,QAAA,CACT,cAAc,IAAI,OAAA,EAAS,aAAa;QAAE,OAAO;IAAA,CAAiB,CAAC,CACnE;IAEF,MAAM,eACL,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,qBAAA,CACjC,CAAA,eAAA,EAAkB,OAAA,CAClB;IACF,IAAI,CAAC,gBAAgB,aAAa,SAAA,GAAA,aAAA,GAAY,IAAI,MAAM,CACvD,CAAA,MAAM,IAAI,QAAA,CACT,cAAc,IAAI,OAAA,EAAS,aAAa;QAAE,OAAO;IAAA,CAAiB,CAAC,CACnE;IAGF,MAAM,IAAI,QAAA,CAAS,iBAAiB,IAAI,OAAA,EAAS,aAAa;QAAE;IAAA,CAAO,CAAC,CAAC;EAE1E;AAED,MAAa,oBAAgB,qMAAA,EAC5B,mBACA;IACC,QAAQ;IACR,aAAa;IACb,OAAO,EACL,qKAAA,CAAO;QACP,OAAO,EAAE,qKAAA,EAAQ,CAAC,QAAA,EAAU;IAAA,CAC5B,CAAC,CACD,QAAA,EAAU;IACZ,MAAM,EAAE,qKAAA,CAAO;QACd,aAAa,EAAE,qKAAA,EAAQ,CAAC,IAAA,CAAK;YAC5B,aAAa;QAAA,CACb,CAAC;QACF,OAAO,EACL,qKAAA,EAAQ,CACR,IAAA,CAAK;YACL,aAAa;QAAA,CACb,CAAC,CACD,QAAA,EAAU;KACZ,CAAC;IACF,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,QAAQ;wCACP,MAAM;oCAAA,CACN;gCAAA,CACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,QAAQ,IAAI,IAAA,CAAK,KAAA,IAAS,IAAI,KAAA,EAAO;IAC3C,IAAI,CAAC,MACJ,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,aAAA;IAAA,CAC1B,CAAC;IAGH,MAAM,EAAE,WAAA,EAAA,GAAgB,IAAI,IAAA;IAE5B,MAAM,YAAY,IAAI,OAAA,CAAQ,QAAA,EAAU,OAAO;IAC/C,MAAM,YAAY,IAAI,OAAA,CAAQ,QAAA,EAAU,OAAO;IAC/C,IAAI,YAAY,MAAA,GAAS,UACxB,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,kBAAA;IAAA,CAC1B,CAAC;IAEH,IAAI,YAAY,MAAA,GAAS,UACxB,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,iBAAA;IAAA,CAC1B,CAAC;IAGH,MAAM,KAAK,CAAA,eAAA,EAAkB,OAAA;IAE7B,MAAM,eACL,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,qBAAA,CAAsB,GAAG;IAC5D,IAAI,CAAC,gBAAgB,aAAa,SAAA,GAAA,aAAA,GAAY,IAAI,MAAM,CACvD,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,aAAA;IAAA,CAC1B,CAAC;IAEH,MAAM,SAAS,aAAa,KAAA;IAC5B,MAAM,iBAAiB,MAAM,IAAI,OAAA,CAAQ,QAAA,CAAS,IAAA,CAAK,YAAY;IAGnE,IAAI,CAAA,CAFa,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,OAAO,EAC9C,IAAA,CAAA,CAAM,KAAO,GAAG,UAAA,KAAe,aAAa,CAEpE,CAAA,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAAc;QAC/C;QACA,YAAY;QACZ,UAAU;QACV,WAAW;KACX,CAAC;SAEF,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,cAAA,CAAe,QAAQ,eAAe;IAEzE,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,uBAAA,CAAwB,aAAa,EAAA,CAAG;IAE1E,IAAI,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,EAAkB,iBAAiB;QAC1D,MAAM,OAAO,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,YAAA,CAAa,OAAO;QACnE,IAAI,KACH,CAAA,MAAM,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,CAAiB,eAAA,CAC1C;YACC;QAAA,CACA,EACD,IAAI,OAAA,CACJ;;IAGH,IAAI,IAAI,OAAA,CAAQ,OAAA,CAAQ,gBAAA,EAAkB,8BACzC,CAAA,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,cAAA,CAAe,OAAO;IAEzD,OAAO,IAAI,IAAA,CAAK;QACf,QAAQ;IAAA,CACR,CAAC;EAEH;AAED,MAAa,qBAAiB,qMAAA,EAC7B,oBACA;IACC,QAAQ;IACR,MAAM,EAAE,qKAAA,CAAO;QAId,UAAU,EAAE,qKAAA,EAAQ,CAAC,IAAA,CAAK;YACzB,aAAa;QAAA,CACb,CAAC;IAAA,CACF,CAAC;IACF,UAAU;QACT,OAAO;QACP,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,QAAQ;wCACP,MAAM;oCAAA,CACN;gCAAA,CACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;KACD;IACD,KAAK;QAAC,+MAAA;KAA2B;CACjC,EACD,OAAO,QAAQ;IACd,MAAM,EAAE,QAAA,EAAA,GAAa,IAAI,IAAA;IACzB,MAAM,UAAU,IAAI,OAAA,CAAQ,OAAA;IAO5B,IAAI,CALY,UAAM,8LAAA,EAAiB,KAAK;QAC3C;QACA,QAAQ,QAAQ,IAAA,CAAK,EAAA;KACrB,CAAC,CAGD,CAAA,MAAM,IAAI,0KAAA,CAAS,eAAe;QACjC,SAAS,qMAAA,CAAiB,gBAAA;IAAA,CAC1B,CAAC;IAGH,OAAO,IAAI,IAAA,CAAK;QACf,QAAQ;IAAA,CACR,CAAC;EAEH"}},
    {"offset": {"line": 6621, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/sign-in.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/sign-in.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { SocialProviderListEnum } from \"@better-auth/core/social-providers\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport { handleOAuthUserInfo } from \"../../oauth2/link-account\";\nimport type { InferUser } from \"../../types\";\nimport { generateState } from \"../../utils\";\nimport { formCsrfMiddleware } from \"../middlewares/origin-check\";\nimport { createEmailVerificationToken } from \"./email-verification\";\n\nconst socialSignInBodySchema = z.object({\n\t/**\n\t * Callback URL to redirect to after the user\n\t * has signed in.\n\t */\n\tcallbackURL: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"Callback URL to redirect to after the user has signed in\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * callback url to redirect if the user is newly registered.\n\t *\n\t * useful if you have different routes for existing users and new users\n\t */\n\tnewUserCallbackURL: z.string().optional(),\n\t/**\n\t * Callback url to redirect to if an error happens\n\t *\n\t * If it's initiated from the client sdk this defaults to\n\t * the current url.\n\t */\n\terrorCallbackURL: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"Callback URL to redirect to if an error happens\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * OAuth2 provider to use`\n\t */\n\tprovider: SocialProviderListEnum,\n\t/**\n\t * Disable automatic redirection to the provider\n\t *\n\t * This is useful if you want to handle the redirection\n\t * yourself like in a popup or a different tab.\n\t */\n\tdisableRedirect: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Disable automatic redirection to the provider. Useful for handling the redirection yourself\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * ID token from the provider\n\t *\n\t * This is used to sign in the user\n\t * if the user is already signed in with the\n\t * provider in the frontend.\n\t *\n\t * Only applicable if the provider supports\n\t * it. Currently only `apple` and `google` is\n\t * supported out of the box.\n\t */\n\tidToken: z.optional(\n\t\tz.object({\n\t\t\t/**\n\t\t\t * ID token from the provider\n\t\t\t */\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"ID token from the provider\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The nonce used to generate the token\n\t\t\t */\n\t\t\tnonce: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Nonce used to generate the token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Access token from the provider\n\t\t\t */\n\t\t\taccessToken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Access token from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Refresh token from the provider\n\t\t\t */\n\t\t\trefreshToken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Refresh token from the provider\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * Expiry date of the token\n\t\t\t */\n\t\t\texpiresAt: z\n\t\t\t\t.number()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Expiry date of the token\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t),\n\tscopes: z\n\t\t.array(z.string())\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Array of scopes to request from the provider. This will override the default scopes passed.\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Explicitly request sign-up\n\t *\n\t * Should be used to allow sign up when\n\t * disableImplicitSignUp for this provider is\n\t * true\n\t */\n\trequestSignUp: z\n\t\t.boolean()\n\t\t.meta({\n\t\t\tdescription:\n\t\t\t\t\"Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * The login hint to use for the authorization code request\n\t */\n\tloginHint: z\n\t\t.string()\n\t\t.meta({\n\t\t\tdescription: \"The login hint to use for the authorization code request\",\n\t\t})\n\t\t.optional(),\n\t/**\n\t * Additional data to be passed through the OAuth flow\n\t */\n\tadditionalData: z.record(z.string(), z.any()).optional().meta({\n\t\tdescription: \"Additional data to be passed through the OAuth flow\",\n\t}),\n});\n\nexport const signInSocial = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-in/social\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"socialSignIn\",\n\t\t\tbody: socialSignInBodySchema,\n\t\t\tmetadata: {\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as z.infer<typeof socialSignInBodySchema>,\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\tredirect: boolean;\n\t\t\t\t\t\ttoken?: string | undefined;\n\t\t\t\t\t\turl?: string | undefined;\n\t\t\t\t\t\tuser?: InferUser<O> | undefined;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\tdescription: \"Sign in with a social provider\",\n\t\t\t\t\toperationId: \"socialSignIn\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Success - Returns either session details or redirect URL\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\t// todo: we need support for multiple schema\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tenum: [false],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"redirect\", \"token\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tc,\n\t\t): Promise<\n\t\t\t| { redirect: boolean; url: string }\n\t\t\t| { redirect: boolean; token: string; url: undefined; user: InferUser<O> }\n\t\t> => {\n\t\t\tconst provider = c.context.socialProviders.find(\n\t\t\t\t(p) => p.id === c.body.provider,\n\t\t\t);\n\t\t\tif (!provider) {\n\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\"Provider not found. Make sure to add the provider in your auth config\",\n\t\t\t\t\t{\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.PROVIDER_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (c.body.idToken) {\n\t\t\t\tif (!provider.verifyIdToken) {\n\t\t\t\t\tc.context.logger.error(\n\t\t\t\t\t\t\"Provider does not support id token verification\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t\t},\n\t\t\t\t\t);\n\t\t\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.ID_TOKEN_NOT_SUPPORTED,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst { token, nonce } = c.body.idToken;\n\t\t\t\tconst valid = await provider.verifyIdToken(token, nonce);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tc.context.logger.error(\"Invalid id token\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst userInfo = await provider.getUserInfo({\n\t\t\t\t\tidToken: token,\n\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\trefreshToken: c.body.idToken.refreshToken,\n\t\t\t\t});\n\t\t\t\tif (!userInfo || !userInfo?.user) {\n\t\t\t\t\tc.context.logger.error(\"Failed to get user info\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!userInfo.user.email) {\n\t\t\t\t\tc.context.logger.error(\"User email not found\", {\n\t\t\t\t\t\tprovider: c.body.provider,\n\t\t\t\t\t});\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_EMAIL_NOT_FOUND,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst data = await handleOAuthUserInfo(c, {\n\t\t\t\t\tuserInfo: {\n\t\t\t\t\t\t...userInfo.user,\n\t\t\t\t\t\temail: userInfo.user.email,\n\t\t\t\t\t\tid: String(userInfo.user.id),\n\t\t\t\t\t\tname: userInfo.user.name || \"\",\n\t\t\t\t\t\timage: userInfo.user.image,\n\t\t\t\t\t\temailVerified: userInfo.user.emailVerified || false,\n\t\t\t\t\t},\n\t\t\t\t\taccount: {\n\t\t\t\t\t\tproviderId: provider.id,\n\t\t\t\t\t\taccountId: String(userInfo.user.id),\n\t\t\t\t\t\taccessToken: c.body.idToken.accessToken,\n\t\t\t\t\t},\n\t\t\t\t\tcallbackURL: c.body.callbackURL,\n\t\t\t\t\tdisableSignUp:\n\t\t\t\t\t\t(provider.disableImplicitSignUp && !c.body.requestSignUp) ||\n\t\t\t\t\t\tprovider.disableSignUp,\n\t\t\t\t});\n\t\t\t\tif (data.error) {\n\t\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\t\tmessage: data.error,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(c, data.data!);\n\t\t\t\treturn c.json({\n\t\t\t\t\tredirect: false,\n\t\t\t\t\ttoken: data.data!.session.token,\n\t\t\t\t\turl: undefined,\n\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\tc.context.options,\n\t\t\t\t\t\tdata.data!.user,\n\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst { codeVerifier, state } = await generateState(\n\t\t\t\tc,\n\t\t\t\tundefined,\n\t\t\t\tc.body.additionalData,\n\t\t\t);\n\t\t\tconst url = await provider.createAuthorizationURL({\n\t\t\t\tstate,\n\t\t\t\tcodeVerifier,\n\t\t\t\tredirectURI: `${c.context.baseURL}/callback/${provider.id}`,\n\t\t\t\tscopes: c.body.scopes,\n\t\t\t\tloginHint: c.body.loginHint,\n\t\t\t});\n\n\t\t\tif (!c.body.disableRedirect) {\n\t\t\t\tc.setHeader(\"Location\", url.toString());\n\t\t\t}\n\n\t\t\treturn c.json({\n\t\t\t\turl: url.toString(),\n\t\t\t\tredirect: !c.body.disableRedirect,\n\t\t\t});\n\t\t},\n\t);\n\nexport const signInEmail = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-in/email\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"signInEmail\",\n\t\t\tuse: [formCsrfMiddleware],\n\t\t\tbody: z.object({\n\t\t\t\t/**\n\t\t\t\t * Email of the user\n\t\t\t\t */\n\t\t\t\temail: z.string().meta({\n\t\t\t\t\tdescription: \"Email of the user\",\n\t\t\t\t}),\n\t\t\t\t/**\n\t\t\t\t * Password of the user\n\t\t\t\t */\n\t\t\t\tpassword: z.string().meta({\n\t\t\t\t\tdescription: \"Password of the user\",\n\t\t\t\t}),\n\t\t\t\t/**\n\t\t\t\t * Callback URL to use as a redirect for email\n\t\t\t\t * verification and for possible redirects\n\t\t\t\t */\n\t\t\t\tcallbackURL: z\n\t\t\t\t\t.string()\n\t\t\t\t\t.meta({\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Callback URL to use as a redirect for email verification\",\n\t\t\t\t\t})\n\t\t\t\t\t.optional(),\n\t\t\t\t/**\n\t\t\t\t * If this is false, the session will not be remembered\n\t\t\t\t * @default true\n\t\t\t\t */\n\t\t\t\trememberMe: z\n\t\t\t\t\t.boolean()\n\t\t\t\t\t.meta({\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"If this is false, the session will not be remembered. Default is `true`.\",\n\t\t\t\t\t})\n\t\t\t\t\t.default(true)\n\t\t\t\t\t.optional(),\n\t\t\t}),\n\t\t\tmetadata: {\n\t\t\t\tallowedMediaTypes: [\n\t\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\t\"application/json\",\n\t\t\t\t],\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as {\n\t\t\t\t\t\temail: string;\n\t\t\t\t\t\tpassword: string;\n\t\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t\t},\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\tredirect: boolean;\n\t\t\t\t\t\ttoken: string;\n\t\t\t\t\t\turl?: string | undefined;\n\t\t\t\t\t\tuser: InferUser<O>;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"signInEmail\",\n\t\t\t\t\tdescription: \"Sign in with email and password\",\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Success - Returns either session details or redirect URL\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\t// todo: we need support for multiple schema\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"Session response when idToken is provided\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tredirect: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\tenum: [false],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Session token\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\turl: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"redirect\", \"token\", \"user\"],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (\n\t\t\tctx,\n\t\t): Promise<{\n\t\t\tredirect: boolean;\n\t\t\ttoken: string;\n\t\t\turl?: string | undefined;\n\t\t\tuser: InferUser<O>;\n\t\t}> => {\n\t\t\tif (!ctx.context.options?.emailAndPassword?.enabled) {\n\t\t\t\tctx.context.logger.error(\n\t\t\t\t\t\"Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!\",\n\t\t\t\t);\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"Email and password is not enabled\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst { email, password } = ctx.body;\n\t\t\tconst isValidEmail = z.email().safeParse(email);\n\t\t\tif (!isValidEmail.success) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst user = await ctx.context.internalAdapter.findUserByEmail(email, {\n\t\t\t\tincludeAccounts: true,\n\t\t\t});\n\n\t\t\tif (!user) {\n\t\t\t\t// Hash password to prevent timing attacks from revealing valid email addresses\n\t\t\t\t// By hashing passwords for invalid emails, we ensure consistent response times\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"User not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst credentialAccount = user.accounts.find(\n\t\t\t\t(a) => a.providerId === \"credential\",\n\t\t\t);\n\t\t\tif (!credentialAccount) {\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"Credential account not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst currentPassword = credentialAccount?.password;\n\t\t\tif (!currentPassword) {\n\t\t\t\tawait ctx.context.password.hash(password);\n\t\t\t\tctx.context.logger.error(\"Password not found\", { email });\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst validPassword = await ctx.context.password.verify({\n\t\t\t\thash: currentPassword,\n\t\t\t\tpassword,\n\t\t\t});\n\t\t\tif (!validPassword) {\n\t\t\t\tctx.context.logger.error(\"Invalid password\");\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL_OR_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tctx.context.options?.emailAndPassword?.requireEmailVerification &&\n\t\t\t\t!user.user.emailVerified\n\t\t\t) {\n\t\t\t\tif (!ctx.context.options?.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (ctx.context.options?.emailVerification?.sendOnSignIn) {\n\t\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tuser.user.email,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t);\n\t\t\t\t\tconst callbackURL = ctx.body.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(ctx.body.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuser: user.user,\n\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new APIError(\"FORBIDDEN\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_NOT_VERIFIED,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\tuser.user.id,\n\t\t\t\tctx.body.rememberMe === false,\n\t\t\t);\n\n\t\t\tif (!session) {\n\t\t\t\tctx.context.logger.error(\"Failed to create session\");\n\t\t\t\tthrow new APIError(\"UNAUTHORIZED\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait setSessionCookie(\n\t\t\t\tctx,\n\t\t\t\t{\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user.user,\n\t\t\t\t},\n\t\t\t\tctx.body.rememberMe === false,\n\t\t\t);\n\n\t\t\tif (ctx.body.callbackURL) {\n\t\t\t\tctx.setHeader(\"Location\", ctx.body.callbackURL);\n\t\t\t}\n\n\t\t\treturn ctx.json({\n\t\t\t\tredirect: !!ctx.body.callbackURL,\n\t\t\t\ttoken: session.token,\n\t\t\t\turl: ctx.body.callbackURL,\n\t\t\t\tuser: parseUserOutput(ctx.context.options, user.user) as InferUser<O>,\n\t\t\t});\n\t\t},\n\t);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 7004, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/sign-out.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/sign-out.ts"],"sourcesContent":["import { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { deleteSessionCookie } from \"../../cookies\";\n\nexport const signOut = createAuthEndpoint(\n\t\"/sign-out\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"signOut\",\n\t\trequireHeaders: true,\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"signOut\",\n\t\t\t\tdescription: \"Sign out the current user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst sessionCookieToken = await ctx.getSignedCookie(\n\t\t\tctx.context.authCookies.sessionToken.name,\n\t\t\tctx.context.secret,\n\t\t);\n\t\tif (sessionCookieToken) {\n\t\t\ttry {\n\t\t\t\tawait ctx.context.internalAdapter.deleteSession(sessionCookieToken);\n\t\t\t} catch (e) {\n\t\t\t\tctx.context.logger.error(\"Failed to delete session from database\", e);\n\t\t\t}\n\t\t}\n\t\tdeleteSessionCookie(ctx);\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t});\n\t},\n);\n"],"names":[],"mappings":";;;;;;;;;AAGA,MAAa,cAAU,qMAAA,EACtB,aACA;IACC,QAAQ;IACR,aAAa;IACb,gBAAgB;IAChB,UAAU;QACT,SAAS;YACR,aAAa;YACb,aAAa;YACb,WAAW;gBACV,OAAO;oBACN,aAAa;oBACb,SAAS;wBACR,oBAAoB;4BACnB,QAAQ;gCACP,MAAM;gCACN,YAAY;oCACX,SAAS;wCACR,MAAM;oCAAA,CACN;gCAAA,CACD;6BACD;wBAAA,CACD;oBAAA,CACD;iBACD;YAAA,CACD;SACD;IAAA,CACD;CACD,EACD,OAAO,QAAQ;IACd,MAAM,qBAAqB,MAAM,IAAI,eAAA,CACpC,IAAI,OAAA,CAAQ,WAAA,CAAY,YAAA,CAAa,IAAA,EACrC,IAAI,OAAA,CAAQ,MAAA,CACZ;IACD,IAAI,mBACH,CAAA,IAAI;QACH,MAAM,IAAI,OAAA,CAAQ,eAAA,CAAgB,aAAA,CAAc,mBAAmB;aAC3D,GAAG;QACX,IAAI,OAAA,CAAQ,MAAA,CAAO,KAAA,CAAM,0CAA0C,EAAE;;IAGvE,IAAA,gNAAA,EAAoB,IAAI;IACxB,OAAO,IAAI,IAAA,CAAK;QACf,SAAS;IAAA,CACT,CAAC;EAEH"}},
    {"offset": {"line": 7058, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/sign-up.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/sign-up.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { runWithTransaction } from \"@better-auth/core/context\";\nimport { isDevelopment } from \"@better-auth/core/env\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { setSessionCookie } from \"../../cookies\";\nimport { parseUserInput } from \"../../db\";\nimport { parseUserOutput } from \"../../db/schema\";\nimport type { AdditionalUserFieldsInput, InferUser, User } from \"../../types\";\n\nimport { formCsrfMiddleware } from \"../middlewares/origin-check\";\nimport { createEmailVerificationToken } from \"./email-verification\";\n\nconst signUpEmailBodySchema = z\n\t.object({\n\t\tname: z.string(),\n\t\temail: z.email(),\n\t\tpassword: z.string().nonempty(),\n\t\timage: z.string().optional(),\n\t\tcallbackURL: z.string().optional(),\n\t\trememberMe: z.boolean().optional(),\n\t})\n\t.and(z.record(z.string(), z.any()));\n\nexport const signUpEmail = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/sign-up/email\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"signUpWithEmailAndPassword\",\n\t\t\tuse: [formCsrfMiddleware],\n\t\t\tbody: signUpEmailBodySchema,\n\t\t\tmetadata: {\n\t\t\t\tallowedMediaTypes: [\n\t\t\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\t\t\"application/json\",\n\t\t\t\t],\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as {\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\temail: string;\n\t\t\t\t\t\tpassword: string;\n\t\t\t\t\t\timage?: string | undefined;\n\t\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t\t} & AdditionalUserFieldsInput<O>,\n\t\t\t\t\treturned: {} as {\n\t\t\t\t\t\ttoken: string | null;\n\t\t\t\t\t\tuser: InferUser<O>;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"signUpWithEmailAndPassword\",\n\t\t\t\t\tdescription: \"Sign up a user using email and password\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tpassword: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The password of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"The URL to use for email verification callback\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trememberMe: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"If this is false, the session will not be remembered. Default is `true`.\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"name\", \"email\", \"password\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Successfully created user\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Authentication token for the session\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email address of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was created\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\trequired: [\"user\"], // token is optional\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"422\": {\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\"Unprocessable Entity. User already exists or failed to create user.\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\treturn runWithTransaction(ctx.context.adapter, async () => {\n\t\t\t\tif (\n\t\t\t\t\t!ctx.context.options.emailAndPassword?.enabled ||\n\t\t\t\t\tctx.context.options.emailAndPassword?.disableSignUp\n\t\t\t\t) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: \"Email and password sign up is not enabled\",\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst body = ctx.body as any as User & {\n\t\t\t\t\tpassword: string;\n\t\t\t\t\tcallbackURL?: string | undefined;\n\t\t\t\t\trememberMe?: boolean | undefined;\n\t\t\t\t} & {\n\t\t\t\t\t[key: string]: any;\n\t\t\t\t};\n\t\t\t\tconst {\n\t\t\t\t\tname,\n\t\t\t\t\temail,\n\t\t\t\t\tpassword,\n\t\t\t\t\timage,\n\t\t\t\t\tcallbackURL: _callbackURL,\n\t\t\t\t\trememberMe,\n\t\t\t\t\t...rest\n\t\t\t\t} = body;\n\t\t\t\tconst isValidEmail = z.email().safeParse(email);\n\n\t\t\t\tif (!isValidEmail.success) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_EMAIL,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!password || typeof password !== \"string\") {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\t\t\tif (password.length < minPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\t\t\t\tif (password.length > maxPasswordLength) {\n\t\t\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst dbUser = await ctx.context.internalAdapter.findUserByEmail(email);\n\t\t\t\tif (dbUser?.user) {\n\t\t\t\t\tctx.context.logger.info(\n\t\t\t\t\t\t`Sign-up attempt for existing email: ${email}`,\n\t\t\t\t\t);\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * Hash the password\n\t\t\t\t *\n\t\t\t\t * This is done prior to creating the user\n\t\t\t\t * to ensure that any plugin that\n\t\t\t\t * may break the hashing should break\n\t\t\t\t * before the user is created.\n\t\t\t\t */\n\t\t\t\tconst hash = await ctx.context.password.hash(password);\n\t\t\t\tlet createdUser: User;\n\t\t\t\ttry {\n\t\t\t\t\tconst data = parseUserInput(ctx.context.options, rest, \"create\");\n\t\t\t\t\tcreatedUser = await ctx.context.internalAdapter.createUser({\n\t\t\t\t\t\temail: email.toLowerCase(),\n\t\t\t\t\t\tname,\n\t\t\t\t\t\timage,\n\t\t\t\t\t\t...data,\n\t\t\t\t\t\temailVerified: false,\n\t\t\t\t\t});\n\t\t\t\t\tif (!createdUser) {\n\t\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (isDevelopment()) {\n\t\t\t\t\t\tctx.context.logger.error(\"Failed to create user\", e);\n\t\t\t\t\t}\n\t\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\tctx.context.logger?.error(\"Failed to create user\", e);\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (!createdUser) {\n\t\t\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_USER,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\t\t\tuserId: createdUser.id,\n\t\t\t\t\tproviderId: \"credential\",\n\t\t\t\t\taccountId: createdUser.id,\n\t\t\t\t\tpassword: hash,\n\t\t\t\t});\n\t\t\t\tconst shouldSendVerificationEmail =\n\t\t\t\t\tctx.context.options.emailVerification?.sendOnSignUp ??\n\t\t\t\t\tctx.context.options.emailAndPassword.requireEmailVerification;\n\t\t\t\tif (shouldSendVerificationEmail) {\n\t\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\t\tctx.context.secret,\n\t\t\t\t\t\tcreatedUser.email,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t\t);\n\t\t\t\t\tconst callbackURL = body.callbackURL\n\t\t\t\t\t\t? encodeURIComponent(body.callbackURL)\n\t\t\t\t\t\t: encodeURIComponent(\"/\");\n\t\t\t\t\tconst url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${callbackURL}`;\n\n\t\t\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuser: createdUser,\n\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tctx.request,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tctx.context.options.emailAndPassword.autoSignIn === false ||\n\t\t\t\t\tctx.context.options.emailAndPassword.requireEmailVerification\n\t\t\t\t) {\n\t\t\t\t\treturn ctx.json({\n\t\t\t\t\t\ttoken: null,\n\t\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\t\tcreatedUser,\n\t\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst session = await ctx.context.internalAdapter.createSession(\n\t\t\t\t\tcreatedUser.id,\n\t\t\t\t\trememberMe === false,\n\t\t\t\t);\n\t\t\t\tif (!session) {\n\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tawait setSessionCookie(\n\t\t\t\t\tctx,\n\t\t\t\t\t{\n\t\t\t\t\t\tsession,\n\t\t\t\t\t\tuser: createdUser,\n\t\t\t\t\t},\n\t\t\t\t\trememberMe === false,\n\t\t\t\t);\n\t\t\t\treturn ctx.json({\n\t\t\t\t\ttoken: session.token,\n\t\t\t\t\tuser: parseUserOutput(\n\t\t\t\t\t\tctx.context.options,\n\t\t\t\t\t\tcreatedUser,\n\t\t\t\t\t) as InferUser<O>,\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t);\n"],"names":["createdUser: User"],"mappings":"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"}},
    {"offset": {"line": 7346, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/routes/update-user.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/routes/update-user.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { createAuthEndpoint } from \"@better-auth/core/api\";\nimport { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { APIError } from \"better-call\";\nimport * as z from \"zod\";\nimport { deleteSessionCookie, setSessionCookie } from \"../../cookies\";\nimport { generateRandomString } from \"../../crypto\";\nimport { parseUserInput, parseUserOutput } from \"../../db/schema\";\nimport type { AdditionalUserFieldsInput } from \"../../types\";\nimport { originCheck } from \"../middlewares\";\nimport { createEmailVerificationToken } from \"./email-verification\";\nimport {\n\tgetSessionFromCtx,\n\tsensitiveSessionMiddleware,\n\tsessionMiddleware,\n} from \"./session\";\n\nconst updateUserBodySchema = z.record(\n\tz.string().meta({\n\t\tdescription: \"Field name must be a string\",\n\t}),\n\tz.any(),\n);\n\nexport const updateUser = <O extends BetterAuthOptions>() =>\n\tcreateAuthEndpoint(\n\t\t\"/update-user\",\n\t\t{\n\t\t\tmethod: \"POST\",\n\t\t\toperationId: \"updateUser\",\n\t\t\tbody: updateUserBodySchema,\n\t\t\tuse: [sessionMiddleware],\n\t\t\tmetadata: {\n\t\t\t\t$Infer: {\n\t\t\t\t\tbody: {} as Partial<AdditionalUserFieldsInput<O>> & {\n\t\t\t\t\t\tname?: string | undefined;\n\t\t\t\t\t\timage?: string | undefined | null;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\topenapi: {\n\t\t\t\t\toperationId: \"updateUser\",\n\t\t\t\t\tdescription: \"Update the current user\",\n\t\t\t\t\trequestBody: {\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"The image of the user\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tresponses: {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tdescription: \"Success\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tasync (ctx) => {\n\t\t\tconst body = ctx.body as {\n\t\t\t\tname?: string | undefined;\n\t\t\t\timage?: string | undefined;\n\t\t\t\t[key: string]: any;\n\t\t\t};\n\n\t\t\tif (typeof body !== \"object\" || Array.isArray(body)) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"Body must be an object\",\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (body.email) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.EMAIL_CAN_NOT_BE_UPDATED,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst { name, image, ...rest } = body;\n\t\t\tconst session = ctx.context.session;\n\t\t\tconst additionalFields = parseUserInput(\n\t\t\t\tctx.context.options,\n\t\t\t\trest,\n\t\t\t\t\"update\",\n\t\t\t);\n\t\t\tif (\n\t\t\t\timage === undefined &&\n\t\t\t\tname === undefined &&\n\t\t\t\tObject.keys(additionalFields).length === 0\n\t\t\t) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: \"No fields to update\",\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst user = await ctx.context.internalAdapter.updateUser(\n\t\t\t\tsession.user.id,\n\t\t\t\t{\n\t\t\t\t\tname,\n\t\t\t\t\timage,\n\t\t\t\t\t...additionalFields,\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst updatedUser = user ?? {\n\t\t\t\t...session.user,\n\t\t\t\t...(name !== undefined && { name }),\n\t\t\t\t...(image !== undefined && { image }),\n\t\t\t\t...additionalFields,\n\t\t\t};\n\t\t\t/**\n\t\t\t * Update the session cookie with the new user data\n\t\t\t */\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: session.session,\n\t\t\t\tuser: updatedUser,\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t},\n\t);\n\nexport const changePassword = createAuthEndpoint(\n\t\"/change-password\",\n\t{\n\t\tmethod: \"POST\",\n\t\toperationId: \"changePassword\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The new password to set\n\t\t\t */\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * The current password of the user\n\t\t\t */\n\t\t\tcurrentPassword: z.string().meta({\n\t\t\t\tdescription: \"The current password is required\",\n\t\t\t}),\n\t\t\t/**\n\t\t\t * revoke all sessions that are not the\n\t\t\t * current one logged in by the user\n\t\t\t */\n\t\t\trevokeOtherSessions: z\n\t\t\t\t.boolean()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"Must be a boolean value\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"changePassword\",\n\t\t\t\tdescription: \"Change the password of the user\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Password successfully changed\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true, // Only present if revokeOtherSessions is true\n\t\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\t\"New session token if other sessions were revoked\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\t\t\tid: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The unique identifier of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temail: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The email address of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The name of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\timage: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"uri\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"The profile image URL of the user\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\temailVerified: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"Whether the email has been verified\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tcreatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was created\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedAt: {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tformat: \"date-time\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescription: \"When the user was last updated\",\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequired: [\n\t\t\t\t\t\t\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"email\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"name\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"emailVerified\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"createdAt\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"updatedAt\",\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"user\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tconst { newPassword, currentPassword, revokeOtherSessions } = ctx.body;\n\t\tconst session = ctx.context.session;\n\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\tif (newPassword.length < minPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\n\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\n\t\tif (newPassword.length > maxPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst account = accounts.find(\n\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t);\n\t\tif (!account || !account.password) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND,\n\t\t\t});\n\t\t}\n\t\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\t\tconst verify = await ctx.context.password.verify({\n\t\t\thash: account.password,\n\t\t\tpassword: currentPassword,\n\t\t});\n\t\tif (!verify) {\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t});\n\t\t}\n\t\tawait ctx.context.internalAdapter.updateAccount(account.id, {\n\t\t\tpassword: passwordHash,\n\t\t});\n\t\tlet token = null;\n\t\tif (revokeOtherSessions) {\n\t\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\t\tconst newSession = await ctx.context.internalAdapter.createSession(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\t\t\tif (!newSession) {\n\t\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_SESSION,\n\t\t\t\t});\n\t\t\t}\n\t\t\t// set the new session cookie\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: newSession,\n\t\t\t\tuser: session.user,\n\t\t\t});\n\t\t\ttoken = newSession.token;\n\t\t}\n\n\t\treturn ctx.json({\n\t\t\ttoken,\n\t\t\tuser: parseUserOutput(ctx.context.options, session.user),\n\t\t});\n\t},\n);\n\nexport const setPassword = createAuthEndpoint(\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The new password to set\n\t\t\t */\n\t\t\tnewPassword: z.string().meta({\n\t\t\t\tdescription: \"The new password to set is required\",\n\t\t\t}),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t},\n\tasync (ctx) => {\n\t\tconst { newPassword } = ctx.body;\n\t\tconst session = ctx.context.session;\n\t\tconst minPasswordLength = ctx.context.password.config.minPasswordLength;\n\t\tif (newPassword.length < minPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too short\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,\n\t\t\t});\n\t\t}\n\n\t\tconst maxPasswordLength = ctx.context.password.config.maxPasswordLength;\n\n\t\tif (newPassword.length > maxPasswordLength) {\n\t\t\tctx.context.logger.error(\"Password is too long\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.PASSWORD_TOO_LONG,\n\t\t\t});\n\t\t}\n\n\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\tsession.user.id,\n\t\t);\n\t\tconst account = accounts.find(\n\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t);\n\t\tconst passwordHash = await ctx.context.password.hash(newPassword);\n\t\tif (!account) {\n\t\t\tawait ctx.context.internalAdapter.linkAccount({\n\t\t\t\tuserId: session.user.id,\n\t\t\t\tproviderId: \"credential\",\n\t\t\t\taccountId: session.user.id,\n\t\t\t\tpassword: passwordHash,\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\tmessage: \"user already has a password\",\n\t\t});\n\t},\n);\n\nexport const deleteUser = createAuthEndpoint(\n\t\"/delete-user\",\n\t{\n\t\tmethod: \"POST\",\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tbody: z.object({\n\t\t\t/**\n\t\t\t * The callback URL to redirect to after the user is deleted\n\t\t\t * this is only used on delete user callback\n\t\t\t */\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The callback URL to redirect to after the user is deleted\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The password of the user. If the password isn't provided, session freshness\n\t\t\t * will be checked.\n\t\t\t */\n\t\t\tpassword: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t\"The password of the user is required to delete the user\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t\t/**\n\t\t\t * The token to delete the user. If the token is provided, the user will be deleted\n\t\t\t */\n\t\t\ttoken: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The token to delete the user is required\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"deleteUser\",\n\t\t\t\tdescription: \"Delete the user\",\n\t\t\t\trequestBody: {\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\tcallbackURL: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The callback URL to redirect to after the user is deleted\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpassword: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t\t\t\"The user's password. Required if session is not fresh\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttoken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tdescription: \"The deletion verification token\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"User deletion processed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the operation was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"User deleted\", \"Verification email sent\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Status message of the deletion process\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"success\", \"message\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Delete user is disabled. Enable it in the options\",\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\");\n\t\t}\n\t\tconst session = ctx.context.session;\n\n\t\tif (ctx.body.password) {\n\t\t\tconst accounts = await ctx.context.internalAdapter.findAccounts(\n\t\t\t\tsession.user.id,\n\t\t\t);\n\t\t\tconst account = accounts.find(\n\t\t\t\t(account) => account.providerId === \"credential\" && account.password,\n\t\t\t);\n\t\t\tif (!account || !account.password) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.CREDENTIAL_ACCOUNT_NOT_FOUND,\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst verify = await ctx.context.password.verify({\n\t\t\t\thash: account.password,\n\t\t\t\tpassword: ctx.body.password,\n\t\t\t});\n\t\t\tif (!verify) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_PASSWORD,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (ctx.body.token) {\n\t\t\t//@ts-expect-error\n\t\t\tawait deleteUserCallback({\n\t\t\t\t...ctx,\n\t\t\t\tquery: {\n\t\t\t\t\ttoken: ctx.body.token,\n\t\t\t\t},\n\t\t\t});\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"User deleted\",\n\t\t\t});\n\t\t}\n\n\t\tif (ctx.context.options.user.deleteUser?.sendDeleteAccountVerification) {\n\t\t\tconst token = generateRandomString(32, \"0-9\", \"a-z\");\n\t\t\tawait ctx.context.internalAdapter.createVerificationValue({\n\t\t\t\tvalue: session.user.id,\n\t\t\t\tidentifier: `delete-account-${token}`,\n\t\t\t\texpiresAt: new Date(\n\t\t\t\t\tDate.now() +\n\t\t\t\t\t\t(ctx.context.options.user.deleteUser?.deleteTokenExpiresIn ||\n\t\t\t\t\t\t\t60 * 60 * 24) *\n\t\t\t\t\t\t\t1000,\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst url = `${\n\t\t\t\tctx.context.baseURL\n\t\t\t}/delete-user/callback?token=${token}&callbackURL=${\n\t\t\t\tctx.body.callbackURL || \"/\"\n\t\t\t}`;\n\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\tctx.context.options.user.deleteUser.sendDeleteAccountVerification(\n\t\t\t\t\t{\n\t\t\t\t\t\tuser: session.user,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t},\n\t\t\t\t\tctx.request,\n\t\t\t\t),\n\t\t\t);\n\t\t\treturn ctx.json({\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: \"Verification email sent\",\n\t\t\t});\n\t\t}\n\n\t\tif (!ctx.body.password && ctx.context.sessionConfig.freshAge !== 0) {\n\t\t\tconst currentAge = new Date(session.session.createdAt).getTime();\n\t\t\tconst freshAge = ctx.context.sessionConfig.freshAge * 1000;\n\t\t\tconst now = Date.now();\n\t\t\tif (now - currentAge > freshAge * 1000) {\n\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\t\tmessage: BASE_ERROR_CODES.SESSION_EXPIRED,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\t\tif (beforeDelete) {\n\t\t\tawait beforeDelete(session.user, ctx.request);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\tdeleteSessionCookie(ctx);\n\t\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\t\tif (afterDelete) {\n\t\t\tawait afterDelete(session.user, ctx.request);\n\t\t}\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"User deleted\",\n\t\t});\n\t},\n);\n\nexport const deleteUserCallback = createAuthEndpoint(\n\t\"/delete-user/callback\",\n\t{\n\t\tmethod: \"GET\",\n\t\tquery: z.object({\n\t\t\ttoken: z.string().meta({\n\t\t\t\tdescription: \"The token to verify the deletion request\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after deletion\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [originCheck((ctx) => ctx.query.callbackURL)],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\tdescription:\n\t\t\t\t\t\"Callback to complete user deletion with verification token\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"User successfully deleted\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tsuccess: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the deletion was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"User deleted\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Confirmation message\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"success\", \"message\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.deleteUser?.enabled) {\n\t\t\tctx.context.logger.error(\n\t\t\t\t\"Delete user is disabled. Enable it in the options\",\n\t\t\t);\n\t\t\tthrow new APIError(\"NOT_FOUND\");\n\t\t}\n\t\tconst session = await getSessionFromCtx(ctx);\n\t\tif (!session) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.FAILED_TO_GET_USER_INFO,\n\t\t\t});\n\t\t}\n\t\tconst token = await ctx.context.internalAdapter.findVerificationValue(\n\t\t\t`delete-account-${ctx.query.token}`,\n\t\t);\n\t\tif (!token || token.expiresAt < new Date()) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tif (token.value !== session.user.id) {\n\t\t\tthrow new APIError(\"NOT_FOUND\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.INVALID_TOKEN,\n\t\t\t});\n\t\t}\n\t\tconst beforeDelete = ctx.context.options.user.deleteUser?.beforeDelete;\n\t\tif (beforeDelete) {\n\t\t\tawait beforeDelete(session.user, ctx.request);\n\t\t}\n\t\tawait ctx.context.internalAdapter.deleteUser(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteSessions(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteAccounts(session.user.id);\n\t\tawait ctx.context.internalAdapter.deleteVerificationValue(token.id);\n\n\t\tdeleteSessionCookie(ctx);\n\n\t\tconst afterDelete = ctx.context.options.user.deleteUser?.afterDelete;\n\t\tif (afterDelete) {\n\t\t\tawait afterDelete(session.user, ctx.request);\n\t\t}\n\t\tif (ctx.query.callbackURL) {\n\t\t\tthrow ctx.redirect(ctx.query.callbackURL || \"/\");\n\t\t}\n\t\treturn ctx.json({\n\t\t\tsuccess: true,\n\t\t\tmessage: \"User deleted\",\n\t\t});\n\t},\n);\n\nexport const changeEmail = createAuthEndpoint(\n\t\"/change-email\",\n\t{\n\t\tmethod: \"POST\",\n\t\tbody: z.object({\n\t\t\tnewEmail: z.email().meta({\n\t\t\t\tdescription:\n\t\t\t\t\t\"The new email address to set must be a valid email address\",\n\t\t\t}),\n\t\t\tcallbackURL: z\n\t\t\t\t.string()\n\t\t\t\t.meta({\n\t\t\t\t\tdescription: \"The URL to redirect to after email verification\",\n\t\t\t\t})\n\t\t\t\t.optional(),\n\t\t}),\n\t\tuse: [sensitiveSessionMiddleware],\n\t\tmetadata: {\n\t\t\topenapi: {\n\t\t\t\toperationId: \"changeEmail\",\n\t\t\t\tresponses: {\n\t\t\t\t\t\"200\": {\n\t\t\t\t\t\tdescription: \"Email change request processed successfully\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\t\t\t$ref: \"#/components/schemas/User\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Indicates if the request was successful\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\tenum: [\"Email updated\", \"Verification email sent\"],\n\t\t\t\t\t\t\t\t\t\t\tdescription: \"Status message of the email change process\",\n\t\t\t\t\t\t\t\t\t\t\tnullable: true,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trequired: [\"status\"],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"422\": {\n\t\t\t\t\t\tdescription: \"Unprocessable Entity. Email already exists\",\n\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tschema: {\n\t\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\tasync (ctx) => {\n\t\tif (!ctx.context.options.user?.changeEmail?.enabled) {\n\t\t\tctx.context.logger.error(\"Change email is disabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Change email is disabled\",\n\t\t\t});\n\t\t}\n\n\t\tconst newEmail = ctx.body.newEmail.toLowerCase();\n\n\t\tif (newEmail === ctx.context.session.user.email) {\n\t\t\tctx.context.logger.error(\"Email is the same\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Email is the same\",\n\t\t\t});\n\t\t}\n\t\tconst existingUser =\n\t\t\tawait ctx.context.internalAdapter.findUserByEmail(newEmail);\n\t\tif (existingUser) {\n\t\t\tctx.context.logger.error(\"Email already exists\");\n\t\t\tthrow new APIError(\"UNPROCESSABLE_ENTITY\", {\n\t\t\t\tmessage: BASE_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * If the email is not verified, we can update the email if the option is enabled\n\t\t */\n\t\tif (\n\t\t\tctx.context.session.user.emailVerified !== true &&\n\t\t\tctx.context.options.user.changeEmail.updateEmailWithoutVerification\n\t\t) {\n\t\t\tawait ctx.context.internalAdapter.updateUserByEmail(\n\t\t\t\tctx.context.session.user.email,\n\t\t\t\t{\n\t\t\t\t\temail: newEmail,\n\t\t\t\t},\n\t\t\t);\n\t\t\tawait setSessionCookie(ctx, {\n\t\t\t\tsession: ctx.context.session.session,\n\t\t\t\tuser: {\n\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\temail: newEmail,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\t\tctx.context.secret,\n\t\t\t\t\tnewEmail,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t);\n\t\t\t\tconst url = `${\n\t\t\t\t\tctx.context.baseURL\n\t\t\t\t}/verify-email?token=${token}&callbackURL=${\n\t\t\t\t\tctx.body.callbackURL || \"/\"\n\t\t\t\t}`;\n\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\t\t\t\temail: newEmail,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tctx.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * If the email is verified, we need to send a verification email\n\t\t */\n\t\tconst sendConfirmationToOldEmail =\n\t\t\tctx.context.session.user.emailVerified &&\n\t\t\t(ctx.context.options.user.changeEmail.sendChangeEmailConfirmation ||\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailVerification);\n\n\t\tif (sendConfirmationToOldEmail) {\n\t\t\tconst token = await createEmailVerificationToken(\n\t\t\t\tctx.context.secret,\n\t\t\t\tctx.context.session.user.email,\n\t\t\t\tnewEmail,\n\t\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t\t{\n\t\t\t\t\trequestType: \"change-email-confirmation\",\n\t\t\t\t},\n\t\t\t);\n\t\t\tconst url = `${\n\t\t\t\tctx.context.baseURL\n\t\t\t}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\t\tconst sendFn =\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailConfirmation ||\n\t\t\t\tctx.context.options.user.changeEmail.sendChangeEmailVerification;\n\t\t\tif (sendFn) {\n\t\t\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\t\t\tsendFn(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuser: ctx.context.session.user,\n\t\t\t\t\t\t\tnewEmail: newEmail,\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\ttoken,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tctx.request,\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn ctx.json({\n\t\t\t\tstatus: true,\n\t\t\t});\n\t\t}\n\n\t\tif (!ctx.context.options.emailVerification?.sendVerificationEmail) {\n\t\t\tctx.context.logger.error(\"Verification email isn't enabled.\");\n\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n\t\t\t\tmessage: \"Verification email isn't enabled\",\n\t\t\t});\n\t\t}\n\n\t\tconst token = await createEmailVerificationToken(\n\t\t\tctx.context.secret,\n\t\t\tctx.context.session.user.email,\n\t\t\tnewEmail,\n\t\t\tctx.context.options.emailVerification?.expiresIn,\n\t\t\t{\n\t\t\t\trequestType: \"change-email-verification\",\n\t\t\t},\n\t\t);\n\t\tconst url = `${\n\t\t\tctx.context.baseURL\n\t\t}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || \"/\"}`;\n\t\tawait ctx.context.runInBackgroundOrAwait(\n\t\t\tctx.context.options.emailVerification.sendVerificationEmail(\n\t\t\t\t{\n\t\t\t\t\tuser: {\n\t\t\t\t\t\t...ctx.context.session.user,\n\t\t\t\t\t\temail: newEmail,\n\t\t\t\t\t},\n\t\t\t\t\turl,\n\t\t\t\t\ttoken,\n\t\t\t\t},\n\t\t\t\tctx.request,\n\t\t\t),\n\t\t);\n\t\treturn ctx.json({\n\t\t\tstatus: true,\n\t\t});\n\t},\n);\n"],"names":["account","token","url"],"mappings":"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"}},
    {"offset": {"line": 8046, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/api/routes/index.mjs"],"sourcesContent":["import { freshSessionMiddleware, getSession, getSessionFromCtx, listSessions, requestOnlySessionMiddleware, revokeOtherSessions, revokeSession, revokeSessions, sensitiveSessionMiddleware, sessionMiddleware } from \"./session.mjs\";\nimport { accountInfo, getAccessToken, linkSocialAccount, listUserAccounts, refreshToken, unlinkAccount } from \"./account.mjs\";\nimport { callbackOAuth } from \"./callback.mjs\";\nimport { createEmailVerificationToken, sendVerificationEmail, sendVerificationEmailFn, verifyEmail } from \"./email-verification.mjs\";\nimport { error } from \"./error.mjs\";\nimport { ok } from \"./ok.mjs\";\nimport { requestPasswordReset, requestPasswordResetCallback, resetPassword, verifyPassword } from \"./password.mjs\";\nimport { signInEmail, signInSocial } from \"./sign-in.mjs\";\nimport { signOut } from \"./sign-out.mjs\";\nimport { signUpEmail } from \"./sign-up.mjs\";\nimport { changeEmail, changePassword, deleteUser, deleteUserCallback, setPassword, updateUser } from \"./update-user.mjs\";\n\nexport {  };"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 8074, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/to-auth-endpoints.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/to-auth-endpoints.ts"],"sourcesContent":["import type { AuthContext, HookEndpointContext } from \"@better-auth/core\";\nimport type { AuthEndpoint, AuthMiddleware } from \"@better-auth/core/api\";\nimport {\n\thasRequestState,\n\trunWithEndpointContext,\n\trunWithRequestState,\n} from \"@better-auth/core/context\";\nimport { shouldPublishLog } from \"@better-auth/core/env\";\nimport type {\n\tEndpointContext,\n\tEndpointOptions,\n\tInputContext,\n} from \"better-call\";\nimport { APIError, toResponse } from \"better-call\";\nimport { createDefu } from \"defu\";\n\ntype InternalContext = Partial<\n\tInputContext<string, any> & EndpointContext<string, any>\n> & {\n\tpath: string;\n\tasResponse?: boolean | undefined;\n\tcontext: AuthContext & {\n\t\tlogger: AuthContext[\"logger\"];\n\t\treturned?: unknown | undefined;\n\t\tresponseHeaders?: Headers | undefined;\n\t};\n};\n\nconst defuReplaceArrays = createDefu((obj, key, value) => {\n\tif (Array.isArray(obj[key]) && Array.isArray(value)) {\n\t\tobj[key] = value;\n\t\treturn true;\n\t}\n});\n\nconst hooksSourceWeakMap = new WeakMap<\n\tAuthMiddleware,\n\t`user` | `plugin:${string}`\n>();\n\ntype UserInputContext = Partial<\n\tInputContext<string, any> & EndpointContext<string, any>\n>;\n\nexport function toAuthEndpoints<\n\tconst E extends Record<\n\t\tstring,\n\t\tOmit<AuthEndpoint<string, EndpointOptions, any>, \"wrap\">\n\t>,\n>(endpoints: E, ctx: AuthContext | Promise<AuthContext>): E {\n\tconst api: Record<\n\t\tstring,\n\t\t((\n\t\t\tcontext: EndpointContext<string, any> & InputContext<string, any>,\n\t\t) => Promise<any>) & {\n\t\t\tpath?: string | undefined;\n\t\t\toptions?: EndpointOptions | undefined;\n\t\t}\n\t> = {};\n\n\tfor (const [key, endpoint] of Object.entries(endpoints)) {\n\t\tapi[key] = async (context?: UserInputContext) => {\n\t\t\tconst run = async () => {\n\t\t\t\tconst authContext = await ctx;\n\t\t\t\tlet internalContext: InternalContext = {\n\t\t\t\t\t...context,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\t...authContext,\n\t\t\t\t\t\treturned: undefined,\n\t\t\t\t\t\tresponseHeaders: undefined,\n\t\t\t\t\t\tsession: null,\n\t\t\t\t\t},\n\t\t\t\t\tpath: endpoint.path,\n\t\t\t\t\theaders: context?.headers ? new Headers(context?.headers) : undefined,\n\t\t\t\t};\n\t\t\t\treturn runWithEndpointContext(internalContext, async () => {\n\t\t\t\t\tconst { beforeHooks, afterHooks } = getHooks(authContext);\n\t\t\t\t\tconst before = await runBeforeHooks(internalContext, beforeHooks);\n\t\t\t\t\t/**\n\t\t\t\t\t * If `before.context` is returned, it should\n\t\t\t\t\t * get merged with the original context\n\t\t\t\t\t */\n\t\t\t\t\tif (\n\t\t\t\t\t\t\"context\" in before &&\n\t\t\t\t\t\tbefore.context &&\n\t\t\t\t\t\ttypeof before.context === \"object\"\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst { headers, ...rest } = before.context as {\n\t\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Headers should be merged differently\n\t\t\t\t\t\t * so the hook doesn't override the whole\n\t\t\t\t\t\t * header\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (headers) {\n\t\t\t\t\t\t\theaders.forEach((value, key) => {\n\t\t\t\t\t\t\t\t(internalContext.headers as Headers).set(key, value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinternalContext = defuReplaceArrays(rest, internalContext);\n\t\t\t\t\t} else if (before) {\n\t\t\t\t\t\t/* Return before hook response if it's anything other than a context return */\n\t\t\t\t\t\treturn context?.asResponse\n\t\t\t\t\t\t\t? toResponse(before, {\n\t\t\t\t\t\t\t\t\theaders: context?.headers,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: context?.returnHeaders\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\theaders: context?.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: before,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: before;\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalContext.asResponse = false;\n\t\t\t\t\tinternalContext.returnHeaders = true;\n\t\t\t\t\tinternalContext.returnStatus = true;\n\t\t\t\t\tconst result = (await runWithEndpointContext(internalContext, () =>\n\t\t\t\t\t\t(endpoint as any)(internalContext as any),\n\t\t\t\t\t).catch((e: any) => {\n\t\t\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * API Errors from response are caught\n\t\t\t\t\t\t\t * and returned to hooks\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tresponse: e,\n\t\t\t\t\t\t\t\tstatus: e.statusCode,\n\t\t\t\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t})) as {\n\t\t\t\t\t\theaders: Headers;\n\t\t\t\t\t\tresponse: any;\n\t\t\t\t\t\tstatus: number;\n\t\t\t\t\t};\n\n\t\t\t\t\t//if response object is returned we skip after hooks and post processing\n\t\t\t\t\tif (result && result instanceof Response) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalContext.context.returned = result.response;\n\t\t\t\t\tinternalContext.context.responseHeaders = result.headers;\n\n\t\t\t\t\tconst after = await runAfterHooks(internalContext, afterHooks);\n\n\t\t\t\t\tif (after.response) {\n\t\t\t\t\t\tresult.response = after.response;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresult.response instanceof APIError &&\n\t\t\t\t\t\tshouldPublishLog(authContext.logger.level, \"debug\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\tresult.response.stack = result.response.errorStack;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result.response instanceof APIError && !context?.asResponse) {\n\t\t\t\t\t\tthrow result.response;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst response = context?.asResponse\n\t\t\t\t\t\t? toResponse(result.response, {\n\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\tstatus: result.status,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: context?.returnHeaders\n\t\t\t\t\t\t\t? context?.returnStatus\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\t\t\t\t\tstatus: result.status,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\theaders: result.headers,\n\t\t\t\t\t\t\t\t\t\tresponse: result.response,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: context?.returnStatus\n\t\t\t\t\t\t\t\t? { response: result.response, status: result.status }\n\t\t\t\t\t\t\t\t: result.response;\n\t\t\t\t\treturn response;\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (await hasRequestState()) {\n\t\t\t\treturn run();\n\t\t\t} else {\n\t\t\t\tconst store = new WeakMap();\n\t\t\t\treturn runWithRequestState(store, run);\n\t\t\t}\n\t\t};\n\t\tapi[key].path = endpoint.path;\n\t\tapi[key].options = endpoint.options;\n\t}\n\treturn api as unknown as E;\n}\n\nasync function runBeforeHooks(\n\tcontext: InternalContext,\n\thooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[],\n) {\n\tlet modifiedContext: Partial<InternalContext> = {};\n\n\tfor (const hook of hooks) {\n\t\tlet matched = false;\n\t\ttry {\n\t\t\tmatched = hook.matcher(context);\n\t\t} catch (error) {\n\t\t\t// manually handle unexpected errors during hook matcher execution to prevent accidental exposure of internal details\n\t\t\t// Also provides debug information about which plugin the hook failed and error info\n\t\t\tconst hookSource = hooksSourceWeakMap.get(hook.handler) ?? \"unknown\";\n\t\t\tcontext.context.logger.error(\n\t\t\t\t`An error occurred during ${hookSource} hook matcher execution:`,\n\t\t\t\terror,\n\t\t\t);\n\t\t\tthrow new APIError(\"INTERNAL_SERVER_ERROR\", {\n\t\t\t\tmessage: `An error occurred during hook matcher execution. Check the logs for more details.`,\n\t\t\t});\n\t\t}\n\t\tif (matched) {\n\t\t\tconst result = await hook\n\t\t\t\t.handler({\n\t\t\t\t\t...context,\n\t\t\t\t\treturnHeaders: false,\n\t\t\t\t})\n\t\t\t\t.catch((e: unknown) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\te instanceof APIError &&\n\t\t\t\t\t\tshouldPublishLog(context.context.logger.level, \"debug\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\te.stack = e.errorStack;\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t\tif (result && typeof result === \"object\") {\n\t\t\t\tif (\"context\" in result && typeof result.context === \"object\") {\n\t\t\t\t\tconst { headers, ...rest } =\n\t\t\t\t\t\tresult.context as Partial<InternalContext>;\n\t\t\t\t\tif (headers instanceof Headers) {\n\t\t\t\t\t\tif (modifiedContext.headers) {\n\t\t\t\t\t\t\theaders.forEach((value, key) => {\n\t\t\t\t\t\t\t\tmodifiedContext.headers?.set(key, value);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmodifiedContext.headers = headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmodifiedContext = defuReplaceArrays(rest, modifiedContext);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\treturn { context: modifiedContext };\n}\n\nasync function runAfterHooks(\n\tcontext: InternalContext,\n\thooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[],\n) {\n\tfor (const hook of hooks) {\n\t\tif (hook.matcher(context)) {\n\t\t\tconst result = (await hook.handler(context).catch((e) => {\n\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\tif (shouldPublishLog(context.context.logger.level, \"debug\")) {\n\t\t\t\t\t\t// inherit stack from errorStack if debug mode is enabled\n\t\t\t\t\t\te.stack = e.errorStack;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tresponse: e,\n\t\t\t\t\t\theaders: e.headers ? new Headers(e.headers) : null,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t})) as {\n\t\t\t\tresponse: any;\n\t\t\t\theaders: Headers;\n\t\t\t};\n\t\t\tif (result.headers) {\n\t\t\t\tresult.headers.forEach((value, key) => {\n\t\t\t\t\tif (!context.context.responseHeaders) {\n\t\t\t\t\t\tcontext.context.responseHeaders = new Headers({\n\t\t\t\t\t\t\t[key]: value,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (key.toLowerCase() === \"set-cookie\") {\n\t\t\t\t\t\t\tcontext.context.responseHeaders.append(key, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.context.responseHeaders.set(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (result.response) {\n\t\t\t\tcontext.context.returned = result.response;\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tresponse: context.context.returned,\n\t\theaders: context.context.responseHeaders,\n\t};\n}\n\nfunction getHooks(authContext: AuthContext) {\n\tconst plugins = authContext.options.plugins || [];\n\tconst beforeHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[] = [];\n\tconst afterHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[] = [];\n\tconst beforeHookHandler = authContext.options.hooks?.before;\n\tif (beforeHookHandler) {\n\t\thooksSourceWeakMap.set(beforeHookHandler, \"user\");\n\t\tbeforeHooks.push({\n\t\t\tmatcher: () => true,\n\t\t\thandler: beforeHookHandler,\n\t\t});\n\t}\n\tconst afterHookHandler = authContext.options.hooks?.after;\n\tif (afterHookHandler) {\n\t\thooksSourceWeakMap.set(afterHookHandler, \"user\");\n\t\tafterHooks.push({\n\t\t\tmatcher: () => true,\n\t\t\thandler: afterHookHandler,\n\t\t});\n\t}\n\tconst pluginBeforeHooks = plugins\n\t\t.filter((plugin) => plugin.hooks?.before)\n\t\t.map((plugin) => plugin.hooks?.before!)\n\t\t.flat();\n\tconst pluginAfterHooks = plugins\n\t\t.filter((plugin) => plugin.hooks?.after)\n\t\t.map((plugin) => plugin.hooks?.after!)\n\t\t.flat();\n\n\t/**\n\t * Add plugin added hooks at last\n\t */\n\tif (pluginBeforeHooks.length) beforeHooks.push(...pluginBeforeHooks);\n\tif (pluginAfterHooks.length) afterHooks.push(...pluginAfterHooks);\n\n\treturn {\n\t\tbeforeHooks,\n\t\tafterHooks,\n\t};\n}\n"],"names":["api: Record<\n\t\tstring,\n\t\t((\n\t\t\tcontext: EndpointContext<string, any> & InputContext<string, any>,\n\t\t) => Promise<any>) & {\n\t\t\tpath?: string | undefined;\n\t\t\toptions?: EndpointOptions | undefined;\n\t\t}\n\t>","internalContext: InternalContext","key","modifiedContext: Partial<InternalContext>","beforeHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[]","afterHooks: {\n\t\tmatcher: (context: HookEndpointContext) => boolean;\n\t\thandler: AuthMiddleware;\n\t}[]"],"mappings":"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"}},
    {"offset": {"line": 8285, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/api/index.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/api/index.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tAwaitable,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { logger } from \"@better-auth/core/env\";\nimport { normalizePathname } from \"@better-auth/core/utils\";\nimport type { Endpoint, Middleware } from \"better-call\";\nimport { APIError, createRouter } from \"better-call\";\nimport type { UnionToIntersection } from \"../types/helper\";\nimport { originCheckMiddleware } from \"./middlewares\";\nimport { onRequestRateLimit } from \"./rate-limiter\";\nimport {\n\taccountInfo,\n\tcallbackOAuth,\n\tchangeEmail,\n\tchangePassword,\n\tdeleteUser,\n\tdeleteUserCallback,\n\terror,\n\tgetAccessToken,\n\tgetSession,\n\tlinkSocialAccount,\n\tlistSessions,\n\tlistUserAccounts,\n\tok,\n\trefreshToken,\n\trequestPasswordReset,\n\trequestPasswordResetCallback,\n\tresetPassword,\n\trevokeOtherSessions,\n\trevokeSession,\n\trevokeSessions,\n\tsendVerificationEmail,\n\tsetPassword,\n\tsignInEmail,\n\tsignInSocial,\n\tsignOut,\n\tsignUpEmail,\n\tunlinkAccount,\n\tupdateUser,\n\tverifyEmail,\n\tverifyPassword,\n} from \"./routes\";\nimport { toAuthEndpoints } from \"./to-auth-endpoints\";\n\nexport function checkEndpointConflicts(\n\toptions: BetterAuthOptions,\n\tlogger: InternalLogger,\n) {\n\tconst endpointRegistry = new Map<\n\t\tstring,\n\t\t{ pluginId: string; endpointKey: string; methods: string[] }[]\n\t>();\n\n\toptions.plugins?.forEach((plugin) => {\n\t\tif (plugin.endpoints) {\n\t\t\tfor (const [key, endpoint] of Object.entries(plugin.endpoints)) {\n\t\t\t\tif (\n\t\t\t\t\tendpoint &&\n\t\t\t\t\t\"path\" in endpoint &&\n\t\t\t\t\ttypeof endpoint.path === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconst path = endpoint.path;\n\t\t\t\t\tlet methods: string[] = [];\n\t\t\t\t\tif (endpoint.options && \"method\" in endpoint.options) {\n\t\t\t\t\t\tif (Array.isArray(endpoint.options.method)) {\n\t\t\t\t\t\t\tmethods = endpoint.options.method;\n\t\t\t\t\t\t} else if (typeof endpoint.options.method === \"string\") {\n\t\t\t\t\t\t\tmethods = [endpoint.options.method];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (methods.length === 0) {\n\t\t\t\t\t\tmethods = [\"*\"];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!endpointRegistry.has(path)) {\n\t\t\t\t\t\tendpointRegistry.set(path, []);\n\t\t\t\t\t}\n\t\t\t\t\tendpointRegistry.get(path)!.push({\n\t\t\t\t\t\tpluginId: plugin.id,\n\t\t\t\t\t\tendpointKey: key,\n\t\t\t\t\t\tmethods,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tconst conflicts: {\n\t\tpath: string;\n\t\tplugins: string[];\n\t\tconflictingMethods: string[];\n\t}[] = [];\n\tfor (const [path, entries] of endpointRegistry.entries()) {\n\t\tif (entries.length > 1) {\n\t\t\tconst methodMap = new Map<string, string[]>();\n\t\t\tlet hasConflict = false;\n\n\t\t\tfor (const entry of entries) {\n\t\t\t\tfor (const method of entry.methods) {\n\t\t\t\t\tif (!methodMap.has(method)) {\n\t\t\t\t\t\tmethodMap.set(method, []);\n\t\t\t\t\t}\n\t\t\t\t\tmethodMap.get(method)!.push(entry.pluginId);\n\n\t\t\t\t\tif (methodMap.get(method)!.length > 1) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"*\" && entries.length > 1) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t} else if (method !== \"*\" && methodMap.has(\"*\")) {\n\t\t\t\t\t\thasConflict = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasConflict) {\n\t\t\t\tconst uniquePlugins = [...new Set(entries.map((e) => e.pluginId))];\n\t\t\t\tconst conflictingMethods: string[] = [];\n\n\t\t\t\tfor (const [method, plugins] of methodMap.entries()) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tplugins.length > 1 ||\n\t\t\t\t\t\t(method === \"*\" && entries.length > 1) ||\n\t\t\t\t\t\t(method !== \"*\" && methodMap.has(\"*\"))\n\t\t\t\t\t) {\n\t\t\t\t\t\tconflictingMethods.push(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconflicts.push({\n\t\t\t\t\tpath,\n\t\t\t\t\tplugins: uniquePlugins,\n\t\t\t\t\tconflictingMethods,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tif (conflicts.length > 0) {\n\t\tconst conflictMessages = conflicts\n\t\t\t.map(\n\t\t\t\t(conflict) =>\n\t\t\t\t\t`  - \"${conflict.path}\" [${conflict.conflictingMethods.join(\", \")}] used by plugins: ${conflict.plugins.join(\", \")}`,\n\t\t\t)\n\t\t\t.join(\"\\n\");\n\t\tlogger.error(\n\t\t\t`Endpoint path conflicts detected! Multiple plugins are trying to use the same endpoint paths with conflicting HTTP methods:\n${conflictMessages}\n\nTo resolve this, you can:\n\t1. Use only one of the conflicting plugins\n\t2. Configure the plugins to use different paths (if supported)\n\t3. Ensure plugins use different HTTP methods for the same path\n`,\n\t\t);\n\t}\n}\n\nexport function getEndpoints<Option extends BetterAuthOptions>(\n\tctx: Awaitable<AuthContext>,\n\toptions: Option,\n) {\n\tconst pluginEndpoints =\n\t\toptions.plugins?.reduce<Record<string, Endpoint>>((acc, plugin) => {\n\t\t\treturn {\n\t\t\t\t...acc,\n\t\t\t\t...plugin.endpoints,\n\t\t\t};\n\t\t}, {}) ?? {};\n\n\ttype PluginEndpoint = UnionToIntersection<\n\t\tOption[\"plugins\"] extends Array<infer T>\n\t\t\t? T extends BetterAuthPlugin\n\t\t\t\t? T extends {\n\t\t\t\t\t\tendpoints: infer E;\n\t\t\t\t\t}\n\t\t\t\t\t? E\n\t\t\t\t\t: {}\n\t\t\t\t: {}\n\t\t\t: {}\n\t>;\n\n\tconst middlewares =\n\t\toptions.plugins\n\t\t\t?.map((plugin) =>\n\t\t\t\tplugin.middlewares?.map((m) => {\n\t\t\t\t\tconst middleware = (async (context: any) => {\n\t\t\t\t\t\tconst authContext = await ctx;\n\t\t\t\t\t\treturn m.middleware({\n\t\t\t\t\t\t\t...context,\n\t\t\t\t\t\t\tcontext: {\n\t\t\t\t\t\t\t\t...authContext,\n\t\t\t\t\t\t\t\t...context.context,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t}) as Middleware;\n\t\t\t\t\tmiddleware.options = m.middleware.options;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpath: m.path,\n\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.filter((plugin) => plugin !== undefined)\n\t\t\t.flat() || [];\n\n\tconst baseEndpoints = {\n\t\tsignInSocial: signInSocial<Option>(),\n\t\tcallbackOAuth,\n\t\tgetSession: getSession<Option>(),\n\t\tsignOut,\n\t\tsignUpEmail: signUpEmail<Option>(),\n\t\tsignInEmail: signInEmail<Option>(),\n\t\tresetPassword,\n\t\tverifyPassword,\n\t\tverifyEmail,\n\t\tsendVerificationEmail,\n\t\tchangeEmail,\n\t\tchangePassword,\n\t\tsetPassword,\n\t\tupdateUser: updateUser<Option>(),\n\t\tdeleteUser,\n\t\trequestPasswordReset,\n\t\trequestPasswordResetCallback,\n\t\tlistSessions: listSessions<Option>(),\n\t\trevokeSession,\n\t\trevokeSessions,\n\t\trevokeOtherSessions,\n\t\tlinkSocialAccount,\n\t\tlistUserAccounts,\n\t\tdeleteUserCallback,\n\t\tunlinkAccount,\n\t\trefreshToken,\n\t\tgetAccessToken,\n\t\taccountInfo,\n\t};\n\tconst endpoints = {\n\t\t...baseEndpoints,\n\t\t...pluginEndpoints,\n\t\tok,\n\t\terror,\n\t} as const;\n\tconst api = toAuthEndpoints(endpoints, ctx);\n\treturn {\n\t\tapi: api as typeof endpoints & PluginEndpoint,\n\t\tmiddlewares,\n\t};\n}\nexport const router = <Option extends BetterAuthOptions>(\n\tctx: AuthContext,\n\toptions: Option,\n) => {\n\tconst { api, middlewares } = getEndpoints(ctx, options);\n\tconst basePath = new URL(ctx.baseURL).pathname;\n\n\treturn createRouter(api, {\n\t\trouterContext: ctx,\n\t\topenapi: {\n\t\t\tdisabled: true,\n\t\t},\n\t\tbasePath,\n\t\trouterMiddleware: [\n\t\t\t{\n\t\t\t\tpath: \"/**\",\n\t\t\t\tmiddleware: originCheckMiddleware,\n\t\t\t},\n\t\t\t...middlewares,\n\t\t],\n\t\tallowedMediaTypes: [\"application/json\"],\n\t\tskipTrailingSlashes: options.advanced?.skipTrailingSlashes ?? false,\n\t\tasync onRequest(req) {\n\t\t\t//handle disabled paths\n\t\t\tconst disabledPaths = ctx.options.disabledPaths || [];\n\t\t\tconst normalizedPath = normalizePathname(req.url, basePath);\n\t\t\tif (disabledPaths.includes(normalizedPath)) {\n\t\t\t\treturn new Response(\"Not Found\", { status: 404 });\n\t\t\t}\n\n\t\t\tlet currentRequest = req;\n\t\t\tfor (const plugin of ctx.options.plugins || []) {\n\t\t\t\tif (plugin.onRequest) {\n\t\t\t\t\tconst response = await plugin.onRequest(currentRequest, ctx);\n\t\t\t\t\tif (response && \"response\" in response) {\n\t\t\t\t\t\treturn response.response;\n\t\t\t\t\t}\n\t\t\t\t\tif (response && \"request\" in response) {\n\t\t\t\t\t\tcurrentRequest = response.request;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst rateLimitResponse = await onRequestRateLimit(currentRequest, ctx);\n\t\t\tif (rateLimitResponse) {\n\t\t\t\treturn rateLimitResponse;\n\t\t\t}\n\n\t\t\treturn currentRequest;\n\t\t},\n\t\tasync onResponse(res) {\n\t\t\tfor (const plugin of ctx.options.plugins || []) {\n\t\t\t\tif (plugin.onResponse) {\n\t\t\t\t\tconst response = await plugin.onResponse(res, ctx);\n\t\t\t\t\tif (response) {\n\t\t\t\t\t\treturn response.response;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\tonError(e) {\n\t\t\tif (e instanceof APIError && e.status === \"FOUND\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (options.onAPIError?.throw) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (options.onAPIError?.onError) {\n\t\t\t\toptions.onAPIError.onError(e, ctx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst optLogLevel = options.logger?.level;\n\t\t\tconst log =\n\t\t\t\toptLogLevel === \"error\" ||\n\t\t\t\toptLogLevel === \"warn\" ||\n\t\t\t\toptLogLevel === \"debug\"\n\t\t\t\t\t? logger\n\t\t\t\t\t: undefined;\n\t\t\tif (options.logger?.disabled !== true) {\n\t\t\t\tif (\n\t\t\t\t\te &&\n\t\t\t\t\ttypeof e === \"object\" &&\n\t\t\t\t\t\"message\" in e &&\n\t\t\t\t\ttypeof e.message === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\te.message.includes(\"no column\") ||\n\t\t\t\t\t\te.message.includes(\"column\") ||\n\t\t\t\t\t\te.message.includes(\"relation\") ||\n\t\t\t\t\t\te.message.includes(\"table\") ||\n\t\t\t\t\t\te.message.includes(\"does not exist\")\n\t\t\t\t\t) {\n\t\t\t\t\t\tctx.logger?.error(e.message);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof APIError) {\n\t\t\t\t\tif (e.status === \"INTERNAL_SERVER_ERROR\") {\n\t\t\t\t\t\tctx.logger.error(e.status, e);\n\t\t\t\t\t}\n\t\t\t\t\tlog?.error(e.message);\n\t\t\t\t} else {\n\t\t\t\t\tctx.logger?.error(\n\t\t\t\t\t\te && typeof e === \"object\" && \"name\" in e ? (e.name as string) : \"\",\n\t\t\t\t\t\te,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t});\n};\n\nexport {\n\ttype AuthEndpoint,\n\ttype AuthMiddleware,\n\tcreateAuthEndpoint,\n\tcreateAuthMiddleware,\n\toptionsMiddleware,\n} from \"@better-auth/core/api\";\nexport { APIError } from \"better-call\";\nexport { getIp } from \"../utils/get-request-ip\";\nexport * from \"./middlewares\";\nexport * from \"./routes\";\n"],"names":["methods: string[]","conflicts: {\n\t\tpath: string;\n\t\tplugins: string[];\n\t\tconflictingMethods: string[];\n\t}[]","conflictingMethods: string[]","APIError"],"mappings":"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"}},
    {"offset": {"line": 8537, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/utils/constants.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/utils/constants.ts"],"sourcesContent":["export const DEFAULT_SECRET = \"better-auth-secret-12345678901234567890\";\n"],"names":[],"mappings":";;;;;AAAA,MAAa,iBAAiB"}},
    {"offset": {"line": 8549, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/context/helpers.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/context/helpers.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { env } from \"@better-auth/core/env\";\nimport { defu } from \"defu\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { getBaseURL } from \"../utils/url\";\n\nexport async function runPluginInit(ctx: AuthContext) {\n\tlet options = ctx.options;\n\tconst plugins = options.plugins || [];\n\tlet context: AuthContext = ctx;\n\tconst dbHooks: BetterAuthOptions[\"databaseHooks\"][] = [];\n\tfor (const plugin of plugins) {\n\t\tif (plugin.init) {\n\t\t\tconst initPromise = plugin.init(context);\n\t\t\tlet result: ReturnType<Required<BetterAuthPlugin>[\"init\"]>;\n\t\t\tif (isPromise(initPromise)) {\n\t\t\t\tresult = await initPromise;\n\t\t\t} else {\n\t\t\t\tresult = initPromise;\n\t\t\t}\n\t\t\tif (typeof result === \"object\") {\n\t\t\t\tif (result.options) {\n\t\t\t\t\tconst { databaseHooks, ...restOpts } = result.options;\n\t\t\t\t\tif (databaseHooks) {\n\t\t\t\t\t\tdbHooks.push(databaseHooks);\n\t\t\t\t\t}\n\t\t\t\t\toptions = defu(options, restOpts);\n\t\t\t\t}\n\t\t\t\tif (result.context) {\n\t\t\t\t\tcontext = {\n\t\t\t\t\t\t...context,\n\t\t\t\t\t\t...(result.context as Partial<AuthContext>),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Add the global database hooks last\n\tdbHooks.push(options.databaseHooks);\n\tcontext.internalAdapter = createInternalAdapter(context.adapter, {\n\t\toptions,\n\t\tlogger: context.logger,\n\t\thooks: dbHooks.filter((u) => u !== undefined),\n\t\tgenerateId: context.generateId,\n\t});\n\tcontext.options = options;\n\treturn { context };\n}\n\nexport function getInternalPlugins(options: BetterAuthOptions) {\n\tconst plugins: BetterAuthPlugin[] = [];\n\tif (options.advanced?.crossSubDomainCookies?.enabled) {\n\t\t// TODO: add internal plugin\n\t}\n\treturn plugins;\n}\n\nexport async function getTrustedOrigins(\n\toptions: BetterAuthOptions,\n\trequest?: Request,\n): Promise<string[]> {\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath, request);\n\tconst trustedOrigins: (string | undefined | null)[] = baseURL\n\t\t? [new URL(baseURL).origin]\n\t\t: [];\n\tif (options.trustedOrigins) {\n\t\tif (Array.isArray(options.trustedOrigins)) {\n\t\t\ttrustedOrigins.push(...options.trustedOrigins);\n\t\t}\n\t\tif (typeof options.trustedOrigins === \"function\") {\n\t\t\tconst validOrigins = await options.trustedOrigins(request);\n\t\t\ttrustedOrigins.push(...validOrigins);\n\t\t}\n\t}\n\tconst envTrustedOrigins = env.BETTER_AUTH_TRUSTED_ORIGINS;\n\tif (envTrustedOrigins) {\n\t\ttrustedOrigins.push(...envTrustedOrigins.split(\",\"));\n\t}\n\treturn trustedOrigins.filter((v): v is string => Boolean(v));\n}\n"],"names":["context: AuthContext","dbHooks: BetterAuthOptions[\"databaseHooks\"][]","result: ReturnType<Required<BetterAuthPlugin>[\"init\"]>","defu","plugins: BetterAuthPlugin[]","trustedOrigins: (string | undefined | null)[]"],"mappings":";;;;;;;;;;;;;;;;;;;;AAWA,eAAsB,cAAc,GAAA,EAAkB;IACrD,IAAI,UAAU,IAAI,OAAA;IAClB,MAAM,UAAU,QAAQ,OAAA,IAAW,EAAE;IACrC,IAAIA,UAAuB;IAC3B,MAAMC,UAAgD,EAAE;IACxD,KAAK,MAAM,UAAU,QACpB,IAAI,OAAO,IAAA,EAAM;QAChB,MAAM,cAAc,OAAO,IAAA,CAAK,QAAQ;QACxC,IAAIC;QACJ,QAAI,4LAAA,EAAU,YAAY,CACzB,CAAA,SAAS,MAAM;aAEf,SAAS;QAEV,IAAI,OAAO,WAAW,UAAU;YAC/B,IAAI,OAAO,OAAA,EAAS;gBACnB,MAAM,EAAE,aAAA,EAAe,GAAG,UAAA,GAAa,OAAO,OAAA;gBAC9C,IAAI,cACH,CAAA,QAAQ,IAAA,CAAK,cAAc;gBAE5B,cAAUC,2JAAAA,EAAK,SAAS,SAAS;;YAElC,IAAI,OAAO,OAAA,CACV,CAAA,UAAU;gBACT,GAAG,OAAA;gBACH,GAAI,OAAO,OAAA;aACX;;;IAML,QAAQ,IAAA,CAAK,QAAQ,aAAA,CAAc;IACnC,QAAQ,eAAA,OAAkB,2MAAA,EAAsB,QAAQ,OAAA,EAAS;QAChE;QACA,QAAQ,QAAQ,MAAA;QAChB,OAAO,QAAQ,MAAA,CAAA,CAAQ,IAAM,MAAM,KAAA,EAAU;QAC7C,YAAY,QAAQ,UAAA;KACpB,CAAC;IACF,QAAQ,OAAA,GAAU;IAClB,OAAO;QAAE;IAAA,CAAS;;AAGnB,SAAgB,mBAAmB,OAAA,EAA4B;IAC9D,MAAMC,UAA8B,EAAE;IACtC,IAAI,QAAQ,QAAA,EAAU,uBAAuB,SAAS,CAAA;IAGtD,OAAO;;AAGR,eAAsB,kBACrB,OAAA,EACA,OAAA,EACoB;IACpB,MAAM,cAAU,mLAAA,EAAW,QAAQ,OAAA,EAAS,QAAQ,QAAA,EAAU,QAAQ;IACtE,MAAMC,iBAAgD,UACnD;QAAC,IAAI,IAAI,QAAQ,CAAC,MAAA;KAAO,GACzB,EAAE;IACL,IAAI,QAAQ,cAAA,EAAgB;QAC3B,IAAI,MAAM,OAAA,CAAQ,QAAQ,cAAA,CAAe,CACxC,CAAA,eAAe,IAAA,CAAK,GAAG,QAAQ,cAAA,CAAe;QAE/C,IAAI,OAAO,QAAQ,cAAA,KAAmB,YAAY;YACjD,MAAM,eAAe,MAAM,QAAQ,cAAA,CAAe,QAAQ;YAC1D,eAAe,IAAA,CAAK,GAAG,aAAa;;;IAGtC,MAAM,oBAAoB,4LAAA,CAAI,2BAAA;IAC9B,IAAI,kBACH,CAAA,eAAe,IAAA,CAAK,GAAG,kBAAkB,KAAA,CAAM,IAAI,CAAC;IAErD,OAAO,eAAe,MAAA,CAAA,CAAQ,IAAmB,QAAQ,EAAE,CAAC"}},
    {"offset": {"line": 8630, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/context/create-context.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/context/create-context.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tBetterAuthPlugin,\n} from \"@better-auth/core\";\nimport { getBetterAuthVersion } from \"@better-auth/core/context\";\nimport { getAuthTables } from \"@better-auth/core/db\";\nimport type { DBAdapter } from \"@better-auth/core/db/adapter\";\nimport { createLogger, env, isProduction, isTest } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport type { OAuthProvider } from \"@better-auth/core/oauth2\";\nimport type { SocialProviders } from \"@better-auth/core/social-providers\";\nimport { socialProviders } from \"@better-auth/core/social-providers\";\nimport { deprecate } from \"@better-auth/core/utils\";\nimport { createTelemetry } from \"@better-auth/telemetry\";\nimport defu from \"defu\";\nimport type { Entries } from \"type-fest\";\nimport { checkEndpointConflicts } from \"../api\";\nimport { matchesOriginPattern } from \"../auth/trusted-origins\";\nimport { createCookieGetter, getCookies } from \"../cookies\";\nimport { hashPassword, verifyPassword } from \"../crypto/password\";\nimport { createInternalAdapter } from \"../db/internal-adapter\";\nimport { generateId } from \"../utils\";\nimport { DEFAULT_SECRET } from \"../utils/constants\";\nimport { isPromise } from \"../utils/is-promise\";\nimport { checkPassword } from \"../utils/password\";\nimport { getBaseURL } from \"../utils/url\";\nimport {\n\tgetInternalPlugins,\n\tgetTrustedOrigins,\n\trunPluginInit,\n} from \"./helpers\";\n\n/**\n * Estimates the entropy of a string in bits.\n * This is a simple approximation that helps detect low-entropy secrets.\n */\nfunction estimateEntropy(str: string): number {\n\tconst unique = new Set(str).size;\n\tif (unique === 0) return 0;\n\treturn Math.log2(Math.pow(unique, str.length));\n}\n\n/**\n * Validates that the secret meets minimum security requirements.\n * Throws BetterAuthError if the secret is invalid.\n * Skips validation for DEFAULT_SECRET in test environments only.\n * Only throws for DEFAULT_SECRET in production environment.\n */\nfunction validateSecret(\n\tsecret: string,\n\tlogger: ReturnType<typeof createLogger>,\n): void {\n\tconst isDefaultSecret = secret === DEFAULT_SECRET;\n\n\tif (isTest()) {\n\t\treturn;\n\t}\n\n\tif (isDefaultSecret && isProduction) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config.\",\n\t\t);\n\t}\n\n\tif (!secret) {\n\t\tthrow new BetterAuthError(\n\t\t\t\"BETTER_AUTH_SECRET is missing. Set it in your environment or pass `secret` to betterAuth({ secret }).\",\n\t\t);\n\t}\n\n\tif (secret.length < 32) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Warning: your BETTER_AUTH_SECRET should be at least 32 characters long for adequate security. Generate one with \\`npx @better-auth/cli secret\\` or \\`openssl rand -base64 32\\`.`,\n\t\t);\n\t}\n\n\t// Optional high-entropy check: warn if entropy appears low\n\tconst entropy = estimateEntropy(secret);\n\tif (entropy < 120) {\n\t\tlogger.warn(\n\t\t\t\"[better-auth] Warning: your BETTER_AUTH_SECRET appears low-entropy. Use a randomly generated secret for production.\",\n\t\t);\n\t}\n}\n\nexport async function createAuthContext(\n\tadapter: DBAdapter<BetterAuthOptions>,\n\toptions: BetterAuthOptions,\n\tgetDatabaseType: (database: BetterAuthOptions[\"database\"]) => string,\n): Promise<AuthContext> {\n\t//set default options for stateless mode\n\tif (!options.database) {\n\t\toptions = defu(options, {\n\t\t\tsession: {\n\t\t\t\tcookieCache: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tstrategy: \"jwe\" as const,\n\t\t\t\t\trefreshCache: true,\n\t\t\t\t},\n\t\t\t},\n\t\t\taccount: {\n\t\t\t\tstoreStateStrategy: \"cookie\" as const,\n\t\t\t\tstoreAccountCookie: true,\n\t\t\t},\n\t\t});\n\t}\n\tconst plugins = options.plugins || [];\n\tconst internalPlugins = getInternalPlugins(options);\n\tconst logger = createLogger(options.logger);\n\tconst baseURL = getBaseURL(options.baseURL, options.basePath);\n\n\tif (!baseURL) {\n\t\tlogger.warn(\n\t\t\t`[better-auth] Base URL could not be determined. Please set a valid base URL using the baseURL config option or the BETTER_AUTH_BASE_URL environment variable. Without this, callbacks and redirects may not work correctly.`,\n\t\t);\n\t}\n\n\tif (\n\t\tadapter.id === \"memory\" &&\n\t\toptions.advanced?.database?.generateId === false\n\t) {\n\t\tlogger.error(\n\t\t\t`[better-auth] Misconfiguration detected.\nYou are using the memory DB with generateId: false.\nThis will cause no id to be generated for any model.\nMost of the features of Better Auth will not work correctly.`,\n\t\t);\n\t}\n\n\tconst secret =\n\t\toptions.secret ||\n\t\tenv.BETTER_AUTH_SECRET ||\n\t\tenv.AUTH_SECRET ||\n\t\tDEFAULT_SECRET;\n\n\tvalidateSecret(secret, logger);\n\n\toptions = {\n\t\t...options,\n\t\tsecret,\n\t\tbaseURL: baseURL ? new URL(baseURL).origin : \"\",\n\t\tbasePath: options.basePath || \"/api/auth\",\n\t\tplugins: plugins.concat(internalPlugins),\n\t};\n\n\tcheckEndpointConflicts(options, logger);\n\tconst cookies = getCookies(options);\n\tconst tables = getAuthTables(options);\n\tconst providers: OAuthProvider[] = (\n\t\tObject.entries(\n\t\t\toptions.socialProviders || {},\n\t\t) as unknown as Entries<SocialProviders>\n\t)\n\t\t.map(([key, config]) => {\n\t\t\tif (config == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (config.enabled === false) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!config.clientId) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Social provider ${key} is missing clientId or clientSecret`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst provider = socialProviders[key](config as never);\n\t\t\t(provider as OAuthProvider).disableImplicitSignUp =\n\t\t\t\tconfig.disableImplicitSignUp;\n\t\t\treturn provider;\n\t\t})\n\t\t.filter((x) => x !== null);\n\n\tconst generateIdFunc: AuthContext[\"generateId\"] = ({ model, size }) => {\n\t\tif (typeof (options.advanced as any)?.generateId === \"function\") {\n\t\t\treturn (options.advanced as any).generateId({ model, size });\n\t\t}\n\t\tconst dbGenerateId = options?.advanced?.database?.generateId;\n\t\tif (typeof dbGenerateId === \"function\") {\n\t\t\treturn dbGenerateId({ model, size });\n\t\t}\n\t\tif (dbGenerateId === \"uuid\") {\n\t\t\treturn crypto.randomUUID();\n\t\t}\n\t\tif (dbGenerateId === \"serial\" || dbGenerateId === false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn generateId(size);\n\t};\n\n\tconst { publish } = await createTelemetry(options, {\n\t\tadapter: adapter.id,\n\t\tdatabase:\n\t\t\ttypeof options.database === \"function\"\n\t\t\t\t? \"adapter\"\n\t\t\t\t: getDatabaseType(options.database),\n\t});\n\n\tconst trustedOrigins = await getTrustedOrigins(options);\n\n\tconst ctx: AuthContext = {\n\t\tappName: options.appName || \"Better Auth\",\n\t\tbaseURL: baseURL || \"\",\n\t\tversion: getBetterAuthVersion(),\n\t\tsocialProviders: providers,\n\t\toptions,\n\t\toauthConfig: {\n\t\t\tstoreStateStrategy:\n\t\t\t\toptions.account?.storeStateStrategy ||\n\t\t\t\t(options.database ? \"database\" : \"cookie\"),\n\t\t\tskipStateCookieCheck: !!options.account?.skipStateCookieCheck,\n\t\t},\n\t\ttables,\n\t\ttrustedOrigins,\n\t\tisTrustedOrigin(\n\t\t\turl: string,\n\t\t\tsettings?: {\n\t\t\t\tallowRelativePaths: boolean;\n\t\t\t},\n\t\t) {\n\t\t\treturn this.trustedOrigins.some((origin) =>\n\t\t\t\tmatchesOriginPattern(url, origin, settings),\n\t\t\t);\n\t\t},\n\t\tsessionConfig: {\n\t\t\tupdateAge:\n\t\t\t\toptions.session?.updateAge !== undefined\n\t\t\t\t\t? options.session.updateAge\n\t\t\t\t\t: 24 * 60 * 60,\n\t\t\texpiresIn: options.session?.expiresIn || 60 * 60 * 24 * 7,\n\t\t\tfreshAge:\n\t\t\t\toptions.session?.freshAge === undefined\n\t\t\t\t\t? 60 * 60 * 24\n\t\t\t\t\t: options.session.freshAge,\n\t\t\tcookieRefreshCache: (() => {\n\t\t\t\tconst refreshCache = options.session?.cookieCache?.refreshCache;\n\t\t\t\tconst maxAge = options.session?.cookieCache?.maxAge || 60 * 5;\n\n\t\t\t\t// `refreshCache` is intended for fully stateless / DB-less setups.\n\t\t\t\t// If a server-side store is configured, prefer fetching/refreshing from that source\n\t\t\t\t// and disable stateless refresh behavior to avoid confusing/unsafe configurations.\n\t\t\t\tconst isStateful = !!options.database || !!options.secondaryStorage;\n\t\t\t\tif (isStateful && refreshCache) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"[better-auth] `session.cookieCache.refreshCache` is enabled while `database` or `secondaryStorage` is configured. `refreshCache` is meant for stateless (DB-less) setups. Disabling `refreshCache`  remove it from your config to silence this warning.\",\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === false || refreshCache === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (refreshCache === true) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tupdateAge: Math.floor(maxAge * 0.2),\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tupdateAge:\n\t\t\t\t\t\trefreshCache.updateAge !== undefined\n\t\t\t\t\t\t\t? refreshCache.updateAge\n\t\t\t\t\t\t\t: Math.floor(maxAge * 0.2),\n\t\t\t\t};\n\t\t\t})(),\n\t\t},\n\t\tsecret,\n\t\trateLimit: {\n\t\t\t...options.rateLimit,\n\t\t\tenabled: options.rateLimit?.enabled ?? isProduction,\n\t\t\twindow: options.rateLimit?.window || 10,\n\t\t\tmax: options.rateLimit?.max || 100,\n\t\t\tstorage:\n\t\t\t\toptions.rateLimit?.storage ||\n\t\t\t\t(options.secondaryStorage ? \"secondary-storage\" : \"memory\"),\n\t\t},\n\t\tauthCookies: cookies,\n\t\tlogger,\n\t\tgenerateId: generateIdFunc,\n\t\tsession: null,\n\t\tsecondaryStorage: options.secondaryStorage,\n\t\tpassword: {\n\t\t\thash: options.emailAndPassword?.password?.hash || hashPassword,\n\t\t\tverify: options.emailAndPassword?.password?.verify || verifyPassword,\n\t\t\tconfig: {\n\t\t\t\tminPasswordLength: options.emailAndPassword?.minPasswordLength || 8,\n\t\t\t\tmaxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128,\n\t\t\t},\n\t\t\tcheckPassword,\n\t\t},\n\t\tsetNewSession(session) {\n\t\t\tthis.newSession = session;\n\t\t},\n\t\tnewSession: null,\n\t\tadapter: adapter,\n\t\tinternalAdapter: createInternalAdapter(adapter, {\n\t\t\toptions,\n\t\t\tlogger,\n\t\t\thooks: options.databaseHooks ? [options.databaseHooks] : [],\n\t\t\tgenerateId: generateIdFunc,\n\t\t}),\n\t\tcreateAuthCookie: createCookieGetter(options),\n\t\tasync runMigrations() {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"runMigrations will be set by the specific init implementation\",\n\t\t\t);\n\t\t},\n\t\tpublishTelemetry: publish,\n\t\tskipCSRFCheck: !!options.advanced?.disableCSRFCheck,\n\t\tskipOriginCheck:\n\t\t\toptions.advanced?.disableOriginCheck !== undefined\n\t\t\t\t? options.advanced.disableOriginCheck\n\t\t\t\t: isTest()\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\trunInBackground:\n\t\t\toptions.advanced?.backgroundTasks?.handler ??\n\t\t\t((p) => {\n\t\t\t\tp.catch(() => {});\n\t\t\t}),\n\t\tasync runInBackgroundOrAwait(\n\t\t\tpromise: Promise<unknown> | Promise<void> | void | unknown,\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (options.advanced?.backgroundTasks?.handler) {\n\t\t\t\t\tif (promise instanceof Promise) {\n\t\t\t\t\t\toptions.advanced.backgroundTasks.handler(\n\t\t\t\t\t\t\tpromise.catch((e) => {\n\t\t\t\t\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait promise;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlogger.error(\"Failed to run background task:\", e);\n\t\t\t}\n\t\t},\n\t\tgetPlugin: <Plugin extends BetterAuthPlugin>(id: Plugin[\"id\"]) =>\n\t\t\t(options.plugins!.find((p): p is Plugin => p.id === id) as\n\t\t\t\t| Plugin\n\t\t\t\t| undefined) ?? null,\n\t};\n\n\tconst initOrPromise = runPluginInit(ctx);\n\tlet context: AuthContext;\n\tif (isPromise(initOrPromise)) {\n\t\t({ context } = await initOrPromise);\n\t} else {\n\t\t({ context } = initOrPromise);\n\t}\n\n\tif (\n\t\ttypeof context.options.emailVerification?.onEmailVerification === \"function\"\n\t) {\n\t\tcontext.options.emailVerification.onEmailVerification = deprecate(\n\t\t\tcontext.options.emailVerification.onEmailVerification,\n\t\t\t\"Use `afterEmailVerification` instead. This will be removed in 1.5\",\n\t\t\tcontext.logger,\n\t\t);\n\t}\n\n\treturn context;\n}\n"],"names":["logger","providers: OAuthProvider[]","generateIdFunc: AuthContext[\"generateId\"]","generateId","context: AuthContext"],"mappings":"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"}},
    {"offset": {"line": 8869, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/context/init.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/context/init.ts"],"sourcesContent":["import { BetterAuthError } from \"@better-auth/core/error\";\nimport { getKyselyDatabaseType } from \"../adapters/kysely-adapter/dialect\";\nimport { getAdapter } from \"../db/adapter-kysely\";\nimport { getMigrations } from \"../db/get-migration\";\nimport type { BetterAuthOptions } from \"../types\";\nimport { createAuthContext } from \"./create-context\";\n\nexport const init = async (options: BetterAuthOptions) => {\n\tconst adapter = await getAdapter(options);\n\n\t// Get database type using Kysely's dialect detection\n\tconst getDatabaseType = (database: BetterAuthOptions[\"database\"]) =>\n\t\tgetKyselyDatabaseType(database) || \"unknown\";\n\n\t// Use base context creation\n\tconst ctx = await createAuthContext(adapter, options, getDatabaseType);\n\n\t// Add runMigrations with Kysely support\n\tctx.runMigrations = async function () {\n\t\t// only run migrations if database is provided and it's not an adapter\n\t\tif (!options.database || \"updateMany\" in options.database) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Database is not provided or it's an adapter. Migrations are only supported with a database instance.\",\n\t\t\t);\n\t\t}\n\t\tconst { runMigrations } = await getMigrations(options);\n\t\tawait runMigrations();\n\t};\n\n\treturn ctx;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAOA,MAAa,OAAO,OAAO,YAA+B;IACzD,MAAM,UAAU,UAAM,8LAAA,EAAW,QAAQ;IAGzC,MAAM,kBAAA,CAAmB,eACxB,0NAAA,EAAsB,SAAS,IAAI;IAGpC,MAAM,MAAM,UAAM,0MAAA,EAAkB,SAAS,SAAS,gBAAgB;IAGtE,IAAI,aAAA,GAAgB,iBAAkB;QAErC,IAAI,CAAC,QAAQ,QAAA,IAAY,gBAAgB,QAAQ,QAAA,CAChD,CAAA,MAAM,IAAI,oNAAA,CACT,uGACA;QAEF,MAAM,EAAE,aAAA,EAAA,GAAkB,UAAM,gMAAA,EAAc,QAAQ;QACtD,MAAM,eAAe;;IAGtB,OAAO"}},
    {"offset": {"line": 8901, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/auth/base.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/auth/base.ts"],"sourcesContent":["import type { AuthContext, BetterAuthOptions } from \"@better-auth/core\";\nimport { runWithAdapter } from \"@better-auth/core/context\";\nimport { BASE_ERROR_CODES, BetterAuthError } from \"@better-auth/core/error\";\nimport { getEndpoints, router } from \"../api\";\nimport { getTrustedOrigins } from \"../context/helpers\";\nimport type { Auth } from \"../types\";\nimport { getBaseURL, getOrigin } from \"../utils/url\";\n\nexport const createBetterAuth = <Options extends BetterAuthOptions>(\n\toptions: Options,\n\tinitFn: (options: Options) => Promise<AuthContext>,\n): Auth<Options> => {\n\tconst authContext = initFn(options);\n\tconst { api } = getEndpoints(authContext, options);\n\tconst errorCodes = options.plugins?.reduce((acc, plugin) => {\n\t\tif (plugin.$ERROR_CODES) {\n\t\t\treturn {\n\t\t\t\t...acc,\n\t\t\t\t...plugin.$ERROR_CODES,\n\t\t\t};\n\t\t}\n\t\treturn acc;\n\t}, {});\n\treturn {\n\t\thandler: async (request: Request) => {\n\t\t\tconst ctx = await authContext;\n\t\t\tconst basePath = ctx.options.basePath || \"/api/auth\";\n\t\t\tif (!ctx.options.baseURL) {\n\t\t\t\tconst baseURL = getBaseURL(\n\t\t\t\t\tundefined,\n\t\t\t\t\tbasePath,\n\t\t\t\t\trequest,\n\t\t\t\t\tundefined,\n\t\t\t\t\tctx.options.advanced?.trustedProxyHeaders,\n\t\t\t\t);\n\t\t\t\tif (baseURL) {\n\t\t\t\t\tctx.baseURL = baseURL;\n\t\t\t\t\tctx.options.baseURL = getOrigin(ctx.baseURL) || undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Could not get base URL from request. Please provide a valid base URL.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.trustedOrigins = await getTrustedOrigins(ctx.options, request);\n\t\t\tconst { handler } = router(ctx, options);\n\t\t\treturn runWithAdapter(ctx.adapter, () => handler(request));\n\t\t},\n\t\tapi,\n\t\toptions: options,\n\t\t$context: authContext,\n\t\t$ERROR_CODES: {\n\t\t\t...errorCodes,\n\t\t\t...BASE_ERROR_CODES,\n\t\t},\n\t} as any;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAQA,MAAa,mBAAA,CACZ,SACA,WACmB;IACnB,MAAM,cAAc,OAAO,QAAQ;IACnC,MAAM,EAAE,GAAA,EAAA,OAAQ,qMAAA,EAAa,aAAa,QAAQ;IAUlD,OAAO;QACN,SAAS,OAAO,YAAqB;YACpC,MAAM,MAAM,MAAM;YAClB,MAAM,WAAW,IAAI,OAAA,CAAQ,QAAA,IAAY;YACzC,IAAI,CAAC,IAAI,OAAA,CAAQ,OAAA,EAAS;gBACzB,MAAM,cAAU,mLAAA,EACf,KAAA,GACA,UACA,SACA,KAAA,GACA,IAAI,OAAA,CAAQ,QAAA,EAAU,oBACtB;gBACD,IAAI,SAAS;oBACZ,IAAI,OAAA,GAAU;oBACd,IAAI,OAAA,CAAQ,OAAA,OAAU,kLAAA,EAAU,IAAI,OAAA,CAAQ,IAAI,KAAA;sBAEhD,CAAA,MAAM,IAAI,oNAAA,CACT,wEACA;;YAGH,IAAI,cAAA,GAAiB,UAAM,gMAAA,EAAkB,IAAI,OAAA,EAAS,QAAQ;YAClE,MAAM,EAAE,OAAA,EAAA,OAAY,+LAAA,EAAO,KAAK,QAAQ;YACxC,WAAO,2MAAA,EAAe,IAAI,OAAA,EAAA,IAAe,QAAQ,QAAQ,CAAC;;QAE3D;QACS;QACT,UAAU;QACV,cAAc;YACb,GAtCiB,QAAQ,OAAA,EAAS,OAAA,CAAQ,KAAK,WAAW;gBAC3D,IAAI,OAAO,YAAA,CACV,CAAA,OAAO;oBACN,GAAG,GAAA;oBACH,GAAG,OAAO,YAAA;iBACV;gBAEF,OAAO;eACL,CAAA,CAAE,CAAC;YA+BJ,GAAG,qMAAA;SACH;KACD"}},
    {"offset": {"line": 8957, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/auth/full.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/auth/full.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport { init } from \"../context/init\";\nimport type { Auth } from \"../types\";\nimport { createBetterAuth } from \"./base\";\n\n/**\n * Better Auth initializer for full mode (with Kysely)\n *\n * @example\n * ```ts\n * import { betterAuth } from \"better-auth\";\n *\n * const auth = betterAuth({\n * \tdatabase: new PostgresDialect({ connection: process.env.DATABASE_URL }),\n * });\n * ```\n *\n * For minimal mode (without Kysely), import from `better-auth/minimal` instead\n * @example\n * ```ts\n * import { betterAuth } from \"better-auth/minimal\";\n *\n * const auth = betterAuth({\n *\t  database: drizzleAdapter(db, { provider: \"pg\" }),\n * });\n */\nexport const betterAuth = <Options extends BetterAuthOptions>(\n\toptions: Options & {},\n): Auth<Options> => {\n\treturn createBetterAuth(options, init);\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BA,MAAa,aAAA,CACZ,YACmB;IACnB,WAAO,yLAAA,EAAiB,SAAS,gLAAA,CAAK"}},
    {"offset": {"line": 8995, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/index.mjs"],"sourcesContent":["import { generateGenericState, parseGenericState } from \"./state.mjs\";\nimport { generateState, parseState } from \"./oauth2/state.mjs\";\nimport { HIDE_METADATA } from \"./utils/hide-metadata.mjs\";\nimport { generateId } from \"./utils/index.mjs\";\nimport { APIError } from \"./api/index.mjs\";\nimport { betterAuth } from \"./auth/full.mjs\";\nimport { getCurrentAdapter } from \"@better-auth/core/context\";\nimport { createTelemetry, getTelemetryAuthConfig } from \"@better-auth/telemetry\";\n\nexport * from \"@better-auth/core\"\n\nexport * from \"@better-auth/core/db\"\n\nexport * from \"@better-auth/core/env\"\n\nexport * from \"@better-auth/core/error\"\n\nexport * from \"@better-auth/core/oauth2\"\n\nexport * from \"@better-auth/core/utils\"\n\nexport { APIError, HIDE_METADATA, betterAuth, createTelemetry, generateGenericState, generateId, generateState, getCurrentAdapter, getTelemetryAuthConfig, parseGenericState, parseState };"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA","ignoreList":[0]}}]
}