{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/adapters/kysely-adapter/kysely-adapter.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/adapters/kysely-adapter/kysely-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport type {\n\tInsertQueryBuilder,\n\tKysely,\n\tRawBuilder,\n\tUpdateQueryBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\ninterface KyselyAdapterConfig {\n\t/**\n\t * Database type.\n\t */\n\ttype?: KyselyDatabaseType | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * Use plural for table names.\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const kyselyAdapter = (\n\tdb: Kysely<any>,\n\tconfig?: KyselyAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter = (\n\t\tdb: Kysely<any>,\n\t): AdapterFactoryCustomizeAdapterCreator => {\n\t\treturn ({\n\t\t\tgetFieldName,\n\t\t\tschema,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetModelName,\n\t\t}) => {\n\t\t\tconst selectAllJoins = (join: JoinConfig | undefined) => {\n\t\t\t\t// Use selectAll which will handle column naming appropriately\n\t\t\t\tconst allSelects: RawBuilder<unknown>[] = [];\n\t\t\t\tconst allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[] = [];\n\t\t\t\tif (join) {\n\t\t\t\t\tfor (const [joinModel, _] of Object.entries(join)) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(joinModel)]?.fields;\n\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\tif (!fields) continue;\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const [field, fieldAttr] of Object.entries(fields)) {\n\t\t\t\t\t\t\tallSelects.push(\n\t\t\t\t\t\t\t\tsql`${sql.ref(`join_${joinModelName}`)}.${sql.ref(fieldAttr.fieldName || field)} as ${sql.ref(`_joined_${joinModelName}_${fieldAttr.fieldName || field}`)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallSelectsStr.push({\n\t\t\t\t\t\t\t\tjoinModel: joinModel,\n\t\t\t\t\t\t\t\tjoinModelRef: joinModelName,\n\t\t\t\t\t\t\t\tfieldName: fieldAttr.fieldName || field,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { allSelectsStr, allSelects };\n\t\t\t};\n\n\t\t\tconst withReturning = async (\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t\tbuilder:\n\t\t\t\t\t| InsertQueryBuilder<any, any, any>\n\t\t\t\t\t| UpdateQueryBuilder<any, string, string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\twhere: Where[],\n\t\t\t) => {\n\t\t\t\tlet res: any;\n\t\t\t\tif (config?.type === \"mysql\") {\n\t\t\t\t\t// This isn't good, but kysely doesn't support returning in mysql and it doesn't return the inserted id.\n\t\t\t\t\t// Change this if there is a better way.\n\t\t\t\t\tawait builder.execute();\n\t\t\t\t\tconst field = values.id\n\t\t\t\t\t\t? \"id\"\n\t\t\t\t\t\t: where.length > 0 && where[0]?.field\n\t\t\t\t\t\t\t? where[0].field\n\t\t\t\t\t\t\t: \"id\";\n\n\t\t\t\t\tif (!values.id && where.length === 0) {\n\t\t\t\t\t\tres = await db\n\t\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = values[field] || where[0]?.value;\n\t\t\t\t\tres = await db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t.where(getFieldName({ model, field }), \"=\", value)\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\tres = await builder.outputAll(\"inserted\").executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tres = await builder.returningAll().executeTakeFirst();\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\tfunction convertWhereClause(model: string, w?: Where[] | undefined) {\n\t\t\t\tif (!w)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tand: null,\n\t\t\t\t\t\tor: null,\n\t\t\t\t\t};\n\n\t\t\t\tconst conditions = {\n\t\t\t\t\tand: [] as any[],\n\t\t\t\t\tor: [] as any[],\n\t\t\t\t};\n\n\t\t\t\tw.forEach((condition) => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t\tvalue: _value,\n\t\t\t\t\t\toperator = \"=\",\n\t\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t\t} = condition;\n\t\t\t\t\tconst value: any = _value;\n\t\t\t\t\tconst field: string | any = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst expr = (eb: any) => {\n\t\t\t\t\t\tconst f = `${model}.${field}`;\n\t\t\t\t\t\tif (operator.toLowerCase() === \"in\") {\n\t\t\t\t\t\t\treturn eb(f, \"in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator.toLowerCase() === \"not_in\") {\n\t\t\t\t\t\t\treturn eb(f, \"not in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"contains\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"eq\") {\n\t\t\t\t\t\t\treturn eb(f, \"=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ne\") {\n\t\t\t\t\t\t\treturn eb(f, \"<>\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gt\") {\n\t\t\t\t\t\t\treturn eb(f, \">\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gte\") {\n\t\t\t\t\t\t\treturn eb(f, \">=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lt\") {\n\t\t\t\t\t\t\treturn eb(f, \"<\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lte\") {\n\t\t\t\t\t\t\treturn eb(f, \"<=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn eb(f, operator, value);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (connector === \"OR\") {\n\t\t\t\t\t\tconditions.or.push(expr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconditions.and.push(expr);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tand: conditions.and.length ? conditions.and : null,\n\t\t\t\t\tor: conditions.or.length ? conditions.or : null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction processJoinedResults(\n\t\t\t\trows: any[],\n\t\t\t\tjoinConfig: JoinConfig | undefined,\n\t\t\t\tallSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[],\n\t\t\t) {\n\t\t\t\tif (!joinConfig || !rows.length) {\n\t\t\t\t\treturn rows;\n\t\t\t\t}\n\n\t\t\t\t// Group rows by main model ID\n\t\t\t\tconst groupedByMainId = new Map<string, any>();\n\n\t\t\t\tfor (const currentRow of rows) {\n\t\t\t\t\t// Separate main model columns from joined columns\n\t\t\t\t\tconst mainModelFields: Record<string, any> = {};\n\t\t\t\t\tconst joinedModelFields: Record<string, Record<string, any>> = {};\n\n\t\t\t\t\t// Initialize joined model fields map\n\t\t\t\t\tfor (const [joinModel] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Distribute all columns - collect complete objects per model\n\t\t\t\t\tfor (const [key, value] of Object.entries(currentRow)) {\n\t\t\t\t\t\tconst keyStr = String(key);\n\t\t\t\t\t\tlet assigned = false;\n\n\t\t\t\t\t\t// Check if this is a joined column\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tjoinModel,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tjoinModelRef,\n\t\t\t\t\t\t} of allSelectsStr) {\n\t\t\t\t\t\t\tif (keyStr === `_joined_${joinModelRef}_${fieldName}`) {\n\t\t\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)]![\n\t\t\t\t\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t] = value;\n\t\t\t\t\t\t\t\tassigned = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!assigned) {\n\t\t\t\t\t\t\tmainModelFields[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mainId = mainModelFields.id;\n\t\t\t\t\tif (!mainId) continue;\n\n\t\t\t\t\t// Initialize or get existing entry for this main model\n\t\t\t\t\tif (!groupedByMainId.has(mainId)) {\n\t\t\t\t\t\tconst entry: Record<string, any> = { ...mainModelFields };\n\n\t\t\t\t\t\t// Initialize joined models based on uniqueness\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] =\n\t\t\t\t\t\t\t\tjoinAttr.relation === \"one-to-one\" ? null : [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroupedByMainId.set(mainId, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst entry = groupedByMainId.get(mainId)!;\n\n\t\t\t\t\t// Add joined records to the entry\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\n\t\t\t\t\t\tconst joinedObj = joinedModelFields[getModelName(joinModel)];\n\n\t\t\t\t\t\tconst hasData =\n\t\t\t\t\t\t\tjoinedObj &&\n\t\t\t\t\t\t\tObject.keys(joinedObj).length > 0 &&\n\t\t\t\t\t\t\tObject.values(joinedObj).some(\n\t\t\t\t\t\t\t\t(value) => value !== null && value !== undefined,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isUnique) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] = hasData ? joinedObj : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For arrays, append if not already there (deduplicate by id) and respect limit\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName]) && hasData) {\n\t\t\t\t\t\t\t\t// Check if we've reached the limit before processing\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length >= limit) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get the id field name using getFieldName to ensure correct transformation\n\t\t\t\t\t\t\t\tconst idFieldName = getFieldName({\n\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst joinedId = joinedObj[idFieldName];\n\n\t\t\t\t\t\t\t\t// Only deduplicate if we have an id field\n\t\t\t\t\t\t\t\tif (joinedId) {\n\t\t\t\t\t\t\t\t\tconst exists = entry[joinModelName].some(\n\t\t\t\t\t\t\t\t\t\t(item: any) => item[idFieldName] === joinedId,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!exists && entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If no id field, still add the object if it has data and limit not reached\n\t\t\t\t\t\t\t\t\tif (entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = Array.from(groupedByMainId.values());\n\n\t\t\t\t// Apply final limit to non-unique join arrays as a safety measure\n\t\t\t\tfor (const entry of result) {\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tif (joinAttr.relation !== \"one-to-one\") {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName])) {\n\t\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length > limit) {\n\t\t\t\t\t\t\t\t\tentry[joinModelName] = entry[joinModelName].slice(0, limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ data, model }) {\n\t\t\t\t\tconst builder = db.insertInto(model).values(data);\n\t\t\t\t\tconst returned = await withReturning(data, builder, model, []);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (!res || !Array.isArray(res) || res.length === 0) return null;\n\n\t\t\t\t\t// Get the first row from the result array\n\t\t\t\t\tconst row = res[0];\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst processedRows = processJoinedResults(\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\tjoin,\n\t\t\t\t\t\t\tallSelectsStr,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn processedRows[0] as any;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn row as any;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\n\t\t\t\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tif (!sortBy) {\n\t\t\t\t\t\t\t\t\t\tb = b.orderBy(getFieldName({ model, field: \"id\" }));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tb = b.offset(offset).fetch(limit || 100);\n\t\t\t\t\t\t\t\t} else if (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.top(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.limit(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.offset(offset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\tb = b.orderBy(\n\t\t\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\t// it's possible users provide a schema name in the model name (`<schema>.<model>`)\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tquery = query.orderBy(\n\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await query.execute();\n\n\t\t\t\t\tif (!res) return [];\n\t\t\t\t\tif (join) return processJoinedResults(res, join, allSelectsStr);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\treturn await withReturning(values as any, query, model, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numUpdatedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t// a temporal solution for counting other than \"*\" - see more - https://www.sqlite.org/quirks.html#double_quoted_string_literals_are_accepted\n\t\t\t\t\t\t.select(db.fn.count(\"id\").as(\"count\"));\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (typeof res[0]!.count === \"number\") {\n\t\t\t\t\t\treturn res[0]!.count;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof res[0]!.count === \"bigint\") {\n\t\t\t\t\t\treturn Number(res[0]!.count);\n\t\t\t\t\t}\n\t\t\t\t\treturn parseInt(res[0]!.count);\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tawait query.execute();\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numDeletedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"kysely\",\n\t\t\tadapterName: \"Kysely Adapter\",\n\t\t\tusePlural: config?.usePlural,\n\t\t\tdebugLogs: config?.debugLogs,\n\t\t\tsupportsBooleans:\n\t\t\t\tconfig?.type === \"sqlite\" ||\n\t\t\t\tconfig?.type === \"mssql\" ||\n\t\t\t\tconfig?.type === \"mysql\" ||\n\t\t\t\t!config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsDates:\n\t\t\t\tconfig?.type === \"sqlite\" || config?.type === \"mssql\" || !config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig?.type === \"postgres\"\n\t\t\t\t\t? true // even if there is JSON support, only pg supports passing direct json, all others must stringify\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: false, // Even if field supports JSON, we must pass stringified arrays to the database.\n\t\t\tsupportsUUIDs: config?.type === \"postgres\" ? true : false,\n\t\t\ttransaction: config?.transaction\n\t\t\t\t? (cb) =>\n\t\t\t\t\t\tdb.transaction().execute((trx) => {\n\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\tadapter: createCustomAdapter(trx),\n\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t})\n\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"names":["lazyOptions: BetterAuthOptions | null","allSelects: RawBuilder<unknown>[]","allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[]","res: any","db","value: any","field: string | any","mainModelFields: Record<string, any>","joinedModelFields: Record<string, Record<string, any>>","entry: Record<string, any>","entry","query: any","eb","join","adapterOptions: AdapterFactoryOptions | null"],"mappings":"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"}},
    {"offset": {"line": 325, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/adapters/kysely-adapter/index.mjs"],"sourcesContent":["import { createKyselyAdapter, getKyselyDatabaseType } from \"./dialect.mjs\";\nimport { kyselyAdapter } from \"./kysely-adapter.mjs\";\n\nexport { createKyselyAdapter, getKyselyDatabaseType, kyselyAdapter };"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0]}}]
}