{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/frontend/node_modules/better-auth/dist/adapters/memory-adapter/memory-adapter.mjs","sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/src/adapters/memory-adapter/memory-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tCleanedWhere,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\n\nexport interface MemoryDB {\n\t[key: string]: any[];\n}\n\nexport interface MemoryAdapterConfig {\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n}\n\nexport const memoryAdapter = (\n\tdb: MemoryDB,\n\tconfig?: MemoryAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tsupportsArrays: true,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tconst useNumberId =\n\t\t\t\t\tprops.options.advanced?.database?.useNumberId ||\n\t\t\t\t\tprops.options.advanced?.database?.generateId === \"serial\";\n\t\t\t\tif (useNumberId && props.field === \"id\" && props.action === \"create\") {\n\t\t\t\t\treturn db[props.model]!.length + 1;\n\t\t\t\t}\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tconst clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\tconst r = await cb(adapterCreator(lazyOptions!));\n\t\t\t\t\treturn r;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Rollback changes\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key]!;\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (\n\t\t\t\trecords: any[],\n\t\t\t\tsortBy: { field: string; direction: \"asc\" | \"desc\" } | undefined,\n\t\t\t\tmodel: string,\n\t\t\t) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a: any, b: any) => {\n\t\t\t\t\tconst field = getFieldName({ model, field: sortBy.field });\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\n\t\t\t\t\tlet comparison = 0;\n\n\t\t\t\t\t// Handle null/undefined values\n\t\t\t\t\tif (aValue == null && bValue == null) {\n\t\t\t\t\t\tcomparison = 0;\n\t\t\t\t\t} else if (aValue == null) {\n\t\t\t\t\t\tcomparison = -1;\n\t\t\t\t\t} else if (bValue == null) {\n\t\t\t\t\t\tcomparison = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle string comparison\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") {\n\t\t\t\t\t\tcomparison = aValue.localeCompare(bValue);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle date comparison\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) {\n\t\t\t\t\t\tcomparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\t}\n\t\t\t\t\t// Handle numeric comparison\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") {\n\t\t\t\t\t\tcomparison = aValue - bValue;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle boolean comparison\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") {\n\t\t\t\t\t\tcomparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t\t// Fallback to string comparison\n\t\t\t\t\telse {\n\t\t\t\t\t\tcomparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfunction convertWhereClause(\n\t\t\t\twhere: CleanedWhere[],\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig,\n\t\t\t): any[] {\n\t\t\t\tconst execute = (where: CleanedWhere[], model: string) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t`[MemoryAdapter] Model ${model} not found in the DB`,\n\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(`Model ${model} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst evalClause = (record: any, clause: CleanedWhere): boolean => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\":\n\t\t\t\t\t\t\t\treturn record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\t\t\treturn record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\t\t\treturn record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\t\t\treturn record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\treturn table.filter((record: any) => {\n\t\t\t\t\t\tif (!where.length || where.length === 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet result = evalClause(record, where[0]!);\n\t\t\t\t\t\tfor (const clause of where) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") {\n\t\t\t\t\t\t\t\tresult = result || clauseResult;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult = result && clauseResult;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!join) return execute(where, model);\n\n\t\t\t\tconst baseRecords = execute(where, model);\n\n\t\t\t\t// Group results by base model and nest joined data as arrays\n\t\t\t\tconst grouped = new Map<string, any>();\n\t\t\t\t// Track seen IDs per joined model for O(1) deduplication\n\t\t\t\tconst seenIds = new Map<string, Set<string>>();\n\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested: Record<string, any> = { ...baseRecord };\n\n\t\t\t\t\t\t// Initialize joined data structures based on isUnique\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t\tnested[joinModelName] = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId)!;\n\n\t\t\t\t\t// Add joined data\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`,\n\t\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter(\n\t\t\t\t\t\t\t(joinRecord: any) =>\n\t\t\t\t\t\t\t\tjoinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from],\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t// For unique relationships, store a single object (or null)\n\t\t\t\t\t\t\tnestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-unique relationships, store array with limit\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`)!;\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tconst useNumberId =\n\t\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdata.id = db[getModelName(model)]!.length + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tdb[model] = [];\n\t\t\t\t\t}\n\t\t\t\t\tdb[model]!.push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Return the first nested object\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\t// Without join, res is an array\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tconst record = resArray[0] || null;\n\t\t\t\t\treturn record;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where || [], model, join);\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply sorting to nested objects\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\n\t\t\t\t\t\t// Apply offset and limit\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Without join - original logic\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tlet table = applySortToRecords(resArray, sortBy, model);\n\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(offset);\n\t\t\t\t\t}\n\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(0, limit);\n\t\t\t\t\t}\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) {\n\t\t\t\t\t\tconst filteredRecords = convertWhereClause(where, model);\n\t\t\t\t\t\treturn filteredRecords.length;\n\t\t\t\t\t}\n\t\t\t\t\treturn db[model]!.length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t});\n\treturn (options: BetterAuthOptions) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n"],"names":["lazyOptions: BetterAuthOptions | null","model","where","nested: Record<string, any>"],"mappings":"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"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///D:/Muhammad%20Shariq/GIAIC/Hackathon/Hackathon%202/Phase3/frontend/node_modules/better-auth/dist/adapters/memory-adapter/index.mjs"],"sourcesContent":["import { memoryAdapter } from \"./memory-adapter.mjs\";\n\nexport { memoryAdapter };"],"names":[],"mappings":";AAAA","ignoreList":[0]}}]
}